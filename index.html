<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScoreKeeper">
    <title>ScoreKeeper</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Mono+One&family=Outfit:wght@300;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --neon-pink: #ff006e;
            --neon-blue: #00f5ff;
            --neon-yellow: #ffbe0b;
            --neon-green: #39ff14;
            --dark-bg: #0a0e27;
            --card-bg: #151b3d;
            --text-primary: #ffffff;
            --text-dim: #8892b0;
        }
        
        /* Stainless Steel Theme - Based on metallic UI kit */
        body[data-theme="stainless"] {
            --neon-pink: #718096;
            --neon-blue: #a0aec0;
            --neon-yellow: #cbd5e0;
            --neon-green: #90a4ae;
            --dark-bg: linear-gradient(180deg, #d0d5db 0%, #9ca3af 50%, #b0b8c0 100%);
            --card-bg: #e2e8f0;
            --text-primary: #2d3748;
            --text-dim: #718096;
        }
        
        body[data-theme="stainless"] {
            background: linear-gradient(180deg, #d0d5db 0%, #9ca3af 50%, #b0b8c0 100%);
        }
        
        body[data-theme="stainless"]::before {
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.15) 0%, transparent 40%),
                linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
        }
        
        /* Stainless Steel - Metallic button effects with radial gradient */
        body[data-theme="stainless"] .tab-btn,
        body[data-theme="stainless"] .voice-btn,
        body[data-theme="stainless"] button {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            color: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.25),
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        body[data-theme="stainless"] .tab-btn.active,
        body[data-theme="stainless"] .voice-btn.listening {
            background: radial-gradient(circle at 30% 30%, #90caf9, #64b5f6);
            color: #1e3a5f;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 1px 2px rgba(255, 255, 255, 0.5),
                0 0 15px rgba(144, 202, 249, 0.4);
        }
        
        body[data-theme="stainless"] .voice-btn.manual-mode-inactive {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }
        body[data-theme="stainless"] .voice-btn:not(.manual-mode-inactive):hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.4);
        }
        body[data-theme="stainless"] button:hover {
            transform: translateY(-2px);
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.4);
        }
        body[data-theme="stainless"] .mic-icon {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-btn:hover .mic-icon {
            color: #1a202c;
        }
        body[data-theme="stainless"] .voice-btn.listening .mic-icon {
            animation: blinkRedStainless 0.8s ease-in-out infinite;
        }
        @keyframes blinkRedStainless {
            0%, 100% { 
                color: #c53030;
                filter: drop-shadow(0 0 6px rgba(197, 48, 48, 0.6));
            }
            50% { 
                color: #1e3a5f;
                filter: drop-shadow(0 0 8px rgba(30, 58, 95, 0.6));
            }
        }
        
        body[data-theme="stainless"] .speaker-icon {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-btn:hover .speaker-icon {
            color: #1a202c;
        }
        
        body[data-theme="stainless"] .tab-btn:not(.active) {
            background: radial-gradient(circle at 30% 30%, #cbd5e0, #a0aec0);
        }
        
        body[data-theme="stainless"] .tab-btn:not(.active):hover {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
        }
        
        body[data-theme="stainless"] .crowns-table th {
            background: radial-gradient(circle at 30% 30%, #cbd5e0, #a0aec0);
            color: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2),
                0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        body[data-theme="stainless"] .crowns-table td {
            background: rgba(226, 232, 240, 0.5);
            color: #2d3748;
            border: 1px solid rgba(160, 174, 192, 0.3);
        }
        
        body[data-theme="stainless"] .crowns-table .round-label {
            background: rgba(0, 0, 0, 0.15) !important;
        }
        
        body[data-theme="stainless"] .card,
        body[data-theme="stainless"] .side-menu,
        body[data-theme="stainless"] .tab-navigation {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        body[data-theme="stainless"] #gameStateBtn {
            background: radial-gradient(circle at 30% 30%, #81c784, #66bb6a) !important;
            color: #1b5e20 !important;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.6),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }
        body[data-theme="stainless"] #gameStateBtn:hover {
            background: radial-gradient(circle at 30% 30%, #a5d6a7, #81c784) !important;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        body[data-theme="stainless"] .actions {
            background: linear-gradient(to top, rgba(160, 174, 192, 0.8) 0%, transparent);
        }
        
        /* Metallic input fields */
        body[data-theme="stainless"] input[type="text"],
        body[data-theme="stainless"] input[type="number"],
        body[data-theme="stainless"] select {
            background: radial-gradient(circle at 50% 0%, #f7fafc, #e2e8f0);
            color: #2d3748;
            border: 1px solid #a0aec0;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        body[data-theme="stainless"] .hamburger-line {
            background: #4a5568;
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        /* Engraved/carved text effect for Stainless Steel */
        body[data-theme="stainless"] h1 {
            background: none;
            -webkit-background-clip: initial;
            -webkit-text-fill-color: initial;
            background-clip: initial;
            color: #4a5568;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.8),     /* White highlight below */
                0 -1px 0 rgba(0, 0, 0, 0.4),          /* Dark shadow above */
                1px 1px 2px rgba(0, 0, 0, 0.2);       /* Subtle depth */
        }
        
        body[data-theme="stainless"] .subtitle {
            color: #718096;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        /* Fix placeholder text contrast in Stainless Steel */
        body[data-theme="stainless"] input[type="text"]::placeholder {
            color: #4a5568; /* Dark gray - same as carved text */
            opacity: 1;
        }
        
        body {
            font-family: Outfit, sans-serif;
            background: var(--dark-bg);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
            padding-bottom: 90px;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 0, 110, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 245, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 190, 11, 0.1) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
        }
        .container {
            max-width: 414px;
            margin: 0 auto;
            padding: 16px;
            position: relative;
            z-index: 1;
        }
        header {
            text-align: left;
            padding: 16px 0 16px 0;
            animation: slideDown 0.6s ease-out;
            position: relative;
            overflow: visible;
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .hamburger-btn {
            position: absolute;
            top: 16px;
            right: 0;
            width: 44px;
            height: 44px;
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
            z-index: 10002;
            pointer-events: auto;
        }
        .hamburger-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }
        .hamburger-btn.active {
            border-color: var(--neon-pink);
        }
        /* Custom Modal for Final Scores */
        .final-scores-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: flex-start; /* Align to top instead of center */
            padding-top: 20px; /* Add top padding for spacing */
            animation: fadeIn 0.3s ease-out;
        }
        
        .final-scores-modal.show {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .final-scores-content {
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 16px;
            padding: 20px;
            max-width: min(95vw, 414px); /* Constrain to iPhone XS Max width */
            width: calc(100vw - 20px); /* Reduce margins for more space */
            max-height: 90vh; /* Use most of the viewport height */
            height: auto; /* Allow dynamic height based on content */
            overflow-y: auto; /* Enable vertical scrolling if needed */
            box-sizing: border-box;
            margin: 10px; /* Small margin from edges */
            min-width: 280px; /* Minimum width for readability */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.4s ease-out;
        }
        
        /* WCAG compliant Instructions panel styling */
        #standardModeInstructions {
            background: rgba(255, 255, 255, 0.95) !important;
            color: #2d3748 !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }
        
        #standardModeInstructions strong {
            color: #1a202c !important;
        }
        
        /* Stainless theme adjustments for Instructions panel */
        body[data-theme="stainless"] #standardModeInstructions {
            background: rgba(248, 250, 252, 0.98) !important;
            color: #1a365d !important;
            border: 1px solid rgba(45, 55, 72, 0.15) !important;
        }
        
        body[data-theme="stainless"] #standardModeInstructions strong {
            color: #0f2132 !important;
        }
        
        /* Custom Game Tracking Modal - Higher z-index to appear above hamburger menu */
        #customGameTrackingModal {
            z-index: 10010 !important;
        }
        
        /* Custom Games Viewer Modal - Higher z-index to appear above hamburger menu */
        #customGamesViewerModal {
            z-index: 10010 !important;
        }
        
        /* Custom Game Statistics Modal - Higher z-index to appear above hamburger menu */
        #customGameStatisticsModal {
            z-index: 10010 !important;
        }
        
        /* Confirmation modals must appear above custom game modals */
        #customAlertModal,
        #customConfirmModal,
        #customPromptModal {
            z-index: 10020 !important;
        }
        
        /* iPhone-specific optimizations for scorecard viewing */
        @media (max-width: 428px) {
            .final-scores-modal {
                padding-top: 10px; /* Reduce top padding on small screens */
            }
            
            .final-scores-content {
                margin: 5px; /* Smaller margins for maximum space */
                padding: 15px; /* Slightly less padding */
                max-height: 92vh; /* Use even more of the viewport height */
                border-radius: 12px; /* Slightly smaller border radius */
            }
            
            #scorecardDisplay,
            #winsTrackerDisplay {
                max-height: calc(92vh - 110px) !important; /* Maximize content area */
                padding: 2px !important; /* Minimal padding */
            }
        }
            position: relative;
            box-sizing: border-box;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .final-scores-title {
            font-family: 'Rubik Mono One', monospace;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .final-scores-winner {
            font-family: 'Rubik Mono One', monospace;
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 25px;
            color: var(--neon-yellow);
            font-weight: 900;
            padding: 15px;
            background: rgba(255, 190, 11, 0.1);
            border-radius: 10px;
            border: 2px solid var(--neon-yellow);
        }
        
        .final-scores-list {
            list-style: none;
            padding: 0;
            margin: 0 0 25px 0;
        }
        
        .final-scores-list li {
            padding: 12px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: Outfit, sans-serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            border-left: 4px solid var(--neon-blue);
        }
        
        .final-scores-list li:first-child {
            border-left-color: var(--neon-yellow);
            background: rgba(255, 190, 11, 0.05);
        }
        
        .final-scores-ok-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000000;
            border: none;
            border-radius: 12px;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            transition: all 0.3s ease;
        }
        
        .final-scores-ok-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
        }
        
        .final-scores-ok-btn:active {
            transform: translateY(0);
        }
        /* Golf Course Selection Modal */
        .course-list-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .course-list-container::-webkit-scrollbar {
            width: 8px;
        }
        .course-list-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        .course-list-container::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 4px;
        }
        .course-list-container::-webkit-scrollbar-thumb:hover {
            background: var(--neon-pink);
        }
        .course-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-dim);
            font-family: Outfit, sans-serif;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 2px dashed rgba(0, 245, 255, 0.3);
        }
        .course-list-empty-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        .course-item {
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(0, 245, 255, 0.3);
            transition: all 0.3s ease;
            font-family: Outfit, sans-serif;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .course-item:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-blue);
        }
        .course-item-main {
            flex: 1;
            cursor: pointer;
            min-width: 0;
        }
        .course-item-main:hover {
            transform: translateX(5px);
        }
        .course-item-name {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 5px;
        }
        .course-item-details {
            font-size: 0.9rem;
            color: var(--text-dim);
        }
        .course-item-details span {
            margin-right: 15px;
        }
        .course-item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .course-action-btn {
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        .course-action-btn:hover {
            transform: scale(1.1);
        }
        .course-action-btn.edit-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-blue);
        }
        .course-action-btn.delete-btn:hover {
            background: rgba(255, 0, 110, 0.2);
            border-color: var(--neon-pink);
        }
        .course-action-btn-text {
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            color: var(--text-primary);
        }
        .course-action-btn-text:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-blue);
            transform: translateY(-2px);
        }
        body[data-theme="stainless"] .course-list-empty {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(160, 174, 192, 0.4);
            color: #718096;
        }
        body[data-theme="stainless"] .course-item {
            background: rgba(255, 255, 255, 0.1);
            border-color: #cbd5e0;
        }
        body[data-theme="stainless"] .course-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .course-item-name {
            color: #2d3748;
        }
        body[data-theme="stainless"] .course-item-details {
            color: #718096;
        }
        body[data-theme="stainless"] .course-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border-color: #cbd5e0;
        }
        body[data-theme="stainless"] .course-action-btn.edit-btn:hover {
            background: rgba(160, 174, 192, 0.3);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .course-action-btn.delete-btn:hover {
            background: rgba(255, 0, 110, 0.15);
            border-color: #e53e3e;
        }
        body[data-theme="stainless"] .course-action-btn-text {
            background: rgba(255, 255, 255, 0.2);
            border-color: #cbd5e0;
            color: #2d3748;
        }
        body[data-theme="stainless"] .course-action-btn-text:hover {
            background: rgba(160, 174, 192, 0.3);
            border-color: #a0aec0;
        }
        /* Custom Dialog Styles */
        .custom-dialog-message {
            font-family: Outfit, sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            padding: 20px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .custom-dialog-message strong {
            font-weight: 800;
            color: var(--text-primary);
        }
        /* Save options for Golf modal */
        .save-options-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .save-options-row {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .save-options-label {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 0.95em;
            margin: 0;
        }
        
        .save-option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .save-option-item label {
            cursor: pointer;
            user-select: none;
            color: var(--text-primary);
            font-size: 0.9em;
        }
        
        body[data-theme="stainless"] .save-options-container {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .wins-tracker-tab {
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .saved-scorecard-item {
            border: 1px solid var(--text-dim) !important;
        }
        
        .saved-scorecard-item:hover {
            background: rgba(255,255,255,0.1) !important;
            border-color: var(--neon-blue) !important;
            transform: translateX(5px);
        }
        
        body[data-theme="stainless"] .saved-scorecard-item {
            border: 1px solid #718096 !important;
        }
        
        body[data-theme="stainless"] .saved-scorecard-item:hover {
            background: rgba(0,0,0,0.1) !important;
            border-color: #64b5f6 !important;
        }
        
        .custom-prompt-input {
            width: 100%;
            padding: 12px 15px;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 1rem;
            font-weight: 600;
        }
        .custom-prompt-input:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        body[data-theme="stainless"] .custom-dialog-message {
            background: rgba(255, 255, 255, 0.1);
            color: #2d3748;
        }
        body[data-theme="stainless"] .custom-prompt-input {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .custom-prompt-input:focus {
            border-color: #a0aec0;
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.3);
        }
        /* Edit Course Grid */
        .edit-course-grid {
            display: grid;
            grid-template-columns: 40px repeat(6, 1fr);
            gap: 4px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
        }
        .edit-course-grid-header {
            font-weight: 700;
            color: var(--text-primary);
            padding: 6px 2px;
            text-align: center;
            font-size: 0.85rem;
        }
        .edit-course-grid-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 2px;
        }
        .edit-course-input {
            width: 100%;
            padding: 6px 4px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
        }
        /* Hide number input spinner arrows */
        .edit-course-input::-webkit-outer-spin-button,
        .edit-course-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .edit-course-input[type=number] {
            -moz-appearance: textfield;
        }
        .edit-course-input:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: 0 0 8px rgba(0, 245, 255, 0.3);
        }
        body[data-theme="stainless"] .edit-course-grid {
            background: rgba(255, 255, 255, 0.1);
        }
        body[data-theme="stainless"] .edit-course-grid-header {
            color: #2d3748;
        }
        body[data-theme="stainless"] .edit-course-input {
            background: rgba(255, 255, 255, 0.3);
            border-color: #cbd5e0;
            color: #2d3748;
        }
        body[data-theme="stainless"] .edit-course-input:focus {
            border-color: #a0aec0;
            box-shadow: 0 0 8px rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .edit-yrd-name-input {
            background: rgba(255, 255, 255, 0.3) !important;
            border-color: #cbd5e0 !important;
            color: #2d3748 !important;
        }
        body[data-theme="stainless"] .edit-yrd-name-input:focus {
            border-color: #a0aec0 !important;
            box-shadow: 0 0 8px rgba(160, 174, 192, 0.3) !important;
        }
        
        /* Stainless Steel Theme */
        body[data-theme="stainless"] .final-scores-content {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            border: 2px solid #a0aec0;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        body[data-theme="stainless"] .final-scores-title {
            background: none;
            -webkit-background-clip: initial;
            -webkit-text-fill-color: initial;
            background-clip: initial;
            color: #4a5568;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.8),     /* White highlight below */
                0 -1px 0 rgba(0, 0, 0, 0.4),          /* Dark shadow above */
                1px 1px 2px rgba(0, 0, 0, 0.2);       /* Subtle depth */
        }
        
        body[data-theme="stainless"] .final-scores-winner {
            color: #2d3748;
            background: linear-gradient(135deg, #f4e4a6, #d4af37);
            border: 2px solid #b8941e;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.6),
                0 4px 8px rgba(212, 175, 55, 0.3);
        }
        
        body[data-theme="stainless"] .final-scores-list li {
            background: rgba(255, 255, 255, 0.2);
            color: #2d3748;
            border-left-color: #718096;
        }
        
        body[data-theme="stainless"] .final-scores-list li:first-child {
            border-left-color: #d4af37;
            background: rgba(244, 228, 166, 0.2);
        }
        
        body[data-theme="stainless"] .final-scores-ok-btn {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            color: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.25),
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        body[data-theme="stainless"] .final-scores-ok-btn:hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .hamburger-line {
            width: 24px;
            height: 3px;
            background: var(--neon-blue);
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        .hamburger-btn.active .hamburger-line:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        .hamburger-btn.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        .hamburger-btn.active .hamburger-line:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.9);
            backdrop-filter: blur(5px);
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .side-menu {
            position: fixed;
            top: 0;
            right: -320px;
            width: 320px;
            max-width: 85%;
            height: 100%;
            background: var(--card-bg);
            border-left: 3px solid var(--neon-blue);
            z-index: 10001;
            padding: 80px 20px 20px 20px;
            overflow-y: auto;
            transition: right 0.3s ease;
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.9);
        }
        .side-menu.active {
            right: 0 !important;
        }
        .menu-section {
            margin-bottom: 30px;
        }
        .menu-section-title {
            font-family: Outfit, sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-primary);
            text-align: left;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        h1 {
            font-family: 'Rubik Mono One', monospace;
            font-size: 1.475rem;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 0, 110, 0.5);
            line-height: 1.3;
            display: block;
        }
        /* iPhone XS Max specific optimizations */
        @media (max-width: 414px) {
            h1 {
                font-size: 1.475rem;
                letter-spacing: 1px;
            }
            .score-number {
                font-size: 1.85rem;
                min-width: 45px;
            }
            .player-name {
                font-size: 1.1rem;
                padding: 6px 10px;
            }
            .control-btn {
                width: 42px;
                height: 42px;
                font-size: 1.4rem;
            }
            .delete-btn {
                width: 42px;
                height: 42px;
            }
            button {
                font-size: 0.9rem;
                padding: 11px 14px;
            }
            .tab-btn {
                font-size: 0.85rem;
                padding: 10px 12px;
            }
            input[type="text"] {
                font-size: 0.9rem;
                padding: 10px 12px;
            }
            .game-type-select {
                font-size: 0.95rem;
                padding: 14px 18px;
                padding-right: 38px;
            }
            .crowns-table th,
            .crowns-table td {
                padding: 5px 6px;
                min-width: 45px;
                font-size: 0.85rem;
            }
            .crowns-table th {
                font-size: 0.85rem;
            }
            .crowns-table .round-label {
                min-width: 30px;
                padding: 5px 3px;
                font-size: 0.85rem;
            }
        }
        @media (max-width: 400px) {
            h1 {
                font-size: 1.475rem;
                letter-spacing: 1px;
            }
            .score-number {
                font-size: 1.75rem;
            }
        }
        .subtitle {
            display: none;
        }
        .game-type-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .settings-row {
            display: none;
        }
        /* Old game-type styles removed - now using custom dropdown */
        .add-player-section {
            margin: 0 0 10px 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        input[type="text"] {
            flex: 1;
            padding: 10px 14px;
            background: var(--card-bg);
            border: 2px solid transparent;
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: Outfit, sans-serif;
            font-weight: 300;
            transition: all 0.3s ease;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.3);
        }
        input[type="text"]::placeholder {
            color: #5f6a7c; /* 30% darker than var(--text-dim) #8892b0 */
        }
        button {
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border: none;
            border-radius: 12px;
            color: black;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            position: relative;
            overflow: hidden;
            min-height: 44px;
        }
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        button:active::before {
            width: 300px;
            height: 300px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
        }
        button:active {
            transform: scale(0.95);
        }
        .btn-secondary {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .players-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 16px 0;
        }
        .player-card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 14px 16px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            animation: scaleIn 0.4s ease-out both;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--neon-pink), var(--neon-blue), var(--neon-yellow));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .player-card:active::before {
            opacity: 1;
        }
        .player-name {
            flex: 1;
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background 0.3s ease;
        }
        .player-name:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .player-name-input {
            flex: 1;
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            padding: 8px 12px;
            font-family: Outfit, sans-serif;
            outline: none;
        }
        /* When player-name-input is inside a table header, override flex */
        th .player-name-input {
            flex: none;
            width: auto;
            max-width: 100px;
            font-size: 0.95rem;
            padding: 4px 8px;
        }
        .player-name-text {
            cursor: pointer;
            display: inline-block;
        }
        .score-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .score-number {
            font-family: 'Rubik Mono One', monospace;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            text-shadow: 0 0 30px rgba(255, 190, 11, 0.5);
            transition: transform 0.2s ease;
            min-width: 50px;
            text-align: right;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
        }
        .score-number:hover {
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0.8;
        }
        .score-input {
            font-family: 'Rubik Mono One', monospace;
            font-size: 2rem;
            background: rgba(255, 190, 11, 0.2);
            border: 2px solid var(--neon-yellow);
            border-radius: 8px;
            padding: 8px;
            min-width: 70px;
            text-align: right;
            color: var(--text-primary);
            outline: none;
        }
        /* Remove spinner buttons for number input on mobile */
        .score-input::-webkit-outer-spin-button,
        .score-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .score-input[type=number] {
            -moz-appearance: textfield;
        }
        .score-number.pulse {
            animation: scorePulse 0.3s ease;
        }
        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .controls {
            display: flex;
            gap: 8px;
        }
        .control-btn {
            width: 44px;
            height: 44px;
            padding: 0;
            font-size: 1.5rem;
            font-weight: 800;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-increment {
            background: linear-gradient(135deg, var(--neon-green), #2ed600);
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
        }
        .btn-decrement {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }
        .delete-btn {
            width: 44px;
            height: 44px;
            padding: 0;
            background: rgba(255, 0, 110, 0.2);
            border: 1px solid var(--neon-pink);
            font-size: 1.2rem;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .delete-btn:hover {
            background: rgba(255, 0, 110, 0.4);
        }
        .actions {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            max-width: 414px;
            width: calc(100% - 32px);
            background: linear-gradient(to top, var(--dark-bg) 80%, transparent);
            padding: 16px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .actions button {
            flex: 1;
        }
        #gameStateBtn {
            background: linear-gradient(135deg, var(--neon-green), #2ed600) !important;
            color: black !important;
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4) !important;
            flex: 0.8; /* Slightly narrower */
        }
        #gameStateBtn:hover {
            box-shadow: 0 6px 20px rgba(57, 255, 20, 0.6) !important;
        }
        /* Pulse animation for Start Game button */
        #gameStateBtn.pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 6px 25px rgba(57, 255, 20, 0.8);
                transform: scale(1.05);
                filter: brightness(1.2);
            }
        }
        .btn-secondary {
            flex: 1.4; /* Wider to prevent text wrapping */
        }
        .actions button:last-child {
            flex: 0.8; /* Reset All - slightly narrower */
        }
        .tab-navigation {
            display: flex;
            gap: 10px;
            margin: 0 0 20px 0;
            justify-content: center;
        }
        .tab-btn {
            padding: 10px 6px;
            background: rgba(0, 245, 255, 0.2); /* Light blue background for inactive */
            border: 2px solid rgba(0, 245, 255, 0.3); /* Subtle border */
            border-radius: 12px;
            color: #00f5ff; /* Bright cyan text for good contrast */
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: none;
            position: relative;
            overflow: hidden;
            min-height: 44px;
        }
        .tab-btn.active {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000000; /* Black text on bright background */
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .tab-btn:not(.active):hover {
            background: rgba(0, 245, 255, 0.3); /* Brighter on hover */
            border-color: rgba(0, 245, 255, 0.5);
            transform: translateY(-2px);
        }
        .tab-btn:active {
            transform: scale(0.95);
        }
        
        /* Scorecard tab content */
        .scorecard-tab-content {
            width: 100%;
        }
        
        /* Wins tracker input fields */
        .wins-tracker-input:hover {
            border-color: var(--neon-blue) !important;
            background: rgba(0, 245, 255, 0.05) !important;
        }
        .wins-tracker-input:focus {
            outline: none;
            border-color: var(--neon-pink) !important;
            background: rgba(255, 0, 110, 0.05) !important;
        }
        
        /* Reduce padding on Scoring tab only for more space */
        .tab-btn:first-child {
            padding: 10px 4px;
        }
        
        .voice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
        }
        .voice-btn:active {
            transform: scale(0.95);
        }
        .tab-navigation-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin: 0 0 0 0;
        }
        .tab-navigation {
            display: flex;
            gap: 5px;
            flex: 1;
            background: rgba(10, 14, 39, 0.6); /* Darker background for contrast */
            border-radius: 12px;
            padding: 4px;
            position: relative;
            top: -3px; /* Move up 3px */
        }
        .tab-btn,
        .voice-btn {
            flex: 1;
        }
        
        .tab-btn {
            background: transparent;
            box-shadow: none;
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        
        .voice-btn {
            flex: 0 0 auto;
            min-width: 50px;
            width: 50px;
        }
        
        .voice-btn.manual-mode-inactive {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.6);
        }
        
        .voice-btn.manual-mode-inactive:hover {
            transform: translateY(0) !important;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.3) !important;
        }
        .voice-btn.manual-mode-inactive:hover .mic-icon {
            transform: scale(1) !important;
        }
        
        .game-type-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: -7px 0 10px 0;
            position: relative;
            z-index: 1002; /* Ensure game type row is above all other dropdowns */
        }
        
        /* When in grid mode (isDoneAdding), move game-type into tab bar space */
        body.grid-mode .tab-navigation-container .tab-navigation {
            display: none;
        }
        
        body.grid-mode .tab-navigation-container {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            align-items: flex-start;
        }
        
        body.grid-mode .game-type-row {
            flex: 1;
            min-width: 0;
            margin: 0;
            background: rgba(10, 14, 39, 0.6);
            border-radius: 12px;
            padding: 6px 10px;
            position: relative;
            top: -3px;
            gap: 6px;
            order: -1;
        }
        
        body.grid-mode .game-type-label {
            font-size: 0.75rem;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        body.grid-mode .custom-dropdown-wrapper-game {
            min-width: 100px;
            flex: 1 1 auto;
        }
        
        body.grid-mode .custom-dropdown {
            font-size: 0.8rem;
            padding: 7px 8px;
            padding-right: 26px;
        }
        
        body.grid-mode .dropdown-arrow {
            right: 6px;
            font-size: 0.7rem;
        }
        
        body[data-theme="stainless"].grid-mode .game-type-row {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        .game-type-label {
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }
        
        .custom-dropdown-wrapper-game {
            flex: 1;
            min-width: 180px;
            position: relative;
            z-index: 1001; /* Ensure game type dropdown appears above other dropdowns */
        }
        
        .custom-dropdown-wrapper-darts {
            flex: 0 0 auto;
            width: 80px;
            min-width: 80px;
            position: relative;
            z-index: 100; /* Lower z-index so game type dropdown appears above */
        }
        
        .dropdown-list-item-game {
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dropdown-list-item-game:hover {
            background: rgba(0, 245, 255, 0.1);
            color: var(--neon-blue);
        }
        
        .theme-selector {
            position: relative;
        }
        
        .theme-selector .custom-dropdown {
            width: 100%;
        }
        
        .theme-selector .custom-dropdown-list {
            width: 100%;
        }
        
        .scorecard-selector {
            position: relative;
        }
        
        .scorecard-selector .custom-dropdown {
            width: 100%;
        }
        
        .scorecard-selector .custom-dropdown-list {
            width: 100%;
            /* Removed max-height and overflow-y - let the base .custom-dropdown-list handle open/closed states */
        }
        
        .wins-tracker-selector {
            position: relative;
        }
        
        .wins-tracker-selector .custom-dropdown {
            width: 100%;
        }
        
        .wins-tracker-selector .custom-dropdown-list {
            width: 100%;
            z-index: 1500; /* Higher than other dropdowns to appear on top */
        }
        
        .dropdown-list-item-theme {
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dropdown-list-item-theme:hover {
            background: rgba(0, 245, 255, 0.1);
            color: var(--neon-blue);
        }
        
        .add-player-section {
            margin: 0 0 10px 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .player-inputs-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px; /* Reduced gap for better iPhone fit */
            margin-bottom: 8px;
        }
        .player-inputs-row:last-child {
            margin-bottom: 0;
        }
        .player-buttons-row {
            display: flex;
            gap: 10px;
        }
        .add-player-section input[type="text"] {
            flex: 1;
            padding: 8px 8px; /* Reduced horizontal padding for iPhone */
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: Outfit, sans-serif;
            font-weight: 400;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.2);
            text-align: center;
            min-width: 0; /* Allow inputs to shrink below their content size */
        }
        .add-player-section input[type="text"]::placeholder {
            color: #a8b5d1;
            opacity: 1;
            text-align: center;
        }
        .add-player-section input[type="text"]:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.4);
        }
        .add-more-btn,
        .done-adding-btn {
            flex: 1;
            padding: 8px 20px;
            border: 2px solid;
            border-radius: 8px;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: black;
        }
        .add-more-btn {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border-color: var(--neon-blue);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .done-adding-btn {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border-color: var(--neon-blue);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .add-more-btn:hover,
        .done-adding-btn:hover {
            transform: translateY(-2px);
        }
        .add-more-btn:active,
        .done-adding-btn:active {
            transform: translateY(0);
        }
        @media (max-width: 320px) {
            /* Only stack vertically on iPhone SE and smaller screens */
            .player-inputs-row {
                grid-template-columns: 1fr;
            }
            .add-player-section input[type="text"] {
                font-size: 0.8rem;
                padding: 6px 8px;
            }
        }
        .add-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--neon-pink), #d90058);
            border: 2px solid var(--neon-pink);
            border-radius: 8px;
            color: white;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 0, 110, 0.4);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* WALLS - Ultra Minimal for Chrome macOS Stability */
        .walls-container {
            display: block;
            margin: 20px auto;
            max-width: 1200px;
            overflow: hidden;
        }
        .wall-section {
            width: 48%;
            float: left;
            margin: 0 1%;
            background: #2a2d3a;
            padding: 20px;
            border: 2px solid #444;
            min-height: 200px;
            box-sizing: border-box;
        }
        .wall-section.fame {
            border-color: #39ff14;
        }
        .wall-section.shame {
            border-color: #ff006e;
        }
        .wall-title {
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0px;
            white-space: nowrap;
            color: #fff;
        }
        .wall-title.fame {
            color: #d4af37;
        }
        .wall-title.shame {
            color: #ff006e;
        }
        .wall-entry {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid;
        }
        .wall-entry.fame {
            border-left-color: var(--neon-green);
        }
        .wall-entry.shame {
            border-left-color: var(--neon-pink);
        }
        .wall-entry-game {
            font-size: 0.85rem;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            font-weight: 800;
        }
        .wall-entry-player {
            font-size: 1rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .wall-entry-score {
            font-size: 1.2rem;
            font-weight: 800;
            font-family: 'Rubik Mono One', monospace;
        }
        .wall-entry.fame .wall-entry-score {
            color: var(--neon-green);
        }
        .wall-entry.shame .wall-entry-score {
            color: var(--neon-pink);
        }
        .wall-entry-date {
            font-size: 0.7rem;
            color: var(--text-dim);
            font-style: italic;
            margin-top: 3px;
        }
        .wall-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        @media (max-width: 600px) {
            .walls-container {
                flex-direction: column;
            }
        }
        
        /* Darts 501 Styling */
        .game-header {
            background: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: bold;
            font-size: 0.95rem;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .game-header-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-header-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 2px solid var(--text-primary);
            border-radius: 4px;
            background: transparent;
            position: relative;
            margin: 0;
        }
        
        .game-header-checkbox:checked {
            background: var(--neon-blue);
            border-color: var(--neon-blue);
        }
        
        .game-header-checkbox:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 16px;
            font-weight: bold;
        }
        
        .game-header-label {
            cursor: pointer;
            user-select: none;
        }
        
        .darts-player-card {
            background: white;
            margin: 0;
            padding: 8px 12px;
            border-radius: 8px;
            display: flex !important;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            visibility: visible !important;
            opacity: 1 !important;
            width: 100% !important;
            min-height: 60px !important;
        }
        
        #playersContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            margin: 0;
            padding: 0;
            visibility: visible;
            opacity: 1;
        }
        
        .darts-player-card.active {
            background: #90CAF9 !important;
        }
        
        .darts-player-score {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
            min-width: 80px;
            font-family: 'Courier New', monospace;
        }
        
        .darts-player-name {
            font-size: 1rem;
            font-weight: bold;
            color: #333;
            min-width: 80px;
        }
        
        .darts-dart-boxes {
            display: flex;
            gap: 5px;
        }
        
        .darts-dart-box {
            width: 45px;
            height: 45px;
            border: 2px solid #ddd;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            background: white;
            color: black;
            font-family: 'Courier New', monospace;
        }
        
        .darts-dart-box.double {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .darts-dart-box.triple {
            background: #FF9800;
            color: white;
            border-color: #FF9800;
        }
        
        .darts-dart-box.uncounted {
            background: white;
            color: red !important;
            border-color: #ddd;
            opacity: 1;
        }
        
        .darts-dart-box.double.uncounted {
            opacity: 1;
            color: red !important;
        }
        
        .darts-dart-box.triple.uncounted {
            opacity: 1;
            color: red !important;
        }
        
        .darts-stats {
            margin-left: auto;
            text-align: right;
        }
        
        .darts-sets-legs {
            font-size: 1rem;
            color: #333;
            font-weight: bold;
            white-space: nowrap;
        }
        
        /* Keypad */
        .darts-keypad {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 15px;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
        }
        
        .darts-keypad-btn {
            padding: 12px;
            font-size: 0.95rem;
            font-weight: bold;
            background: white;
            color: #333;
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 50px;
        }
        
        .darts-keypad-btn:hover {
            background: #e8e8e8;
            transform: scale(1.05);
        }
        
        .darts-keypad-btn:active {
            transform: scale(0.95);
        }
        
        .darts-keypad-btn.double {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .darts-keypad-btn.triple {
            background: #FF9800;
            color: white;
            border-color: #FF9800;
        }
        
        .darts-keypad-btn.undo {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10003;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        
        .modal.active {
            display: flex;
            pointer-events: all;
        }
        
        .modal-content {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 15px;
            max-width: min(95vw, 414px); /* Constrain to iPhone XS Max width */
            width: calc(100vw - 20px); /* Reduce margins for more space */
            max-height: 90vh; /* Use most of the viewport height */
            height: auto; /* Allow dynamic height based on content */
            overflow-y: auto; /* Enable vertical scrolling if needed */
            min-width: 280px; /* Minimum width for readability */
            text-align: center;
            pointer-events: all;
            box-sizing: border-box;
            margin: 10px; /* Small margin from edges */
        }
        
        .modal-content h2 {
            color: var(--neon-blue);
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .darts-player-score {
                font-size: 1.5rem;
                min-width: 60px;
            }
            
            .darts-player-name {
                font-size: 0.9rem;
                min-width: 60px;
            }
            
            .darts-dart-box {
                width: 35px;
                height: 35px;
                font-size: 0.8rem;
            }
            
            .darts-sets-legs {
                font-size: 0.7rem;
            }
            
            .darts-keypad {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        /* Player Setup */
        .player-chip {
            display: inline-block;
            background: #4CAF50;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
        }
        
        .remove-player {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .hidden {
            display: none;
        }
        
        #darts501Container {
            padding: 0;
            overflow: visible;
        }
        
        #gameArea {
            display: none;
        }
        
        #gameArea.active {
            display: block;
            overflow: visible;
        }
        
        .crowns-mode {
            display: none;
        }
        .crowns-mode.active {
            display: block;
        }
        .crowns-container {
            overflow-x: auto;
            overflow-y: visible;
            margin: 20px 0;
            padding-bottom: 20px;
            -webkit-overflow-scrolling: touch;
            width: 100%;
        }
        .crowns-table {
            border-collapse: collapse;
            background: var(--card-bg);
            border-radius: 12px;
            overflow: hidden;
            width: auto;
            min-width: 100%;
            display: table;
        }
        .crowns-table th,
        .crowns-table td {
            border: 1px solid rgba(0, 245, 255, 0.2);
            padding: 6px 8px;
            text-align: center;
            min-width: 50px;
        }
        .crowns-table th {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000000; /* Black text for better contrast on light blue */
            font-weight: 800;
            text-transform: uppercase;
            font-size: 1rem;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }
        .crowns-table th.player-name-header {
            cursor: pointer;
            transition: background 0.3s ease;
            min-width: 70px;
        }
        .crowns-table th.player-name-header:hover {
            background: rgba(0, 245, 255, 0.2);
        }
        .crowns-table th.crowns-player-header {
            cursor: pointer;
            transition: background 0.3s ease;
            min-width: 80px;
            width: auto;
        }
        .crowns-table th.crowns-player-header:hover {
            background: rgba(0, 245, 255, 0.2);
        }
        .crowns-table td.crowns-score:not(.golf-info-column) {
            min-width: 60px;
            width: auto;
        }
        .crowns-player-name-input {
            width: 90%;
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            padding: 8px 12px;
            font-family: Outfit, sans-serif;
            text-align: center;
        }
        .crowns-player-name-input:focus {
            outline: none;
            border-color: var(--neon-blue);
        }
        .crowns-table .round-label {
            background: rgba(0, 0, 0, 0.5);
            color: var(--text-primary);
            font-weight: 800;
            font-size: 0.9rem;
            position: sticky;
            left: 0;
            z-index: 5;
            border-right: 2px solid var(--neon-blue);
            min-width: 35px;
            padding: 6px 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .crowns-table td.round-label.highlighted {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc) !important; /* Neon blue highlight like tabs */
            color: #000000 !important; /* Black text on bright background */
            box-shadow: 0 2px 8px rgba(0, 245, 255, 0.4) !important;
        }
        
        .crowns-table td.crowns-hole-label.highlighted {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc) !important; /* Neon blue highlight like tabs */
            color: #000000 !important; /* Black text on bright background */
            box-shadow: 0 2px 8px rgba(0, 245, 255, 0.4) !important;
        }
        .crowns-table th.round-label {
            z-index: 15;
            color: #000000; /* Black text for better contrast on light blue */
        }
        .crown-icon {
            font-size: 1.08rem; /* 20% bigger than the 0.9rem base */
            display: inline-block;
            filter: drop-shadow(0 0 4px rgba(64, 64, 64, 0.8)) drop-shadow(0 0 8px rgba(64, 64, 64, 0.5));
            line-height: 1;
        }
        
        body[data-theme="stainless"] .crown-icon {
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 8px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 2px rgba(255, 215, 0, 0.4));
        }
        .crowns-table th.crowns-hole-label {
            color: #000000; /* Black text for better contrast on light blue */
            padding: 6px 6px;
        }
        .crowns-table td.crowns-hole-label {
            padding: 6px 6px;
        }
        
        /* Light green background for Tee column cells (not OUT, IN, TOT) */
        .crowns-table tbody tr:not(.total-row) td.crowns-hole-label.golf-info-column {
            background: rgba(57, 255, 20, 0.2) !important;
        }
        /* Yahtzee-specific styles */
        .yahtzee-available {
            background: rgba(0, 245, 255, 0.15) !important;
            cursor: pointer !important;
        }
        .yahtzee-available:hover {
            background: rgba(0, 245, 255, 0.3) !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }
        .yahtzee-used {
            background: rgba(0, 123, 255, 0.6) !important; /* Brighter blue instead of grey */
            opacity: 1; /* Remove opacity reduction */
            cursor: pointer !important;
        }
        .yahtzee-used:hover {
            background: rgba(0, 123, 255, 0.8) !important; /* Darker blue on hover */
        }
        .section-divider {
            border-top: 2px solid var(--neon-blue);
            border-bottom: 2px solid var(--neon-blue);
        }
        .yrd-column-header {
            cursor: pointer !important;
            position: relative;
        }
        .yrd-column-header:hover {
            background: rgba(0, 245, 255, 0.2) !important;
            color: var(--neon-blue) !important;
        }
        .yrd-column-header::after {
            content: '';
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            margin-left: 4px;
        }
        .yrd-column-header:hover::after {
            opacity: 1;
        }
        .crowns-table td {
            background: rgba(10, 14, 39, 0.6);
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .crowns-table td:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .crowns-table td.editable {
            background: rgba(0, 245, 255, 0.05);
        }
        .crowns-table td.newly-entered {
            background: rgba(57, 255, 20, 0.3);
            animation: highlightScore 0.5s ease-out;
        }
        @keyframes highlightScore {
            0% {
                background: rgba(57, 255, 20, 0.8);
                transform: scale(1.1);
            }
            100% {
                background: rgba(57, 255, 20, 0.3);
                transform: scale(1);
            }
        }
        .crowns-table .total-row {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.3), rgba(255, 68, 68, 0.3));
            border-top: 3px solid var(--neon-pink);
        }
        
        /* Add border under OUT row in golf mode */
        .crowns-table .golf-out-row {
            border-bottom: 3px solid var(--neon-pink);
        }
        .crowns-table .total-row td {
            font-size: 1rem;
            font-weight: 800;
            font-family: Outfit, sans-serif;
            text-transform: uppercase;
            color: var(--text-primary);
            background: transparent;
        }
        .crowns-score-input {
            width: 60px;
            padding: 8px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid var(--neon-blue);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            font-family: Outfit, sans-serif;
        }
        .crowns-score-input:focus {
            outline: none;
            border-color: var(--neon-pink);
        }
        .crowns-score-input::-webkit-outer-spin-button,
        .crowns-score-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .crowns-mode-toggle {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        .mode-toggle-btn {
            padding: 10px 20px;
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-dim);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .mode-toggle-btn.active {
            background: var(--neon-blue);
            color: var(--dark-bg);
            border-color: var(--neon-blue);
        }
        .empty-state {
            margin-top: 0;
            animation: fadeIn 0.8s ease-out;
        }
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        .empty-state-text {
            font-size: 1.1rem;
            font-weight: 300;
            letter-spacing: 1px;
        }
        .voice-btn {
            padding: 0 14px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border: none;
            border-radius: 12px;
            color: black;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            position: relative;
            overflow: hidden;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mic-icon {
            width: 28px !important;
            height: 28px !important;
            min-width: 28px;
            min-height: 28px;
            color: #000000;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .voice-btn:hover .mic-icon {
            transform: scale(1.1);
        }
        .voice-btn.listening .mic-icon {
            animation: blinkRed 0.8s ease-in-out infinite;
        }
        @keyframes blinkRed {
            0%, 100% { 
                color: #ff0000;
                filter: drop-shadow(0 0 8px rgba(255, 0, 0, 0.8));
            }
            50% { 
                color: #ffffff;
                filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.8));
            }
        }
        .voice-btn.listening {
            background: linear-gradient(135deg, var(--neon-pink), #d90058);
            animation: pulseButton 1s ease-in-out infinite;
        }
        
        /* Speaker icon styling */
        .speaker-icon {
            width: 28px !important;
            height: 28px !important;
            min-width: 28px;
            min-height: 28px;
            color: #000000;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .voice-btn:hover .speaker-icon {
            transform: scale(1.1);
        }
        #speakerBtn.speaker-muted .speaker-mute-line {
            display: block !important;
        }
        
        /* MICROPHONE STRIKETHROUGH - MATCHES SPEAKER BUTTON STYLE */
        #voiceBtn {
            position: relative !important;
        }
        
        /* Create thin diagonal line to match speaker button - but not when listening */
        #voiceBtn:not(.listening)::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 28px;
            height: 2.5px;
            background: currentColor;
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            z-index: 999;
        }

        
        @keyframes pulseButton {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 0, 110, 0.6), 0 0 40px rgba(255, 0, 110, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 0, 110, 1), 0 0 80px rgba(255, 0, 110, 0.6);
                transform: scale(1.05);
            }
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 2px 10px rgba(0, 245, 255, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 20px rgba(0, 245, 255, 0.6);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 2px 10px rgba(0, 245, 255, 0.3);
            }
        }
        .voice-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(21, 27, 61, 0.98);
            border: 2px solid var(--neon-blue);
            border-radius: 20px;
            padding: 30px 40px;
            z-index: 10000;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
            min-width: 280px;
            max-width: 414px; /* iPhone XS Max width */
            width: calc(100vw - 40px); /* Responsive width with margins */
            box-sizing: border-box;
        }
        
        .voice-feedback::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: -1;
        }
        .voice-feedback * {
            border: none !important;
            text-decoration: none !important;
            box-shadow: none !important;
            outline: none !important;
        }
        .voice-feedback > * {
            border: none !important;
            text-decoration: none !important;
        }
        .voice-feedback.show {
            display: block;
            animation: feedbackAppear 0.3s ease-out;
        }
        @keyframes feedbackAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        .voice-feedback-icon {
            font-size: 3rem;
            margin-bottom: 5px;
            animation: pulseIcon 1.5s ease-in-out infinite;
            border: none;
            outline: none;
            text-decoration: none;
            display: block;
            line-height: 1;
        }
        @keyframes pulseIcon {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .voice-feedback-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--neon-blue);
            margin-bottom: 10px;
            margin-top: 5px;
            border: none !important;
            outline: none;
            text-decoration: none !important;
            border-top: none !important;
            border-bottom: none !important;
            padding-top: 0;
            padding-bottom: 0;
            display: block;
            box-shadow: none !important;
            background: transparent;
        }
        .voice-feedback-transcript {
            font-size: 0.9rem;
            color: var(--text-dim);
            font-style: italic;
            margin-top: 10px;
            border: none !important;
            outline: none;
            padding: 0;
            text-decoration: none !important;
            border-top: none !important;
            padding-top: 0;
        }
        .voice-help {
            position: relative;
            flex: 1;
            min-width: 0;
        }
        .voice-help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        .voice-help-header:hover {
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        .voice-help-header.open {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-color: var(--neon-pink);
        }
        .voice-help-title {
            flex: 1;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
        }
        .voice-help-toggle {
            margin-left: 10px;
            transition: transform 0.3s ease;
            font-size: 0.8rem;
            color: #000;
        }
        .voice-help-header.open .voice-help-toggle {
            transform: rotate(180deg);
        }
        /* Golf Mode Toggle (below golf grid) */
        /* Golf Mode Toggle (inline with buttons) */
        .toggle-switch-container-inline {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }
        @media (max-width: 768px) {
            .golf-course-row {
                justify-content: center;
            }
            
            .toggle-switch-container-inline {
                order: 3; /* Move to next row on mobile */
                width: 100%;
                justify-content: center;
            }
            
            .btn-golf-course {
                flex: 1;
                min-width: 100px;
            }
        }
        /* Golf Course Selector */
        .golf-course-selector {
            padding: 10px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 2px solid rgba(0, 245, 255, 0.3);
        }
        
        /* Match game-type panel styling in grid mode */
        body.grid-mode .golf-course-selector {
            padding: 6px 10px;
            margin-bottom: 15px;
        }
        
        body.grid-mode .golf-course-label {
            font-size: 0.75rem;
        }
        
        body.grid-mode .golf-course-row {
            gap: 6px;
        }
        .golf-course-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .golf-course-label {
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .golf-course-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
        }
        .golf-course-input:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        /* Custom Dropdown for Golf Course */
        .custom-dropdown-wrapper {
            flex: 1;
            min-width: 200px;
            position: relative;
        }
        .custom-dropdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .custom-dropdown:hover {
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        .custom-dropdown.open {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-color: var(--neon-pink);
        }
        .dropdown-selected {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .dropdown-arrow {
            margin-left: 10px;
            transition: transform 0.3s ease;
            font-size: 0.8rem;
        }
        .custom-dropdown.open .dropdown-arrow {
            transform: rotate(180deg);
        }
        /* Dropdown list styles kept for potential future use */
        .custom-dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 0;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--neon-pink);
            border-top: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            z-index: 1000;
            transition: max-height 0.3s ease;
        }
        .custom-dropdown-list.open {
            max-height: 400px;
            overflow-y: auto;
        }
        .dropdown-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(0, 245, 255, 0.1);
        }
        .dropdown-course-name {
            flex: 1;
            cursor: pointer;
        }
        .dropdown-course-actions {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }
        .dropdown-action-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dropdown-action-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-blue);
            transform: scale(1.1);
        }
        .dropdown-list-item:last-child {
            border-bottom: none;
        }
        .dropdown-list-item:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .dropdown-course-name:hover {
            color: var(--neon-blue);
        }
        .dropdown-list-empty {
            padding: 15px;
            color: var(--text-dim);
            text-align: center;
            font-size: 0.9rem;
            font-style: italic;
        }
        .dropdown-add-new-btn {
            padding: 12px 15px;
            color: var(--neon-green);
            background: rgba(57, 255, 20, 0.1);
            border-top: 2px solid rgba(57, 255, 20, 0.3);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .dropdown-add-new-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            color: #39ff14;
        }
        /* Stainless theme for dropdown */
        body[data-theme="stainless"] .custom-dropdown {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .custom-dropdown:hover {
            border-color: #a0aec0;
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .custom-dropdown.open {
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .custom-dropdown-list {
            background: rgba(255, 255, 255, 0.95);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .dropdown-list-item {
            color: #2d3748;
            border-bottom-color: rgba(160, 174, 192, 0.2);
        }
        body[data-theme="stainless"] .dropdown-list-item:hover {
            background: rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .dropdown-course-name:hover {
            color: #4299e1;
        }
        body[data-theme="stainless"] .dropdown-action-btn {
            background: rgba(255, 255, 255, 0.3);
            border-color: #cbd5e0;
            color: #2d3748;
        }
        body[data-theme="stainless"] .dropdown-action-btn:hover {
            background: rgba(160, 174, 192, 0.4);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .dropdown-list-empty {
            color: #718096;
        }
        body[data-theme="stainless"] .dropdown-add-new-btn {
            color: #2f855a;
            background: rgba(72, 187, 120, 0.1);
            border-top-color: rgba(72, 187, 120, 0.3);
        }
        body[data-theme="stainless"] .dropdown-add-new-btn:hover {
            background: rgba(72, 187, 120, 0.2);
            color: #276749;
        }
        
        /* Steel theme for Voice Commands dropdown */
        body[data-theme="stainless"] .voice-help-header {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-header:hover {
            border-color: #a0aec0;
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .voice-help-header.open {
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .voice-help-content {
            background: rgba(255, 255, 255, 0.95);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .voice-help li {
            color: #2d3748;
            border-bottom-color: rgba(160, 174, 192, 0.2);
        }
        body[data-theme="stainless"] .voice-help li strong {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-content strong {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-title {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-toggle {
            color: #2d3748;
        }
        
        .btn-golf-course {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000;
            border: none;
            border-radius: 8px;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-golf-course:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .btn-golf-save {
            background: linear-gradient(135deg, var(--neon-green), #2ed600);
        }
        .btn-golf-save:hover {
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
        }
        body[data-theme="stainless"] .golf-course-selector {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(160, 174, 192, 0.4);
        }
        body[data-theme="stainless"] .golf-course-label {
            color: #2d3748;
        }
        body[data-theme="stainless"] .golf-course-input {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .btn-golf-course {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            color: #2d3748;
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.8),
                        inset 0 -1px 2px rgba(0, 0, 0, 0.25);
        }
        /* Golf Score Visual Indicators */
        .golf-over-par {
            border: 3px solid #ff0055;
            border-radius: 4px;
            font-weight: 900;
            color: #ff0055;
        }
        .golf-under-par {
            border: 3px solid var(--neon-blue);
            border-radius: 50%;
            font-weight: 900;
            color: var(--neon-blue);
        }
        /* Darker background for Tee, Par, HCP, YRD columns */
        .golf-info-column {
            background: rgba(0, 0, 0, 0.5) !important;
            font-weight: 800;
            font-size: 0.9rem;
            font-family: Outfit, sans-serif;
            min-width: 35px !important;
            max-width: 45px !important;
            width: 40px !important;
            padding: 4px 2px !important;
            white-space: nowrap;
        }
        body[data-theme="stainless"] .golf-info-column {
            background: rgba(0, 0, 0, 0.15) !important;
        }
        
        /* Light green Tee column for stainless theme */
        body[data-theme="stainless"] .crowns-table tbody tr:not(.total-row) td.crowns-hole-label.golf-info-column {
            background: rgba(129, 199, 132, 0.4) !important;
        }
        /* Front 9 / Back 9 separator */
        .golf-nine-separator {
            height: 8px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
        }
        body[data-theme="stainless"] .golf-nine-separator {
            background: linear-gradient(90deg, transparent, #718096, transparent);
        }
        .voice-help-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 0;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--neon-pink);
            border-top: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            z-index: 1200; /* Lower than wins tracker (1500) so it appears below */
            transition: max-height 0.3s ease;
        }
        .voice-help-content.open {
            max-height: 500px;
            overflow-y: auto;
        }
        
        /* Custom scrollbar styling for voice help */
        .voice-help-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .voice-help-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        .voice-help-content::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 4px;
        }
        
        .voice-help-content::-webkit-scrollbar-thumb:hover {
            background: var(--neon-pink);
        }
        .voice-help ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .voice-help li {
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            line-height: 1.6;
            border-bottom: 1px solid rgba(0, 245, 255, 0.1);
        }
        .voice-help li:last-child {
            border-bottom: none;
        }
        .voice-help li strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        .voice-help-content strong {
            color: var(--text-primary);
        }
    </style>
</head>
<body data-theme="stainless">
    <div class="container">
        <header>
            <div class="hamburger-btn" id="hamburgerBtn" onclick="toggleMenu()">
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
            </div>
            <div style="display: flex; align-items: center; gap: 12px; padding-right: 55px;">
                <span style="font-size: 2.5rem; position: relative; top: -4px;"></span>
                <div>
                    <h1 style="margin: 0;">ScoreKeeper</h1>
                    <div class="subtitle" style="margin-top: -5px;">Track  Compete  Win</div>
                </div>
            </div>
        </header>
        <div class="tab-navigation-container">
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('scorekeeper')">Scoring</button>
                <button class="tab-btn" onclick="switchTab('highscores')">High Scores</button>
            </div>
            <button class="voice-btn" id="speakerBtn" onclick="toggleSpeaker()">
                <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M11 5L6 9H2V15H6L11 19V5Z" fill="currentColor"/>
                    <path d="M15.54 8.46C16.4774 9.39764 17.0039 10.6692 17.0039 11.995C17.0039 13.3208 16.4774 14.5924 15.54 15.53" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18.07 5.93C19.9447 7.80528 20.9979 10.3462 20.9979 13C20.9979 15.6538 19.9447 18.1947 18.07 20.07" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <line class="speaker-mute-line" x1="2" y1="2" x2="22" y2="22" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" style="display: none;"/>
                </svg>
            </button>
            <button class="voice-btn" id="voiceBtn" onclick="startVoiceInput()">
                <svg class="mic-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 15C13.66 15 15 13.66 15 12V6C15 4.34 13.66 3 12 3C10.34 3 9 4.34 9 6V12C9 13.66 10.34 15 12 15Z" fill="currentColor"/>
                    <path d="M17 11C17 14.31 14.31 17 11 17H13C16.31 17 19 14.31 19 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M7 11C7 14.31 9.69 17 13 17H11C7.69 17 5 14.31 5 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M12 17V21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M9 21H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </button>
        </div>
        
        <div class="game-type-row">
            <label class="game-type-label">Game Type:</label>
            <div class="custom-dropdown-wrapper-game">
                <div class="custom-dropdown" id="gameTypeDropdown" onclick="toggleGameTypeDropdown()">
                    <span id="selectedGameType" class="dropdown-selected">Select a Game</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="gameTypeDropdownList">
                    <div class="dropdown-list-item-game" data-value="5crowns" onclick="selectGameType('5crowns')">5 Crowns</div>
                    <div class="dropdown-list-item-game" data-value="darts" onclick="selectGameType('darts')">Darts</div>
                    <div class="dropdown-list-item-game" data-value="farkle" onclick="selectGameType('farkle')">Farkle</div>
                    <div class="dropdown-list-item-game" data-value="general" onclick="selectGameType('general')">General</div>
                    <div class="dropdown-list-item-game" data-value="golf" onclick="selectGameType('golf')">Golf</div>
                    <div class="dropdown-list-item-game" data-value="phase10" onclick="selectGameType('phase10')">Phase 10</div>
                    <div class="dropdown-list-item-game" data-value="scrabble" onclick="selectGameType('scrabble')">Scrabble</div>
                    <div class="dropdown-list-item-game" data-value="yahtzee" onclick="selectGameType('yahtzee')">Yahtzee</div>
                </div>
            </div>
            <!-- Hidden select for backwards compatibility -->
            <select id="gameType" style="display: none;">
                <option value="5crowns">5 Crowns</option>
                <option value="darts">Darts</option>
                <option value="farkle">Farkle</option>
                <option value="general">General</option>
                <option value="golf">Golf</option>
                <option value="phase10">Phase 10</option>
                <option value="scrabble">Scrabble</option>
                <option value="yahtzee">Yahtzee</option>
            </select>
        </div>
        
        <div class="add-player-section" id="addPlayerSection">
            <div id="playerInputsContainer">
                <div class="player-inputs-row">
                    <input type="text" id="playerNameInput1" placeholder="Player 1" maxlength="20">
                    <input type="text" id="playerNameInput2" placeholder="Player 2" maxlength="20">
                </div>
                <div class="player-inputs-row">
                    <input type="text" id="playerNameInput3" placeholder="Player 3" maxlength="20">
                    <input type="text" id="playerNameInput4" placeholder="Player 4" maxlength="20">
                </div>
            </div>
            <div class="player-buttons-row">
                <button class="add-more-btn" onclick="addMorePlayerFields()">Add More Players</button>
                <button class="done-adding-btn" onclick="doneAdding()">Done Adding Player Names</button>
            </div>
        </div>
        <div id="scorekeeperTab" class="tab-content active">
            <div id="standardMode" class="standard-mode">
                <!-- Instructions Panel for Standard Mode -->
                <div id="standardModeInstructions" style="padding: 15px 20px 20px 20px; text-align: left; line-height: 1.5; font-size: 0.9em; margin: 10px 0; border-radius: 8px;">
                    <strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>
                    To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>
                    1. Choose the game you want to play.<br>
                    2. Add Player names.<br>
                    3. Say "Done Adding" or Click the "Done adding Player Names" button, and the game will start.
                </div>
            </div>
            <div id="crownsMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="crownsTable"></table>
                </div>
            </div>
            <div id="golfMode" class="crowns-mode">
                <div class="crowns-container">
                    <!-- Golf Course Selector (Always visible when players exist) -->
                    <div class="golf-course-selector" id="golfCourseSelector" style="display: none;">
                        <div class="golf-course-row">
                            <label class="golf-course-label">Golf Course:</label>
                            <div class="custom-dropdown-wrapper">
                                <div class="custom-dropdown" id="golfCourseDropdown" onclick="toggleGolfCourseDropdown();">
                                    <span id="selectedCourseName" class="dropdown-selected">Select a course</span>
                                    <span class="dropdown-arrow"></span>
                                </div>
                                <div class="custom-dropdown-list" id="golfCourseDropdownList">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <table class="crowns-table" id="golfTable"></table>
                </div>
            </div>
            <div id="scrabbleMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="scrabbleTable"></table>
                    <div id="scrabbleButtons" style="display: none; margin-top: 20px; gap: 10px; display: flex;">
                        <button id="addScrabbleRowBtn" class="btn-secondary" onclick="addScrabbleRow()">Add New Scoring Row</button>
                        <button id="scrabbleFinalBtn" class="btn-secondary" onclick="scrabbleFinalAdjustments()">Final Scoring Adjustments</button>
                    </div>
                </div>
            </div>
            <div id="yahtzeeMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="yahtzeeTable"></table>
                </div>
            </div>
            <div id="phase10Mode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="phase10Table"></table>
                </div>
            </div>
            <div id="genericGridMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="genericGridTable"></table>
                    <div id="genericGridButtons" style="display: none; margin-top: 20px; gap: 10px; display: flex;">
                        <button id="addGenericRowBtn" class="btn-secondary" onclick="addGenericRow()">Add New Scoring Row</button>
                    </div>
                </div>
            </div>
            
            <!-- Darts 501 Mode -->
            <div id="darts501Container" style="display: none;">
                <!-- Player Setup Section -->
                <!-- Game Area Section -->
                <div id="gameArea" style="padding-top: 10px;">
                    <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap; margin-bottom: 10px;">
                        <div class="custom-dropdown-wrapper-darts">
                            <div class="custom-dropdown" id="gameVariantDropdown" onclick="toggleGameVariantDropdown()">
                                <span id="selectedGameVariant" class="dropdown-selected">501</span>
                                <span class="dropdown-arrow"></span>
                            </div>
                            <div class="custom-dropdown-list" id="gameVariantDropdownList">
                                <div class="dropdown-list-item-game" data-value="501" onclick="selectGameVariant('501')">501</div>
                                <div class="dropdown-list-item-game" data-value="301" onclick="selectGameVariant('301')">301</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="doubleInCheckbox" class="game-header-checkbox" checked onchange="updateGameRules()">
                            <label for="doubleInCheckbox" style="cursor: pointer; user-select: none; color: var(--text-primary);">Double In</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="doubleOutCheckbox" class="game-header-checkbox" checked onchange="updateGameRules()">
                            <label for="doubleOutCheckbox" style="cursor: pointer; user-select: none; color: var(--text-primary);">Double Out</label>
                        </div>
                    </div>
                    <div id="playersContainer"></div>
                    <div id="keypadContainer" class="darts-keypad"></div>
                    <div id="actionButtonsContainer" style="display: flex; gap: 10px; margin-top: 10px;"></div>
                </div>
            </div>
            <div id="winnerModal" class="modal">
                <div class="modal-content">
                    <h2 id="winnerText">Winner!</h2>
                    <p id="winnerDetails" style="margin: 20px 0; padding: 15px 0; font-size: 1.1rem; line-height: 1.4;"></p>
                    <button class="btn-secondary" onclick="closeWinnerModal()">Continue</button>
                </div>
            </div>
        </div>
        <div id="highScoresTab" class="tab-content">
            <div style="padding: 20px;">
                <hr>
                <div style="display: table; width: 100%;">
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <h3>HIGHEST SCORE</h3>
                    </div>
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <h3>LOWEST SCORE</h3>
                    </div>
                </div>
                <hr>
                <div style="display: table; width: 100%;">
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <div id="wallOfFameContainer"></div>
                    </div>
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <div id="wallOfShameContainer"></div>
                    </div>
                </div>
                <hr style="margin-bottom: 30px;">
                <button class="btn-secondary" onclick="window.clearAllWalls()">Clear All Scores</button>
            </div>
        </div>
        <div id="voiceFeedback" class="voice-feedback">
            <div class="voice-feedback-icon"></div>
            <div class="voice-feedback-text">Listening...</div>
            <div class="voice-feedback-transcript" id="voiceTranscript"></div>
        </div>
    </div>
    <div class="menu-overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    
    <div class="side-menu" id="sideMenu">
        
        <div class="menu-section">
            <div class="menu-section-title">Wins Tracker</div>
            <div class="wins-tracker-selector">
                <div class="custom-dropdown" id="winsTrackerDropdown" onclick="toggleWinsTrackerDropdown()">
                    <span id="selectedWinsTracker" class="dropdown-selected">Select a Game</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="winsTrackerDropdownList">
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('5crowns')">5 Crowns</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('darts')">Darts</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('farkle')">Farkle</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('general')">General</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('golf')">Golf</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('phase10')">Phase 10</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('scrabble')">Scrabble</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('yahtzee')">Yahtzee</div>
                    <div class="dropdown-list-item-theme" onclick="openCustomGamesViewer()">Custom Games</div>
                    <div class="dropdown-list-item-theme" onclick="openCustomGameTrackingModal()" style="border-top: 2px solid var(--neon-blue); margin-top: 8px; padding-top: 12px;">Custom Game Tracking</div>
                </div>
            </div>
        </div>
        
        <div class="menu-section">
            <div class="menu-section-title">Interface Theme</div>
            <div class="theme-selector">
                <div class="custom-dropdown" id="themeDropdown" onclick="toggleThemeDropdown()">
                    <span id="selectedTheme" class="dropdown-selected">Steel</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="themeDropdownList">
                    <div class="dropdown-list-item-theme" onclick="selectTheme('stainless')">Steel</div>
                    <div class="dropdown-list-item-theme" onclick="selectTheme('default')">Neon</div>
                </div>
                <!-- Hidden select for backwards compatibility -->
                <select id="themeSelect" style="display: none;">
                    <option value="stainless">Steel</option>
                    <option value="default">Neon</option>
                </select>
            </div>
        </div>
        
        <div class="menu-section">
            <div class="menu-section-title">Voice Commands</div>
            <div class="voice-help">
                <div class="voice-help-header" onclick="toggleVoiceHelp()">
                    <div class="voice-help-title">Command List</div>
                    <div class="voice-help-toggle" id="voiceHelpToggle"></div>
                </div>
                <div class="voice-help-content" id="voiceHelpContent">
                    <ul>
                        <li><strong> Game Selection:</strong> "Golf"  "5 Crowns"  "Farkle"  "Darts - 501"  "Scrabble"  "General"</li>
                        <li><strong> Add Multiple Players:</strong> "Add players"  Say names  "Done" when finished</li>
                        <li><strong> Add Single Player:</strong> "Add Sarah"  "Add Guy and Emma"</li>
                        <li><strong> Add Points (Name First):</strong> "Emma 5"  "Jonathan 20"  "Guy, 5"</li>
                        <li><strong> Add Points (Number First):</strong> "20 Jonathan"  "5 Emma"  "15 Guy"</li>
                        <li><strong> Add Points (For):</strong> "5 for Emma"  "20 for Jonathan"</li>
                        <li><strong> Add Points (Give):</strong> "Give Sarah 5 points"  "Give Sarah 5"</li>
                        <li><strong> Golf Advanced (Over/Under):</strong> "Jonathan 1 over"  "Emma 2 under"  "Guy plus 1"  "Sarah minus 2"</li>
                        <li><strong> Subtract Points:</strong> "Emma minus 5"  "Take 3 from Sarah"</li>
                        <li><strong> Update Score:</strong> "Change Emma to 10"  "Update Sarah to 5"</li>
                        <li><strong> Undo Last Action:</strong> "Undo"  "Undo that"  "Go back"</li>
                        <li><strong> Fix Wrong Entry:</strong> "Wrong"  "Fix"  "Delete"  "Remove"  "Make correction"</li>
                        <li><strong> Reset:</strong> "Reset all scores"</li>
                        <li><strong> Scrabble Final Scoring:</strong> "Final scoring adjustments"  "Final scoring"</li>
                        <li><strong> Skip Voice Input:</strong> Say "Skip" or "Manual" during tile collection</li>
                    </ul>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(0,245,255,0.1); border-radius: 6px; font-size: 0.85rem;">
                        <strong> Tips:</strong><br>
                         You can interrupt any voice prompt at any time<br>
                         "At" auto-corrects to "Add" for player names<br>
                         Numbers: "too/to"  2, "for/fore"  4, "twenty four"  "twenty for"<br>
                         Undo works for last 20 actions<br>
                         Voice adds players immediately to active game<br>
                         Click grid cells to manually edit scores<br>
                         Golf Advanced: Voice commands only work when Par values are set
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="actions">
        <button id="gameStateBtn" onclick="toggleGameState()">Start Game</button>
        <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
        <button onclick="resetAll()">Reset All</button>
    </div>
    <script>
        let players = [];
        let recognition;
        let isListening = false;
        let intentionallyStopped = false; // Flag to prevent auto-restart after manual stop
        let isAddingMode = false;
        let addedPlayersInSession = [];
        let currentGameType = 'general';
        let hasAskedGameType = false;
        let isAskingGameType = false;
        let wallOfFame = {}; // Best score per game: {golf: {player, score, date}, scrabble: {...}, ...}
        let wallOfShame = {}; // Worst score per game: {golf: {player, score, date}, scrabble: {...}, ...}
        let isRenderingWalls = false; // Prevent concurrent renders
        let inputMode = 'voice'; // 'voice' or 'manual'
        let isSpeakerMuted = false;
        
        // ===== GLOBAL DELETE FUNCTIONS - Define early for immediate availability =====
        window.deleteGameScorecardFromWins = async function(gameType, index) {
            console.log(' DELETE FUNCTION CALLED:', gameType, index);
            
            // Test if customConfirm exists and is callable
            if (typeof customConfirm !== 'function') {
                console.error(' customConfirm is not a function!', typeof customConfirm);
                alert('customConfirm function not found!');
                return;
            }
            
            console.log(' customConfirm function exists');
            
            try {
                console.log(' Calling customConfirm...');
                
                // Show confirmation modal
                const confirmed = await customConfirm(
                    `Are you sure you want to delete this ${gameType} scorecard?\n\nThis action cannot be undone.`,
                    ' Delete Scorecard'
                );
                
                console.log(' customConfirm resolved with:', confirmed);
                
                if (!confirmed) {
                    console.log(' Delete cancelled by user');
                    return;
                }
                
                console.log(' User confirmed, proceeding with deletion...');
                
                // Perform deletion directly with localStorage
                const storageKey = `scorekeeper_${gameType}_scorecards`;
                const saved = localStorage.getItem(storageKey);
                if (!saved) {
                    console.log(' No saved scorecards found');
                    return;
                }
                
                let scorecards = JSON.parse(saved);
                if (index >= 0 && index < scorecards.length) {
                    scorecards.splice(index, 1);
                    localStorage.setItem(storageKey, JSON.stringify(scorecards));
                    console.log(' Scorecard deleted successfully');
                    
                    // Refresh the display
                    if (window.refreshWinsTrackerScorecardsTab) {
                        window.refreshWinsTrackerScorecardsTab(gameType);
                        console.log(' Display refreshed');
                    } else {
                        console.log(' Refresh function not found');
                    }
                } else {
                    console.log(' Invalid index:', index, 'scorecards length:', scorecards.length);
                }
                
            } catch (e) {
                console.error(' Error in delete function:', e);
                alert('Error: ' + e.message);
            }
        };

        window.deleteAllGameScorecards = async function(gameType) {
            console.log(' DELETE ALL FUNCTION CALLED:', gameType);
            try {
                const gameNames = {
                    'general': 'General',
                    'golf': 'Golf',
                    '5crowns': '5 Crowns',
                    'phase10': 'Phase 10',
                    'farkle': 'Farkle',
                    'darts': 'Darts',
                    'scrabble': 'Scrabble',
                    'yahtzee': 'Yahtzee'
                };
                
                const gameName = gameNames[gameType] || gameType;
                
                const confirmed = await customConfirm(
                    `Are you sure you want to delete ALL saved ${gameName} scorecards?\n\nThis action cannot be undone and will not affect your stats.`,
                    ' Delete All Scorecards'
                );
                
                if (!confirmed) {
                    console.log('Delete All cancelled by user');
                    return;
                }
                
                // Clear all scorecards for this game type from localStorage
                const storageKey = `scorekeeper_${gameType}_scorecards`;
                localStorage.removeItem(storageKey);
                console.log(' All scorecards deleted successfully');
                
                // Refresh the display
                if (window.refreshWinsTrackerScorecardsTab) {
                    window.refreshWinsTrackerScorecardsTab(gameType);
                    console.log('Display refreshed');
                } else {
                    console.log('Refresh function not found');
                }
                
            } catch (e) {
                console.error(' Error deleting all scorecards:', e);
                if (window.customAlert) {
                    await customAlert('Error deleting scorecards: ' + e.message, 'Error');
                }
            }
        };
        
        window.deleteGolfScorecardFromWins = async function(index) {
            console.log('Golf delete function called with:', index);
            try {
                const confirmed = await customConfirm(
                    'Are you sure you want to delete this golf scorecard?\n\nThis action cannot be undone.',
                    'Delete Scorecard'
                );
                
                if (!confirmed) return;
                
                const savedScorecards = localStorage.getItem('scorekeeper_golf_scorecards');
                if (!savedScorecards) return;
                
                let scorecards = JSON.parse(savedScorecards);
                if (index >= 0 && index < scorecards.length) {
                    scorecards.splice(index, 1);
                    localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(scorecards));
                    
                    // Refresh the display
                    if (window.refreshWinsTrackerScorecardsTab) {
                        window.refreshWinsTrackerScorecardsTab('golf');
                    } else if (window.displayWinsTracker) {
                        window.displayWinsTracker('golf');
                    }
                }
            } catch (e) {
                console.error('Error deleting golf scorecard:', e);
                await customAlert('Error deleting scorecard: ' + e.message, 'Error');
            }
        };
        
        // ===== END GLOBAL DELETE FUNCTIONS =====
        
        // ===== DARTS 501 VARIABLES =====
        let dartsPlayers = [];
        let dartsScores = {};
        let dartsCurrentPlayer = null;
        let dartsNextMultiplier = null;
        let dartsHistory = [];
        let dartsKeypadRendered = false; // Flag to prevent keypad from rendering multiple times
        let gameStarted = false;
        let dartsStartingScore = 501;
        let requireDoubleIn = true;
        let requireDoubleOut = true;
        let startingScore = 501; // Darts starting score
        
        
        function updateWalls(gameName, playerName, score, isLowerBetter) {
            // Determine if this is a best or worst score
            const currentFame = wallOfFame[gameName];
            const currentShame = wallOfShame[gameName];
            
            // Highest Score: Best score (lower is better for some games, higher for others)
            if (!currentFame) {
                // First entry for this game
                wallOfFame[gameName] = {
                    player: playerName,
                    score: score,
                    date: new Date().toISOString().split('T')[0]
                };
            } else {
                // Check if this is better than current best
                const isBetter = isLowerBetter ? (score < currentFame.score) : (score > currentFame.score);
                if (isBetter) {
                    wallOfFame[gameName] = {
                        player: playerName,
                        score: score,
                        date: new Date().toISOString().split('T')[0]
                    };
                }
            }
            
            // Lowest Score: Worst score (opposite of highest)
            if (!currentShame) {
                // First entry for this game
                wallOfShame[gameName] = {
                    player: playerName,
                    score: score,
                    date: new Date().toISOString().split('T')[0]
                };
            } else {
                // Check if this is worse than current worst
                const isWorse = isLowerBetter ? (score > currentShame.score) : (score < currentShame.score);
                if (isWorse) {
                    wallOfShame[gameName] = {
                        player: playerName,
                        score: score,
                        date: new Date().toISOString().split('T')[0]
                    };
                }
            }
            
            saveWalls();
        }
        
        function saveWalls() {
            try {
                localStorage.setItem('scorekeeper_wall_of_fame', JSON.stringify(wallOfFame));
                localStorage.setItem('scorekeeper_wall_of_shame', JSON.stringify(wallOfShame));
            } catch (e) {
                console.error('Error saving walls:', e);
            }
        }
        
        function loadWalls() {
            try {
                const savedFame = localStorage.getItem('scorekeeper_wall_of_fame');
                const savedShame = localStorage.getItem('scorekeeper_wall_of_shame');
                wallOfFame = savedFame ? JSON.parse(savedFame) : {};
                wallOfShame = savedShame ? JSON.parse(savedShame) : {};
            } catch (e) {
                console.error('Error loading walls:', e);
                wallOfFame = {};
                wallOfShame = {};
            }
        }
        
        function renderWalls() {
            if (isRenderingWalls) return;
            
            isRenderingWalls = true;
            
            const fameContainer = document.getElementById('wallOfFameContainer');
            const shameContainer = document.getElementById('wallOfShameContainer');
            
            if (!fameContainer || !shameContainer) {
                isRenderingWalls = false;
                return;
            }
            
            // Render Highest Score - with dividers between games
            const fameGames = Object.keys(wallOfFame);
            if (fameGames.length === 0) {
                fameContainer.textContent = 'No champions yet!';
            } else {
                fameContainer.innerHTML = fameGames.map((game, index) => {
                    const entry = wallOfFame[game];
                    const divider = index < fameGames.length - 1 ? '<hr style="border: none; border-top: 1px solid #555; margin: 10px 0;">' : '';
                    return `<p><b>${escapeHtml(game)}:</b> ${escapeHtml(entry.player)} - ${entry.score} pts (${entry.date})</p>${divider}`;
                }).join('');
            }
            
            // Render Lowest Score - with dividers between games
            const shameGames = Object.keys(wallOfShame);
            if (shameGames.length === 0) {
                shameContainer.textContent = 'No disasters yet!';
            } else {
                shameContainer.innerHTML = shameGames.map((game, index) => {
                    const entry = wallOfShame[game];
                    const divider = index < shameGames.length - 1 ? '<hr style="border: none; border-top: 1px solid #555; margin: 10px 0;">' : '';
                    return `<p><b>${escapeHtml(game)}:</b> ${escapeHtml(entry.player)} - ${entry.score} pts (${entry.date})</p>${divider}`;
                }).join('');
            }
            
            isRenderingWalls = false;
        }
        
        window.clearAllWalls = async function() {
            const confirmed = await customConfirm('Clear all Highest and Lowest Score records?', ' Clear All Scores');
            if (confirmed) {
                wallOfFame = {};
                wallOfShame = {};
                localStorage.removeItem('scorekeeper_wall_of_fame');
                localStorage.removeItem('scorekeeper_wall_of_shame');
                renderWalls();
            }
        }
        
        // Theme management functions
        function changeTheme() {
            // Cancel any voice operations when manually changing theme
            cancelAllVoiceOperations();
            
            const theme = document.getElementById('themeSelect').value;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('scorekeeper_theme', theme);
            console.log('Theme changed to:', theme);
        }
        
        function loadTheme() {
            const savedTheme = localStorage.getItem('scorekeeper_theme') || 'stainless';
            document.body.setAttribute('data-theme', savedTheme);
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.value = savedTheme;
            }
            
            // Update custom dropdown display
            const selectedTheme = document.getElementById('selectedTheme');
            if (selectedTheme) {
                const themeNames = {
                    'stainless': 'Steel',
                    'default': 'Neon'
                };
                selectedTheme.textContent = themeNames[savedTheme] || 'Steel';
            }
            
            console.log('Theme loaded:', savedTheme);
        }
        
        let currentTab = 'scorekeeper';
        let scoringMode = 'standard'; // 'standard', 'crowns', 'golf', or 'scrabble'
        let crownsScores = {}; // Store 5 Crowns scores by player and round
        let currentCrownsRound = {}; // Track current round index for each player
        let highlightedRound = null; // Track which round is highlighted
        let golfScores = {}; // Store Golf scores by player and hole
        let currentGolfHole = {}; // Track current hole index for each player
        let golfMode = 'simple'; // 'simple' or 'advanced'
        let currentGolfCourse = ''; // Current golf course name
        let golfCoursePar = {}; // Par values for each hole
        let golfCourseHCP = {}; // Handicap values for each hole
        let golfCourseYRD = {}; // Yards values for each hole - now stores arrays of 6 values
        let golfCourseYrdColumns = ['Blue', 'White', 'Red']; // Tee box color names (editable)
        let savedGolfCourses = {}; // Saved courses with par and HCP data
        let scrabbleScores = {}; // Store Scrabble scores by player and turn
        let currentScrabbleTurn = {}; // Track current turn index for each player
        let yahtzeeScores = {}; // Store Yahtzee scores by player and category
        let yahtzeeUsedCategories = {}; // Track which categories have been used by each player
        let phase10Scores = {}; // Store Phase 10 scores by player and phase
        let phase10Completed = {}; // Track which phases have been completed by each player
        let genericGridScores = {}; // Store generic grid scores by player and turn
        let currentGenericTurn = {}; // Track current turn index for each player
        let highlightedGenericTurn = null; // Track which turn is highlighted
        let gameInProgress = false; // Track if game has started
        let isDoneAdding = false; // Track if user clicked "Done Adding"
        let nextPlayerNumber = 5; // Track next player number for new fields
        let undoStack = []; // Stack for undo functionality
        const MAX_UNDO_HISTORY = 20; // Maximum number of undo actions to keep
        const CROWNS_ROUNDS = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const GOLF_HOLES = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'];
        let SCRABBLE_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Start with 12 turns
        let scrabbleMaxTurn = 12; // Track the maximum turn number
        let GENERIC_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Start with 12 turns
        let genericMaxTurn = 12; // Track the maximum turn number
        const YAHTZEE_CATEGORIES = {
            // Upper Section
            'ones': { name: 'Aces', section: 'upper', calc: 'sum' },
            'twos': { name: 'Twos', section: 'upper', calc: 'sum' },
            'threes': { name: 'Threes', section: 'upper', calc: 'sum' },
            'fours': { name: 'Fours', section: 'upper', calc: 'sum' },
            'fives': { name: 'Fives', section: 'upper', calc: 'sum' },
            'sixes': { name: 'Sixes', section: 'upper', calc: 'sum' },
            // Lower Section
            'threeKind': { name: '3 of a Kind', section: 'lower', points: 'sum' },
            'fourKind': { name: '4 of a Kind', section: 'lower', points: 'sum' },
            'fullHouse': { name: 'Full House', section: 'lower', points: 25 },
            'smStraight': { name: 'Sm. Straight', section: 'lower', points: 30 },
            'lgStraight': { name: 'Lg. Straight', section: 'lower', points: 40 },
            'yahtzee': { name: 'YAHTZEE', section: 'lower', points: 50 },
            'chance': { name: 'Chance', section: 'lower', points: 'sum' }
        };
        
        const PHASE10_PHASES = [
            { num: 1, name: '2 sets of 3' },
            { num: 2, name: '1 set of 3 + 1 run of 4' },
            { num: 3, name: '1 set of 4 + 1 run of 4' },
            { num: 4, name: '1 run of 7' },
            { num: 5, name: '1 run of 8' },
            { num: 6, name: '1 run of 9' },
            { num: 7, name: '2 sets of 4' },
            { num: 8, name: '7 cards of 1 color' },
            { num: 9, name: '1 set of 5 + 1 set of 2' },
            { num: 10, name: '1 set of 5 + 1 set of 3' }
        ];
        // Text-to-speech function
        function speak(text, protectScrabbleSpeech = false) {
            // Don't speak if speaker is muted
            if (isSpeakerMuted) {
                console.log('Speaker muted, not speaking:', text);
                return;
            }
            
            if ('speechSynthesis' in window) {
                try {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();
                    
                    // Set protection flag if requested
                    if (protectScrabbleSpeech && scrabbleIsCollectingTiles) {
                        scrabbleSpeaking = true;
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Function to set voice after voices are loaded
                    const setVoice = function() {
                        const voices = window.speechSynthesis.getVoices();
                        
                        // Look for Samantha voice (Mac system voice - female, priority)
                        let selectedVoice = voices.find(function(voice) {
                            return voice.name === 'Samantha';
                        }) || voices.find(function(voice) {
                            return voice.lang.includes('en-GB') && voice.name.toLowerCase().includes('female');
                        }) || voices.find(function(voice) {
                            return voice.lang.includes('en-GB');
                        }) || voices.find(function(voice) {
                            return voice.name.toLowerCase().includes('female') || voice.name.toLowerCase().includes('woman');
                        });
                        
                        if (selectedVoice) {
                            utterance.voice = selectedVoice;
                            console.log('Using voice:', selectedVoice.name, selectedVoice.lang);
                        } else {
                            console.log('Using default system voice');
                        }
                    };
                    
                    // Try to set voice immediately
                    setVoice();
                    
                    // Settings optimized for interruptible speech
                    utterance.rate = 0.85;  // Slower for easier interruption and clarity
                    utterance.pitch = 1.1; // Slightly higher for female voice
                    utterance.volume = 0.8; // Softer volume
                    
                    // Clear protection flag when speech ends
                    utterance.onend = function() {
                        if (protectScrabbleSpeech) {
                            scrabbleSpeaking = false;
                        }
                    };
                    
                    // Also clear on error
                    utterance.onerror = function() {
                        if (protectScrabbleSpeech) {
                            scrabbleSpeaking = false;
                        }
                    };
                    
                    // Speak (after a tiny delay to ensure cancel() took effect)
                    setTimeout(() => {
                        window.speechSynthesis.speak(utterance);
                    }, 50);
                    
                    // Return utterance so caller can attach additional handlers
                    return utterance;
                } catch (err) {
                    console.error('Error in speak function:', err);
                    if (protectScrabbleSpeech) {
                        scrabbleSpeaking = false;
                    }
                    return null;
                }
            }
            return null;
        }
        
        // Toggle speaker mute/unmute
        function toggleSpeaker() {
            isSpeakerMuted = !isSpeakerMuted;
            const speakerBtn = document.getElementById('speakerBtn');
            
            // Save speaker state
            localStorage.setItem('scorekeeper_speaker_muted', isSpeakerMuted ? 'true' : 'false');
            
            if (isSpeakerMuted) {
                speakerBtn.classList.add('speaker-muted');
                speakerBtn.title = 'Voice is muted. Click to unmute.';
                console.log('Speaker muted');
                // Cancel any ongoing speech
                if (window.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
            } else {
                speakerBtn.classList.remove('speaker-muted');
                speakerBtn.title = 'Voice is active. Click to mute.';
                console.log('Speaker unmuted');
                speak('Voice enabled');
            }
        }
        
        function loadSpeakerState() {
            const saved = localStorage.getItem('scorekeeper_speaker_muted');
            if (saved === 'true') {
                isSpeakerMuted = true;
            } else {
                isSpeakerMuted = false;
            }
            
            // Update button state
            const speakerBtn = document.getElementById('speakerBtn');
            if (speakerBtn) {
                if (isSpeakerMuted) {
                    speakerBtn.classList.add('speaker-muted');
                    speakerBtn.title = 'Voice is muted. Click to unmute.';
                } else {
                    speakerBtn.classList.remove('speaker-muted');
                    speakerBtn.title = 'Voice is active. Click to mute.';
                }
            }
            console.log('Loaded speaker state:', isSpeakerMuted ? 'muted' : 'unmuted');
        }
        
        // Show custom final scores modal
        function showFinalScoresModal(winner, finalScores, wonByTiebreaker = false) {
            const modal = document.getElementById('finalScoresModal');
            const winnerDiv = document.getElementById('finalScoresWinner');
            const listOl = document.getElementById('finalScoresList');
            
            // Set winner text with tiebreaker info if applicable
            if (wonByTiebreaker) {
                winnerDiv.textContent = ` Winner: ${winner.player.name} with ${winner.total} points! (Won on tiebreaker - highest score before final adjustments)`;
            } else {
                winnerDiv.textContent = ` Winner: ${winner.player.name} with ${winner.total} points!`;
            }
            
            // Build ranked list
            listOl.innerHTML = '';
            finalScores.forEach((item, idx) => {
                const li = document.createElement('li');
                li.textContent = `${idx + 1}. ${item.player.name}: ${item.total} points`;
                listOl.appendChild(li);
            });
            
            // Show modal
            modal.classList.add('show');
        }
        
        // Close final scores modal
        function closeFinalScoresModal() {
            // Cancel any voice operations when closing modal
            cancelAllVoiceOperations();
            
            const modal = document.getElementById('finalScoresModal');
            modal.classList.remove('show');
        }
        // ===== CUSTOM DIALOG FUNCTIONS =====
        
        // Custom Alert
        let customAlertResolver;
        
        function customAlert(message, title = ' Alert') {
            return new Promise((resolve) => {
                customAlertResolver = resolve;
                const modal = document.getElementById('customAlertModal');
                const titleEl = document.getElementById('customAlertTitle');
                const messageEl = document.getElementById('customAlertMessage');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                modal.classList.add('show');
            });
        }
        
        function closeCustomAlert() {
            const modal = document.getElementById('customAlertModal');
            modal.classList.remove('show');
            if (customAlertResolver) {
                customAlertResolver();
                customAlertResolver = null;
            }
        }
        
        // Custom Confirm
        let customConfirmResolver;
        
        // Override customConfirm to ensure it works with higher z-index
        function customConfirm(message, title = ' Confirm') {
            return new Promise((resolve) => {
                console.log(' customConfirm Promise created');
                customConfirmResolver = resolve;
                
                const modal = document.getElementById('customConfirmModal');
                const titleEl = document.getElementById('customConfirmTitle');
                const messageEl = document.getElementById('customConfirmMessage');
                
                console.log(' Modal elements found:', {
                    modal: !!modal,
                    titleEl: !!titleEl,
                    messageEl: !!messageEl
                });
                
                if (!modal || !titleEl || !messageEl) {
                    console.error(' Required modal elements not found!');
                    resolve(false);
                    return;
                }
                
                // Set content
                titleEl.textContent = title;
                messageEl.innerHTML = message;
                
                // Force very high z-index to appear above everything
                modal.style.zIndex = '99999';
                modal.style.display = 'flex';
                modal.classList.add('show');
                
                console.log(' Modal shown with z-index:', modal.style.zIndex);
                console.log(' Modal display:', modal.style.display);
                console.log(' Modal classes:', modal.classList.toString());
            });
        }
        
        function resolveCustomConfirm(result) {
            console.log(' resolveCustomConfirm called with:', result);
            const modal = document.getElementById('customConfirmModal');
            
            if (modal) {
                // Remove show class and reset styles
                modal.classList.remove('show');
                modal.style.display = 'none';
                modal.style.zIndex = ''; // Reset z-index
                console.log(' Modal hidden');
            }
            
            if (customConfirmResolver) {
                console.log(' Resolving Promise with:', result);
                customConfirmResolver(result);
                customConfirmResolver = null;
            }
        }
        
        // Golf Scorecard Save Modal (with notes)
        let golfScorecardSaveResolver;
        let golfScorecardNotes = '';
        
        function showGolfScorecardSaveModal(message) {
            return new Promise((resolve) => {
                golfScorecardSaveResolver = resolve;
                const modal = document.getElementById('golfScorecardSaveModal');
                const messageEl = document.getElementById('golfScorecardSaveMessage');
                const notesInput = document.getElementById('golfScorecardNotesInput');
                
                messageEl.innerHTML = message;
                notesInput.value = '';
                golfScorecardNotes = '';
                
                modal.classList.add('show');
            });
        }
        
        // toggleGolfNotes function removed - notes are always visible now
        
        function resolveGolfScorecardSave(action) {
            const modal = document.getElementById('golfScorecardSaveModal');
            const notesInput = document.getElementById('golfScorecardNotesInput');
            
            // Get checkbox values
            const saveWinLoss = document.getElementById('saveWinLoss').checked;
            const saveScorecard = document.getElementById('saveScorecard').checked;
            
            // Save notes if any (auto-save)
            golfScorecardNotes = notesInput.value.trim();
            const saveNotes = golfScorecardNotes.length > 0;
            
            modal.classList.remove('show');
            
            if (golfScorecardSaveResolver) {
                golfScorecardSaveResolver({
                    action: action,
                    notes: golfScorecardNotes,
                    saveWinLoss: saveWinLoss,
                    saveNotes: saveNotes,
                    saveScorecard: saveScorecard
                });
                golfScorecardSaveResolver = null;
            }
        }
        
        // Universal Game Completion Modal System
        let gameCompletionResolver = null;
        let gameCompletionNotes = '';
        let currentCompletionGameType = '';
        
        function showGameCompletionModal(gameType, message, winnerData, finalScores) {
            return new Promise((resolve) => {
                gameCompletionResolver = resolve;
                currentCompletionGameType = gameType;
                
                const modal = document.getElementById('gameCompletionModal');
                const messageEl = document.getElementById('gameCompletionMessage');
                const notesInput = document.getElementById('gameCompletionNotesInput');
                const titleEl = document.getElementById('gameCompletionTitle');
                
                // Set title and message
                const gameNames = {
                    'general': 'General',
                    'golf': 'Golf',
                    '5crowns': '5 Crowns',
                    'phase10': 'Phase 10',
                    'farkle': 'Farkle',
                    'darts': 'Darts',
                    'scrabble': 'Scrabble',
                    'yahtzee': 'Yahtzee'
                };
                
                titleEl.textContent = `${gameNames[gameType] || gameType} Complete!`;
                messageEl.innerHTML = message;
                notesInput.value = '';
                notesInput.placeholder = `Add notes about this ${gameNames[gameType] || gameType} game...`;
                gameCompletionNotes = '';
                
                // Load save preferences from localStorage (if set)
                const savedPrefs = localStorage.getItem(`scorekeeper_${gameType}_save_prefs`);
                if (savedPrefs) {
                    try {
                        const prefs = JSON.parse(savedPrefs);
                        document.getElementById('saveWinLossGeneral').checked = prefs.saveWinLoss !== false;
                        document.getElementById('saveScorecardGeneral').checked = prefs.saveScorecard === true;
                    } catch (e) {
                        // Use defaults
                        document.getElementById('saveWinLossGeneral').checked = true;
                        document.getElementById('saveScorecardGeneral').checked = false;
                    }
                } else {
                    // Defaults
                    document.getElementById('saveWinLossGeneral').checked = true;
                    document.getElementById('saveScorecardGeneral').checked = false;
                }
                
                modal.classList.add('show');
                
                // Store winner and scores data for later use
                modal.winnerData = winnerData;
                modal.finalScores = finalScores;
            });
        }
        
        function resolveGameCompletion(action) {
            const modal = document.getElementById('gameCompletionModal');
            const notesInput = document.getElementById('gameCompletionNotesInput');
            
            // Get checkbox values
            const saveWinLoss = document.getElementById('saveWinLossGeneral').checked;
            const saveScorecard = document.getElementById('saveScorecardGeneral').checked;
            
            // Save notes if any
            gameCompletionNotes = notesInput.value.trim();
            const saveNotes = gameCompletionNotes.length > 0;
            
            // Save user preferences for this game type
            const prefs = {
                saveWinLoss: saveWinLoss,
                saveScorecard: saveScorecard
            };
            localStorage.setItem(`scorekeeper_${currentCompletionGameType}_save_prefs`, JSON.stringify(prefs));
            
            modal.classList.remove('show');
            
            if (gameCompletionResolver) {
                gameCompletionResolver({
                    action: action,
                    notes: gameCompletionNotes,
                    saveWinLoss: saveWinLoss,
                    saveNotes: saveNotes,
                    saveScorecard: saveScorecard,
                    gameType: currentCompletionGameType,
                    winnerData: modal.winnerData,
                    finalScores: modal.finalScores
                });
                gameCompletionResolver = null;
            }
        }
        
        async function handleUniversalGameCompletion(gameType, winnerData, finalScores) {
            if (!winnerData || !finalScores || finalScores.length === 0) {
                const message = '<strong>Game Complete!</strong><br><br>No scores available.';
                try {
                    const result = await showGameCompletionModal(gameType, message, winnerData, finalScores);
                } catch (error) {
                    console.error('Error in game completion:', error);
                }
                return;
            }

            // Get score unit based on game type
            const getScoreUnit = (score) => {
                if (gameType === 'darts') {
                    return score === 1 ? 'leg' : 'legs';
                } else {
                    return score === 1 ? 'point' : 'points';
                }
            };

            // Check for ties - find all players with the same score as the winner
            const winnerScore = winnerData.total || winnerData.score || 0;
            const tiedWinners = finalScores.filter(score => (score.total || score.score) === winnerScore);
            
            // Create winner text with Supreme Champion format or tie format
            const winnerText = tiedWinners.length > 1 
                ? `${tiedWinners.map(w => w.name || w.player?.name).join(' and ')} tied with ${winnerScore} ${getScoreUnit(winnerScore)}!`
                : `${winnerData.name || winnerData.player?.name} is the Supreme Champion with ${winnerScore} ${getScoreUnit(winnerScore)}!`;
                
            const scoresHTML = finalScores.map((score, index) => {
                const position = index + 1;
                const name = score.name || score.player?.name || 'Unknown';
                const total = score.total || score.score || 0;
                return `${position}. ${name}: ${total}`;
            }).join('<br>');
            
            const message = `<strong>${winnerText}</strong><br><br>${scoresHTML}`;
            
            try {
                const result = await showGameCompletionModal(gameType, message, winnerData, finalScores);
                
                if (result.action === 'save') {
                    // Handle saving wins/losses
                    if (result.saveWinLoss) {
                        finalScores.forEach((playerScore, index) => {
                            const playerName = playerScore.name || playerScore.player?.name;
                            if (playerName) {
                                // Since finalScores is now sorted best-to-worst for all games,
                                // the winner is always at index 0 (first position)
                                const isWinner = index === 0;
                                updatePlayerWins(playerName, gameType, isWinner);
                            }
                        });
                    }
                    
                    // Handle saving full scorecard (to be implemented per game type)
                    if (result.saveScorecard) {
                        await saveGameScorecard(gameType, finalScores, result.notes, winnerData);
                    }
                } else {
                    await customAlert('Game completed without saving.', 'Game Complete');
                }
            } catch (error) {
                console.error('Error in game completion:', error);
                await customAlert('Error completing game: ' + error.message, 'Error');
            }
        }
        
        // Scorecard storage implementation for all game types
        async function saveGameScorecard(gameType, finalScores, notes, winnerData) {
            console.log(`Saving ${gameType} scorecard:`, {finalScores, notes, winnerData});
            
            const dateStr = new Date().toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: 'numeric' 
            });
            
            let scorecard = {
                date: dateStr,
                gameType: gameType,
                players: players.map(p => p.name),
                notes: notes || '',
                finalScores: finalScores,
                timestamp: new Date().toISOString()
            };
            
            // Add game-specific data based on game type
            switch (gameType) {
                case '5crowns':
                    scorecard.scores = {};
                    scorecard.rounds = [...CROWNS_ROUNDS];
                    players.forEach(player => {
                        scorecard.scores[player.name] = {...crownsScores[player.id]};
                    });
                    break;
                    
                case 'scrabble':
                    scorecard.scores = {};
                    scorecard.turns = [...SCRABBLE_TURNS];
                    players.forEach(player => {
                        scorecard.scores[player.name] = {...scrabbleScores[player.id]};
                    });
                    break;
                    
                case 'darts':
                    scorecard.scores = {};
                    scorecard.gameSettings = {
                        targetScore: dartsStartingScore || 501,
                        requireDoubleIn: requireDoubleIn,
                        requireDoubleOut: requireDoubleOut
                    };
                    players.forEach(player => {
                        scorecard.scores[player.name] = {
                            legs: dartsScores[player.id]?.legs || 0,
                            currentScore: dartsScores[player.id]?.score || dartsStartingScore,
                            history: dartsScores[player.id]?.history || []
                        };
                    });
                    break;
                    
                case 'yahtzee':
                    scorecard.scores = {};
                    scorecard.categories = Object.keys(YAHTZEE_CATEGORIES);
                    players.forEach(player => {
                        scorecard.scores[player.name] = {...yahtzeeScores[player.id]};
                    });
                    break;
                    
                case 'phase10':
                    scorecard.scores = {};
                    scorecard.phases = PHASE10_PHASES.map(p => p.num);
                    players.forEach(player => {
                        scorecard.scores[player.name] = {
                            scores: {...phase10Scores[player.id]},
                            completed: {...phase10Completed[player.id]}
                        };
                    });
                    break;
                    
                case 'farkle':
                case 'general':
                    scorecard.scores = {};
                    if (scoringMode === 'generic') {
                        scorecard.turns = [...GENERIC_TURNS];
                        players.forEach(player => {
                            scorecard.scores[player.name] = {...genericGridScores[player.id]};
                        });
                    } else {
                        // Simple score tracking for other modes
                        players.forEach(player => {
                            scorecard.scores[player.name] = {
                                finalScore: player.score
                            };
                        });
                    }
                    break;
                    
                default:
                    // Generic fallback - just save final scores
                    scorecard.scores = {};
                    players.forEach(player => {
                        scorecard.scores[player.name] = {
                            finalScore: player.score || 0
                        };
                    });
                    break;
            }
            
            // Load existing scorecards for this game type
            const storageKey = `scorekeeper_${gameType}_scorecards`;
            let savedScorecards = [];
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error(`Error loading ${gameType} scorecards:`, e);
                }
            }
            
            // Add new scorecard
            savedScorecards.push(scorecard);
            
            // Keep only last 50 scorecards per game type
            if (savedScorecards.length > 50) {
                savedScorecards = savedScorecards.slice(-50);
            }
            
            // Save to localStorage
            localStorage.setItem(storageKey, JSON.stringify(savedScorecards));
            
            // Game type name mapping
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            const gameName = gameNames[gameType] || gameType;
            const winner = winnerData ? winnerData.name : 'Unknown';
            const winnerScore = winnerData ? winnerData.total : 'Unknown';
            
            await customAlert(
                `Scorecard saved successfully!\n\n${gameName} Game\nDate: ${dateStr}\nWinner: ${winner} (${winnerScore})\n${notes ? `Notes: ${notes.substring(0, 50)}${notes.length > 50 ? '...' : ''}` : ''}}`,
                'Scorecard Saved'
            );
            
            console.log(`Saved ${gameType} scorecard:`, scorecard);
        }
        
        // Helper functions for scorecard management across all game types
        window.loadGameScorecards = function(gameType) {
            const storageKey = `scorekeeper_${gameType}_scorecards`;
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error(`Error loading ${gameType} scorecards:`, e);
                    return [];
                }
            }
            return [];
        }
        
        window.deleteGameScorecard = function(gameType, index) {
            const storageKey = `scorekeeper_${gameType}_scorecards`;
            const scorecards = window.loadGameScorecards(gameType);
            
            if (index >= 0 && index < scorecards.length) {
                scorecards.splice(index, 1);
                localStorage.setItem(storageKey, JSON.stringify(scorecards));
                return true;
            }
            return false;
        }
        
        
        function getGameScorecardCount(gameType) {
            const scorecards = loadGameScorecards(gameType);
            return scorecards.length;
        }
        
        // Universal functions for viewing and deleting game scorecards from Wins Tracker
        function viewGameScorecardFromWins(gameType, index) {
            try {
                const scorecards = loadGameScorecards(gameType);
                if (!scorecards || scorecards.length === 0) return;
                
                // Close wins tracker modal
                document.getElementById('winsTrackerModal').classList.remove('show');
                
                // Set current viewed scorecard
                currentScorecardIndex = index;
                currentScorecardGameType = gameType;
                
                // Display the scorecard using a universal display function
                displayGameScorecard(gameType, index);
                
                // Show the saved scorecards modal
                document.getElementById('savedScorecardsModal').classList.add('show');
            } catch (e) {
                console.error('Error viewing scorecard:', e);
                customAlert('Error loading scorecard: ' + e.message, 'Error');
            }
        }
        
        // deleteGameScorecardFromWins function moved to global scope above
        
        window.refreshWinsTrackerScorecardsTab = function(gameType) {
            // Rebuild just the scorecards tab content
            const scorecardsTab = document.getElementById('winsTrackerScorecardsTab');
            if (!scorecardsTab) return;
            
            const savedScorecards = loadGameScorecards(gameType);
            let html = '';
            
            if (savedScorecards.length > 0) {
                html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                savedScorecards.reverse().forEach((scorecard, idx) => {
                    const actualIndex = savedScorecards.length - 1 - idx;
                    const dateStr = scorecard.date;
                    
                    // Handle players
                    let playerNames = '';
                    if (Array.isArray(scorecard.players)) {
                        playerNames = scorecard.players.join(', ');
                    } else if (scorecard.finalScores) {
                        playerNames = scorecard.finalScores.map(s => s.name).join(', ');
                    } else {
                        playerNames = 'Unknown';
                    }
                    
                    // Get game-specific display info
                    let gameInfo = '';
                    if (gameType === 'golf' && scorecard.course) {
                        gameInfo = scorecard.course;
                    } else {
                        // For all non-Golf games, show player names instead of technical details
                        gameInfo = playerNames;
                    }
                    
                    html += `
                        <div class="saved-scorecard-item" 
                             style="display: flex; align-items: center; justify-content: space-between; gap: 10px;
                                    cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; 
                                    transition: all 0.2s ease;">
                            <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;" onclick="viewGameScorecardFromWins('${gameType}', ${actualIndex})">
                                <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                                    <div style="font-weight: 700; color: black; flex: 1; text-align: left;">${escapeHtml(gameInfo)}</div>
                                    <div style="font-weight: 600; color: black; text-align: right;">${dateStr}</div>
                                </div>
                                ${gameType === 'golf' ? `<div style="color: black; font-size: 0.9em; text-align: left;">${escapeHtml(playerNames)}</div>` : ''}
                            </div>
                            <button class="delete-btn" onclick="event.stopPropagation(); window.deleteGameScorecardFromWins('${gameType}', ${actualIndex})" 
                                    style="width: 36px; height: 36px; font-size: 1.1rem; flex-shrink: 0;"></button>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html = '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No scorecards saved yet.</div>';
            }
            
            scorecardsTab.innerHTML = html;
        }
        
        let currentScorecardGameType = null; // Track which game type scorecard is being viewed
        
        function displayGameScorecard(gameType, index) {
            const scorecards = loadGameScorecards(gameType);
            if (!scorecards || index >= scorecards.length) return;
            
            const scorecard = scorecards[index];
            
            // Update modal title based on game type
            const modalTitle = document.querySelector('#savedScorecardsModal .final-scores-title');
            const gameNames = {
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'scrabble': 'Scrabble',
                'darts': 'Darts',
                'yahtzee': 'Yahtzee',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'general': 'General'
            };
            if (modalTitle) {
                modalTitle.textContent = `${gameNames[gameType] || gameType} Scorecard`;
            }
            
            const scorecardDisplay = document.getElementById('scorecardDisplay');
            
            // Remove redundant scorecard text for non-Golf games, only show for Golf
            let html = `
                ${gameType !== 'golf' && gameType !== 'darts' ? `
                    <div style="margin-bottom: 15px; text-align: center; font-weight: 600; color: var(--text-primary);">
                        Date: ${scorecard.date}
                    </div>
                ` : ''}
            `;
            
            // Add game-specific information and detailed scoring
            if (gameType === 'golf' && scorecard.course) {
                // Show Course and Date on the same row
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-weight: 600;">
                        <div>Course: ${scorecard.course}</div>
                        <div>Date: ${scorecard.date}</div>
                    </div>
                `;
                
                // Show detailed tee-by-tee scoring for Golf formatted exactly like the game grid
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.9em;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 50px; font-weight: 700; font-size: 0.85em;">Tee</th>
                    `;
                    
                    // Calculate available width for player columns
                    const playerCount = scorecard.players.length;
                    const parColumnWidth = (scorecard.par && Object.keys(scorecard.par).length > 0) ? 40 : 0;
                    const teeColumnWidth = 50;
                    const availableWidth = `calc((100% - ${teeColumnWidth + parColumnWidth}px) / ${playerCount})`;
                    
                    // Add player columns with equal narrow width
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85em;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    // Add par column if available with fixed narrow width
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        html += `<th style="text-align: center; background: rgba(255,255,0,0.15); width: 40px; font-weight: 700;">Par</th>`;
                    }
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Front 9 (holes 1-9)
                    for (let hole = 1; hole <= 9; hole++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(0,255,0,0.2); font-weight: 700; min-width: 40px; width: 50px; color: #0a5f0a;">${hole}</td>`;
                        
                        // Player scores for this hole
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        // Par for this hole if available
                        if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                            const par = scorecard.par[hole.toString()] || '';
                            html += `<td style="text-align: center; background: rgba(255,255,0,0.15);">${par}</td>`;
                        }
                        
                        html += `</tr>`;
                    }
                    
                    // Front 9 total row (In) with darker grid lines
                    html += `<tr style="background: rgba(255,150,180,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">In</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let front9Total = 0;
                        for (let hole = 1; hole <= 9; hole++) {
                            front9Total += scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${front9Total || ''}</td>`;
                    });
                    
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        let front9Par = 0;
                        for (let hole = 1; hole <= 9; hole++) {
                            front9Par += parseInt(scorecard.par[hole.toString()] || 0);
                        }
                        html += `<td style="text-align: center; font-weight: 800; background: rgba(255,255,0,0.3); color: #000;">${front9Par || ''}</td>`;
                    }
                    
                    html += `</tr>`;
                    
                    // Back 9 (holes 10-18)
                    for (let hole = 10; hole <= 18; hole++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(0,255,0,0.2); font-weight: 700; min-width: 40px; width: 50px; color: #0a5f0a;">${hole}</td>`;
                        
                        // Player scores for this hole
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        // Par for this hole if available
                        if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                            const par = scorecard.par[hole.toString()] || '';
                            html += `<td style="text-align: center; background: rgba(255,255,0,0.15);">${par}</td>`;
                        }
                        
                        html += `</tr>`;
                    }
                    
                    // Back 9 total row (Out) with darker grid lines
                    html += `<tr style="background: rgba(255,150,180,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Out</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let back9Total = 0;
                        for (let hole = 10; hole <= 18; hole++) {
                            back9Total += scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${back9Total || ''}</td>`;
                    });
                    
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        let back9Par = 0;
                        for (let hole = 10; hole <= 18; hole++) {
                            back9Par += parseInt(scorecard.par[hole.toString()] || 0);
                        }
                        html += `<td style="text-align: center; font-weight: 800; background: rgba(255,255,0,0.3); color: #000;">${back9Par || ''}</td>`;
                    }
                    
                    html += `</tr>`;
                    
                    // Total row (Tot.) with darker grid lines
                    html += `<tr style="background: rgba(255,150,180,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Tot.</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let hole = 1; hole <= 18; hole++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        let totalPar = 0;
                        for (let hole = 1; hole <= 18; hole++) {
                            totalPar += parseInt(scorecard.par[hole.toString()] || 0);
                        }
                        html += `<td style="text-align: center; font-weight: 800; background: rgba(255,255,0,0.3); color: #000;">${totalPar || ''}</td>`;
                    }
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === '5crowns') {
                // Show detailed round-by-round scoring for 5 Crowns in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.9em;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns with equal width distribution
                    const playerCount = scorecard.players.length;
                    const roundColumnWidth = 40;
                    const availableWidth = `calc((100% - ${roundColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85em;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // 5 Crowns rounds
                    const crownsRounds = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    
                    crownsRounds.forEach(round => {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${round}</td>`;
                        
                        // Player scores for this round
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][round] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    });
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        crownsRounds.forEach(round => {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][round] || 0) : 0;
                        });
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'scrabble') {
                // Show detailed turn-by-turn scoring for Scrabble in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.9em;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const turnColumnWidth = 40;
                    const availableWidth = `calc((100% - ${turnColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85em;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Scrabble turns (1-12 or however many were played)
                    const maxTurns = scorecard.turns ? scorecard.turns.length : 12;
                    for (let turn = 1; turn <= maxTurns; turn++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${turn}</td>`;
                        
                        // Player scores for this turn
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    }
                    
                    // Unplayed Tiles row (matching main table styling)
                    html += `<tr>`;
                    html += `<td style="text-align: center; background: rgba(255,0,110,0.1); font-weight: 700; width: 40px;">Unplayed Tiles</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        const unplayedScore = scorecard.scores[playerName] ? (scorecard.scores[playerName]['unplayed'] || 0) : 0;
                        // Display as negative number (except 0) to match main table
                        const displayScore = unplayedScore === 0 ? 0 : -unplayedScore;
                        html += `<td style="text-align: center; background: rgba(255,0,110,0.1); white-space: nowrap;">${displayScore}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    // Opponents' Tiles row (matching main table styling)
                    html += `<tr>`;
                    html += `<td style="text-align: center; background: rgba(0,245,255,0.1); font-weight: 700; width: 40px;">Opponents' Tiles</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        const opponentsScore = scorecard.scores[playerName] ? (scorecard.scores[playerName]['opponents'] || 0) : 0;
                        html += `<td style="text-align: center; background: rgba(0,245,255,0.1); white-space: nowrap;">${opponentsScore}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    // Total Points row (matching main table styling)
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total Points</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let turn = 1; turn <= maxTurns; turn++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                        }
                        // Apply adjustments: subtract unplayed tiles and add opponents' tiles
                        if (scorecard.scores[playerName]) {
                            totalScore -= (scorecard.scores[playerName]['unplayed'] || 0);  // Subtract unplayed
                            totalScore += (scorecard.scores[playerName]['opponents'] || 0);  // Add opponents
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'farkle') {
                // Show detailed turn-by-turn scoring for Farkle in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.9em;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const turnColumnWidth = 40;
                    const availableWidth = `calc((100% - ${turnColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85em;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Get maximum turns from the scorecard data
                    let maxTurns = 0;
                    scorecard.players.forEach(playerName => {
                        if (scorecard.scores[playerName]) {
                            const playerTurns = Object.keys(scorecard.scores[playerName]).filter(key => !isNaN(key)).length;
                            maxTurns = Math.max(maxTurns, playerTurns);
                        }
                    });
                    
                    // Farkle turns
                    for (let turn = 1; turn <= maxTurns; turn++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${turn}</td>`;
                        
                        // Player scores for this turn
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    }
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let turn = 1; turn <= maxTurns; turn++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'general') {
                // Show detailed turn-by-turn scoring for General games in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.9em;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const turnColumnWidth = 40;
                    const availableWidth = `calc((100% - ${turnColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85em;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Get maximum turns from the scorecard data
                    let maxTurns = 0;
                    scorecard.players.forEach(playerName => {
                        if (scorecard.scores[playerName]) {
                            const playerTurns = Object.keys(scorecard.scores[playerName]).filter(key => !isNaN(key)).length;
                            maxTurns = Math.max(maxTurns, playerTurns);
                        }
                    });
                    
                    // General game turns
                    for (let turn = 1; turn <= maxTurns; turn++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${turn}</td>`;
                        
                        // Player scores for this turn
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    }
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let turn = 1; turn <= maxTurns; turn++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'yahtzee') {
                // Show detailed category-by-category scoring for Yahtzee in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.9em;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 120px; font-weight: 700;">Category</th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const categoryColumnWidth = 120;
                    const availableWidth = `calc((100% - ${categoryColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85em;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Upper Section
                    html += '<tr style="background: rgba(0, 245, 255, 0.2); border-top: 3px solid #666; border-bottom: 3px solid #666;"><td style="text-align: center; font-weight: 800; color: #000;">UPPER SECTION</td>';
                    scorecard.players.forEach(() => {
                        html += '<td style="text-align: center; font-weight: 800; color: #000;"></td>';
                    });
                    html += '</tr>';
                    
                    const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
                    const upperNames = ['Ones', 'Twos', 'Threes', 'Fours', 'Fives', 'Sixes'];
                    
                    upperCategories.forEach((cat, idx) => {
                        html += `<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700; width: 120px;">${upperNames[idx]}</td>`;
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][cat] || 0) : 0;
                            html += `<td style="text-align: center; background: ${score > 0 ? 'rgba(0, 123, 255, 0.6)' : 'rgba(0, 245, 255, 0.15)'};">${score || '-'}</td>`;
                        });
                        html += '</tr>';
                    });
                    
                    // Upper Bonus
                    html += '<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700;">Bonus 35 (if 63)</td>';
                    scorecard.players.forEach(playerName => {
                        const upperBonus = scorecard.scores[playerName] ? (scorecard.scores[playerName]['upperBonus'] || 0) : 0;
                        html += `<td style="text-align: center; font-weight: 700; color: ${upperBonus > 0 ? '#28a745' : 'inherit'};">${upperBonus > 0 ? '+35' : '-'}</td>`;
                    });
                    html += '</tr>';
                    
                    // Lower Section
                    html += '<tr style="background: rgba(0, 245, 255, 0.2); border-top: 3px solid #666; border-bottom: 3px solid #666;"><td style="text-align: center; font-weight: 800; color: #000;">LOWER SECTION</td>';
                    scorecard.players.forEach(() => {
                        html += '<td style="text-align: center; font-weight: 800; color: #000;"></td>';
                    });
                    html += '</tr>';
                    
                    const lowerCategories = [
                        { key: 'threeKind', name: '3 of a Kind' },
                        { key: 'fourKind', name: '4 of a Kind' },
                        { key: 'fullHouse', name: 'Full House' },
                        { key: 'smStraight', name: 'Sm Straight' },
                        { key: 'lgStraight', name: 'Lg Straight' },
                        { key: 'yahtzee', name: 'Yahtzee' },
                        { key: 'chance', name: 'Chance' }
                    ];
                    
                    lowerCategories.forEach(cat => {
                        html += `<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700; width: 120px;">${cat.name}</td>`;
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][cat.key] || 0) : 0;
                            html += `<td style="text-align: center; background: ${score > 0 ? 'rgba(0, 123, 255, 0.6)' : 'rgba(0, 245, 255, 0.15)'};">${score || '-'}</td>`;
                        });
                        html += '</tr>';
                    });
                    
                    // Yahtzee Bonus
                    html += '<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700;">Yahtzee Bonus</td>';
                    scorecard.players.forEach(playerName => {
                        const bonus = scorecard.scores[playerName] ? (scorecard.scores[playerName]['yahtzeeBonus'] || 0) : 0;
                        html += `<td style="text-align: center; font-weight: 700; color: ${bonus > 0 ? '#28a745' : 'inherit'};">${bonus > 0 ? bonus : '-'}</td>`;
                    });
                    html += '</tr>';
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">GRAND TOTAL</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        if (scorecard.scores[playerName]) {
                            // Upper section
                            upperCategories.forEach(cat => {
                                totalScore += scorecard.scores[playerName][cat] || 0;
                            });
                            // Upper bonus
                            totalScore += scorecard.scores[playerName]['upperBonus'] || 0;
                            // Lower section
                            lowerCategories.forEach(cat => {
                                totalScore += scorecard.scores[playerName][cat.key] || 0;
                            });
                            // Yahtzee bonus
                            totalScore += scorecard.scores[playerName]['yahtzeeBonus'] || 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'darts' && scorecard.gameSettings) {
                // Build the game description based on double in/out settings
                let gameDesc = '';
                const hasDoubleIn = scorecard.gameSettings.requireDoubleIn;
                const hasDoubleOut = scorecard.gameSettings.requireDoubleOut;
                
                if (hasDoubleIn && hasDoubleOut) {
                    gameDesc = 'Double In/Out';
                } else if (hasDoubleIn && !hasDoubleOut) {
                    gameDesc = 'Double In';
                } else if (!hasDoubleIn && hasDoubleOut) {
                    gameDesc = 'Double Out';
                } else {
                    gameDesc = 'Any In/Out';
                }
                
                // Show Game and Date on the same row (like Golf Course and Date)
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-weight: 600;">
                        <div>Game: ${scorecard.gameSettings.targetScore} (${gameDesc})</div>
                        <div>Date: ${scorecard.date}</div>
                    </div>
                `;
            }
            
            // Show final scores (but not for Golf, Farkle, General, or Yahtzee - they show detailed grids instead)
            if (!['golf', 'farkle', 'general', 'yahtzee'].includes(gameType)) {
                // Sort scores from best to worst based on game type
                const isLowerScoreWins = ['5crowns', 'golf', 'phase10'].includes(gameType);
                const sortedScores = [...scorecard.finalScores].sort((a, b) => {
                    return isLowerScoreWins ? a.total - b.total : b.total - a.total;
                });
                
                html += `
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; color: var(--text-primary);">Final Scores</h4>
                        <table class="crowns-table" style="width: 100%;">
                            <thead>
                                <tr>
                                    <th style="text-align: left;">Player</th>
                                    <th style="text-align: right;">Score</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                sortedScores.forEach(score => {
                    html += `
                        <tr>
                            <td style="text-align: left;">${score.name}</td>
                            <td style="text-align: right; font-weight: 600;">${score.total}</td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // Show notes if any
            if (scorecard.notes && scorecard.notes.trim()) {
                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                        <h4 style="margin-bottom: 8px; color: var(--text-primary);">Notes</h4>
                        <div style="color: black;">${escapeHtml(scorecard.notes)}</div>
                    </div>
                `;
            }
            
            // TODO: Add detailed scoring breakdown for each game type in future phases
            
            scorecardDisplay.innerHTML = html;
        }
        
        // Custom Prompt
        let customPromptResolver;
        
        function customPrompt(message, defaultValue = '', title = ' Input') {
            return new Promise((resolve) => {
                customPromptResolver = resolve;
                const modal = document.getElementById('customPromptModal');
                const titleEl = document.getElementById('customPromptTitle');
                const messageEl = document.getElementById('customPromptMessage');
                const inputEl = document.getElementById('customPromptInput');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                inputEl.value = defaultValue;
                modal.classList.add('show');
                
                // Focus and select input
                setTimeout(() => {
                    inputEl.focus();
                    inputEl.select();
                }, 100);
                
                // Handle Enter key
                inputEl.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        resolveCustomPrompt(inputEl.value);
                    }
                };
            });
        }
        
        function resolveCustomPrompt(result) {
            const modal = document.getElementById('customPromptModal');
            modal.classList.remove('show');
            if (customPromptResolver) {
                customPromptResolver(result);
                customPromptResolver = null;
            }
        }
        // Load voices when they become available (needed for Safari/Brave)
        if ('speechSynthesis' in window) {
            // Safari needs this event listener
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = function() {
                    const voices = window.speechSynthesis.getVoices();
                    console.log('Voices loaded:', voices.length, 'voices available');
                };
            }
            
            // Also try to load voices immediately
            setTimeout(function() {
                const voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    console.log('Voices available:', voices.length);
                }
            }, 100);
        }
        // Initialize speech recognition
        function initSpeechRecognition() {
            console.log('=== Initializing Speech Recognition ===');
            try {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    console.log('Speech Recognition API available');
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = true; // Enable interim results for faster interruption
                    recognition.lang = 'en-US';
                    recognition.maxAlternatives = 1;
                    
                    console.log(' Speech recognition initialized successfully');
                    console.log('Recognition object:', recognition);
                    recognition.onstart = function() {
                        console.log('Recognition started - onstart event. intentionallyStopped:', intentionallyStopped);
                        
                        // Don't re-enable if we intentionally stopped
                        if (intentionallyStopped) {
                            console.log('Ignoring onstart because we intentionally stopped - NOT calling stop()');
                            // Don't call recognition.stop() here - it can cause loops
                            // Just don't set isListening to true
                            return;
                        }
                        
                        isListening = true;
                        updateVoiceButtonState();
                        if (isAddingMode) {
                            showVoiceFeedback('Say names... (say "done" when finished)', '');
                        } else if (isAskingGameType) {
                            showVoiceFeedback('Listening for game type...', 'Interrupt anytime by speaking');
                        } else if (scrabbleIsCollectingTiles) {
                            // Already handled in askForUnplayedTiles
                        } else {
                            showVoiceFeedback('Listening...', 'Speak anytime');
                        }
                    };
                    recognition.onresult = function(event) {
                        try {
                            const lastResult = event.results[event.results.length - 1];
                            const transcript = lastResult[0].transcript.toLowerCase().trim();
                            
                            // AGGRESSIVELY cancel speech when any speech detected
                            // EXCEPT during protected Scrabble speech
                            if (window.speechSynthesis && window.speechSynthesis.speaking && !scrabbleSpeaking) {
                                // Cancel multiple times to ensure it stops
                                window.speechSynthesis.cancel();
                                setTimeout(() => {
                                    window.speechSynthesis.cancel();
                                }, 10);
                                console.log(' Speech interrupted by user');
                            }
                            
                            // Only process final results (ignore interim)
                            if (lastResult.isFinal) {
                                console.log('Heard (final):', transcript);
                                processVoiceCommand(transcript);
                            } else {
                                // Interim result - shows user started speaking
                                console.log('User speaking (interim)...');
                            }
                        } catch (err) {
                            console.error('Error processing result:', err);
                        }
                    };
                    recognition.onerror = function(event) {
                        console.error('=== Speech recognition error ===');
                        console.error('Error type:', event.error);
                        console.error('Error message:', event.message);
                        
                        // Handle no-speech gracefully - don't stop listening
                        if (event.error === 'no-speech') {
                            console.log('No speech detected - continuing');
                            return;
                        }
                        
                        // Handle aborted gracefully
                        if (event.error === 'aborted') {
                            console.log('Recognition aborted');
                            return;
                        }
                        
                        // Handle not-allowed during automatic restart
                        if (event.error === 'not-allowed') {
                            console.log('not-allowed error - stopping to prevent loops');
                            isListening = false;
                            updateVoiceButtonState();
                            hideVoiceFeedback();
                            return;
                        }
                        
                        // Handle other errors
                        hideVoiceFeedback();
                        isListening = false;
                        isAddingMode = false;
                        addedPlayersInSession = [];
                        updateVoiceButtonState();
                        
                        if (event.error === 'permission-denied') {
                            customAlert('Microphone access denied. Please enable microphone permissions in your browser settings and reload the page.', ' Microphone access');
                        } else if (event.error === 'network') {
                            customAlert('Network error. Please check your internet connection.', ' Network error');
                        } else {
                            console.error('Unhandled error:', event.error);
                        }
                    };
                    recognition.onend = function() {
                        console.log('=== Recognition onend fired ===');
                        console.log('State before onend handling:', { isListening, intentionallyStopped });
                        
                        // If intentionally stopped, don't mess with the button state
                        // It's already been set correctly
                        if (intentionallyStopped) {
                            console.log('Was intentionally stopped - clearing flag');
                            intentionallyStopped = false;
                            console.log('intentionallyStopped cleared, ready for next start');
                            return;
                        }
                        
                        // Only update state if recognition ended unexpectedly
                        if (isListening) {
                            console.log('Recognition ended unexpectedly - turning off voice');
                            isListening = false;
                            updateVoiceButtonState();
                            hideVoiceFeedback();
                        }
                        
                        console.log('State after onend handling:', { isListening, intentionallyStopped });
                    };
                } else {
                    console.warn(' Speech recognition not supported in this browser');
                    console.warn('Browser info:', navigator.userAgent);
                }
            } catch (err) {
                console.error(' Failed to initialize speech recognition:', err);
            }
            console.log('=== Speech Recognition Initialization Complete ===');
            console.log('Recognition object exists:', !!recognition);
            
            // Set initial voice button state
            updateVoiceButtonState();
            
            // Debug the microphone button state
            setTimeout(() => {
                const voiceBtn = document.getElementById('voiceBtn');
                console.log('=== MICROPHONE DEBUG ===');
                console.log('Voice button element:', voiceBtn);
                console.log('Has listening class:', voiceBtn?.classList.contains('listening'));
                console.log('Button classes:', voiceBtn?.className);
                const muteLine = voiceBtn?.querySelector('.mic-mute-line');
                console.log('Mute line element:', muteLine);
                if (muteLine) {
                    console.log('Mute line computed display:', window.getComputedStyle(muteLine).display);
                    console.log('Mute line inline style:', muteLine.style.display);
                }
            }, 500);
        }
        // Handle microphone button clicks
        
        function startVoiceInput() {
            console.log(' startVoiceInput() CALLED');
            
            const voiceBtn = document.getElementById('voiceBtn');
            if (voiceBtn) {
                console.log('Voice button state:', {
                    disabled: voiceBtn.disabled,
                    className: voiceBtn.className,
                    text: voiceBtn.textContent
                });
            }
            
            console.log('=== startVoiceInput called ===');
            console.log('recognition object:', !!recognition);
            console.log('isListening:', isListening);
            console.log('intentionallyStopped:', intentionallyStopped);
            
            if (!recognition) {
                console.error('Recognition object not initialized');
                customAlert('Voice recognition is not supported on this device/browser. Please use Safari on iOS or Chrome on Android.', ' Voice not supported');
                return;
            }
            if (isListening) {
                // STOPPING - always allow stop regardless of mode
                console.log('>>> STOPPING voice recognition...');
                try {
                    // Set states immediately for instant UI feedback
                    intentionallyStopped = true; // Prevent auto-restart
                    isListening = false; // Set immediately
                    console.log('Set intentionallyStopped=true, isListening=false');
                    
                    // Update button state IMMEDIATELY - twice for redundancy
                    updateVoiceButtonState(); // Update button state
                    
                    // Force immediate visual update
                    const voiceBtn = document.getElementById('voiceBtn');
                    if (voiceBtn) {
                        voiceBtn.classList.remove('listening');
                        voiceBtn.innerHTML = `
                            <svg class="mic-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 15C13.66 15 15 13.66 15 12V6C15 4.34 13.66 3 12 3C10.34 3 9 4.34 9 6V12C9 13.66 10.34 15 12 15Z" fill="currentColor"/>
                                <path d="M17 11C17 14.31 14.31 17 11 17H13C16.31 17 19 14.31 19 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M7 11C7 14.31 9.69 17 13 17H11C7.69 17 5 14.31 5 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M12 17V21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M9 21H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                        `;
                        voiceBtn.setAttribute('aria-label', 'Start voice input');
                    }
                    
                    // Hide feedback immediately
                    hideVoiceFeedback();
                    
                    // Now stop recognition
                    recognition.stop();
                    console.log('Recognition stop() called successfully');
                } catch (e) {
                    console.error('Error stopping recognition:', e);
                    intentionallyStopped = true;
                    isListening = false;
                    updateVoiceButtonState();
                    hideVoiceFeedback();
                }
            } else {
                // STARTING - check if in manual mode
                if (inputMode === 'manual') {
                    showVoiceFeedback('Voice Input Disabled', 'Open menu () and switch to Voice mode to enable voice input.');
                    setTimeout(hideVoiceFeedback, 3000);
                    return;
                }
                
                console.log('>>> STARTING voice recognition...');
                intentionallyStopped = false; // Clear the flag when starting
                console.log('Cleared intentionallyStopped flag');
                
                // Check if recognition is already running
                try {
                    isListening = true; // Set BEFORE starting recognition
                    updateVoiceButtonState(); // Update button state immediately
                    recognition.start();
                    console.log('Recognition start() called, isListening:', isListening);
                } catch (e) {
                    console.error('Error starting recognition:', e);
                    
                    if (e.name === 'InvalidStateError') {
                        console.log('Recognition not ready yet - retrying in 100ms...');
                        // Recognition might still be stopping - retry after a short delay
                        setTimeout(() => {
                            try {
                                isListening = true;
                                updateVoiceButtonState();
                                recognition.start();
                                console.log('Recognition started after retry');
                            } catch (retryError) {
                                console.error('Retry failed:', retryError);
                                isListening = false;
                                intentionallyStopped = false;
                                updateVoiceButtonState();
                                customAlert('Could not start voice recognition. Please try again.', ' Voice error');
                            }
                        }, 100);
                    } else if (e.name === 'NotAllowedError') {
                        isListening = false;
                        intentionallyStopped = false;
                        updateVoiceButtonState();
                        customAlert('Microphone access denied. Please enable microphone permissions in your browser settings and reload the page.', ' Microphone access');
                    } else {
                        isListening = false;
                        intentionallyStopped = false;
                        updateVoiceButtonState();
                        customAlert('Error starting voice recognition: ' + e.message, ' Voice error');
                    }
                }
            }
            console.log('=== startVoiceInput completed ===');
            console.log('Final state:', { isListening, intentionallyStopped });
        }
        function updateVoiceButtonState() {
            const voiceBtn = document.getElementById('voiceBtn');
            const headerVoiceBtn = document.getElementById('headerVoiceBtn');
            
            console.log('updateVoiceButtonState called, isListening:', isListening);
            
            if (isListening) {
                if (voiceBtn) {
                    voiceBtn.classList.add('listening');
                    voiceBtn.setAttribute('aria-label', 'Stop listening');
                    console.log('Button updated to: Listening - STRIKETHROUGH HIDDEN');
                }
                if (headerVoiceBtn) {
                    headerVoiceBtn.classList.add('listening');
                }
            } else {
                if (voiceBtn) {
                    voiceBtn.classList.remove('listening');
                    voiceBtn.setAttribute('aria-label', 'Start voice input');
                    voiceBtn.title = 'Click to start voice input';
                    console.log('Button updated to: Ready - STRIKETHROUGH VISIBLE');
                }
                if (headerVoiceBtn) {
                    headerVoiceBtn.classList.remove('listening');
                }
            }
        }
        function askForGameType() {
            if (!recognition) {
                console.log('Speech recognition not available');
                customAlert('Voice recognition is not supported on this device/browser. Please use Safari on iOS or Chrome on Android.', ' Voice not supported');
                return;
            }
            
            // Prevent multiple calls
            if (isAskingGameType && isListening) {
                console.log('Already asking for game type and listening - skipping duplicate call');
                return;
            }
            console.log('askForGameType called - Setting isAskingGameType = true');
            isAskingGameType = true;
            hasAskedGameType = true;
            localStorage.setItem('scorekeeper_asked_gametype', 'true');
            
            // Show feedback that we're speaking the prompt
            showVoiceFeedback('Speaking...', 'You can interrupt at any time');
            
            // Speak the prompt first
            const promptText = 'Welcome Player One! What game are we playing today? Say Golf, 5 Crowns, Phase 10, Farkle, Darts, Scrabble, Yahtzee, or General.';
            const utterance = speak(promptText);
            
            // Realistic timing: Ignore input for first 3 seconds to prevent self-listening
            // After 3 seconds, user can interrupt
            const ignoreInputUntil = Date.now() + 3000; // 3 seconds
            
            console.log('Will ignore input for first 3 seconds to prevent self-listening');
            window.gameTypeIgnoreUntil = ignoreInputUntil;
            
            // Start recognition immediately so mic is ready for interruption
            if (utterance) {
                utterance.onend = function() {
                    console.log('Game type prompt finished');
                    showVoiceFeedback('Listening...', 'Say your game choice now');
                    if (!isListening) {
                        try {
                            intentionallyStopped = false;
                            isListening = true;
                            recognition.start();
                            updateVoiceButtonState();
                            console.log(' Recognition started after prompt');
                        } catch (e) {
                            console.error('Error starting recognition:', e);
                            if (e.name === 'InvalidStateError') {
                                console.log('Recognition already running');
                                isListening = true;
                            }
                        }
                    }
                };
                
                utterance.onerror = function(e) {
                    console.log('Speech error, starting recognition anyway');
                    showVoiceFeedback('Listening...', 'Say your game choice now');
                    if (!isListening) {
                        try {
                            intentionallyStopped = false;
                            isListening = true;
                            recognition.start();
                            updateVoiceButtonState();
                        } catch (e) {
                            console.error('Error starting recognition:', e);
                        }
                    }
                };
            } else {
                // Fallback: start recognition immediately
                console.log('No utterance returned, starting recognition immediately');
                showVoiceFeedback('Listening...', 'Say your game choice now');
                if (!isListening) {
                    try {
                        intentionallyStopped = false;
                        isListening = true;
                        recognition.start();
                        updateVoiceButtonState();
                    } catch (e) {
                        console.error('Error starting recognition:', e);
                    }
                }
            }
        }
        function startNewGame() {
            console.log('startNewGame called');
            
            // If already in ANY specific game mode (not general), just restart that game mode
            if (currentGameType !== 'general' && players.length > 0) {
                console.log('Restarting', currentGameType, 'game with existing players');
                gameInProgress = true;
                updateGameStateButton();
                
                // Restart the specific game mode
                if (currentGameType === 'darts') {
                    startGameDarts();
                } else if (currentGameType === '5crowns') {
                    // Reset 5 Crowns scores
                    players.forEach(player => {
                        crownsScores[player.id] = {};
                        CROWNS_ROUNDS.forEach(round => {
                            crownsScores[player.id][round] = 0;
                        });
                    });
                    currentCrownsRound = {};
                    saveCrownsScores();
                    renderCrownsTable();
                } else if (currentGameType === 'golf') {
                    // Reset golf scores
                    players.forEach(player => {
                        golfScores[player.id] = {};
                    });
                    currentGolfHole = {};
                    renderGolfTable();
                } else if (currentGameType === 'farkle' || scoringMode === 'generic') {
                    // Reset generic grid scores for Farkle and other generic grid games
                    genericGridScores = {};
                    currentGenericTurn = {};
                    players.forEach(player => {
                        player.score = 0;
                        genericGridScores[player.id] = {};
                        GENERIC_TURNS.forEach(turn => {
                            genericGridScores[player.id][turn] = 0;
                        });
                    });
                    savePlayers();
                    renderGenericGridTable();
                } else {
                    // For other modes, just reset player scores to 0
                    players.forEach(player => {
                        player.score = 0;
                    });
                    savePlayers();
                    
                }
                return;
            }
            
            // In general mode - DON'T clear players if they exist
            // Just reset their scores and game state
            if (players.length === 0) {
                // No players yet - clear everything
                crownsScores = {};
                currentCrownsRound = {};
                golfScores = {};
                currentGolfHole = {};
                savePlayers();
                saveCrownsScores();
                localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            } else {
                // Players exist - just reset their scores
                players.forEach(player => {
                    player.score = 0;
                });
                savePlayers();
            }
            
            
            renderCrownsTable();
            if (document.getElementById('golfTable')) {
                renderGolfTable();
            }
            
            // Mark game as in progress
            gameInProgress = true;
            updateGameStateButton();
            
            // Trigger the game type question (which will enable mic after speaking)
            console.log('About to call askForGameType, recognition exists:', !!recognition);
            askForGameType();
        }
        // Helper function to cancel all voice operations when manual input is used
        function cancelAllVoiceOperations() {
            // Cancel speech
            if (window.speechSynthesis && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            
            // Reset voice flags
            isAddingMode = false;
            isAskingGameType = false;
            scrabbleIsCollectingTiles = false;
            scrabbleProcessingResponse = false;
            scrabbleSpeaking = false;
            
            // Hide voice feedback
            hideVoiceFeedback();
            
            console.log(' Voice operations cancelled by manual input');
        }
        
        function toggleGameState() {
            try {
                console.log('toggleGameState called, gameInProgress:', gameInProgress);
                if (!gameInProgress) {
                    // Starting new game
                    console.log('Starting new game...');
                    
                    // Check if we're in general mode with no players - this means they want voice welcome
                    if (currentGameType === 'general' && players.length === 0) {
                        console.log('General mode with no players - starting voice welcome');
                        startNewGame(); // This will trigger askForGameType
                        return;
                    }
                    
                    // Check if user has manually entered players and selected a game type
                    if (currentGameType !== 'general' && players.length > 0) {
                        console.log('Manual input mode - players exist and game type selected');
                        // Act like "Done Adding" button - initialize the game
                        doneAdding();
                        return;
                    }
                    
                    // Check if user has manually entered player names but not selected game type
                    // First check if there are names in the input fields
                    const container = document.getElementById('playerInputsContainer');
                    if (container) {
                        const allInputs = container.querySelectorAll('input[type="text"]');
                        let hasNames = false;
                        allInputs.forEach(input => {
                            if (input && input.value.trim() !== '') {
                                hasNames = true;
                            }
                        });
                        
                        if (hasNames && currentGameType === 'general') {
                            console.log('Player names entered but no game type - acting like Done Adding');
                            doneAdding();
                            return;
                        }
                    }
                    
                    // Only cancel voice if we're in a specific game mode (not general)
                    // This allows the voice prompt to work on the main screen
                    if (currentGameType !== 'general') {
                        cancelAllVoiceOperations();
                    }
                    
                    startNewGame();
                } else {
                    // Ending current game - let the announcement play
                    console.log('Ending game...');
                    endGame();
                }
            } catch (err) {
                console.error('Error in toggleGameState:', err);
                customAlert('Error: ' + err.message, ' Error');
            }
        }
        function updateGameStateButton() {
            const btn = document.getElementById('gameStateBtn');
            if (!btn) {
                console.error('gameStateBtn not found!');
                return;
            }
            
            console.log('Updating button, gameInProgress:', gameInProgress);
            
            if (gameInProgress) {
                btn.textContent = 'End Game';
                btn.style.background = 'linear-gradient(135deg, var(--neon-blue), #00c4cc)';
                btn.style.color = 'black';
                btn.style.boxShadow = '0 4px 15px rgba(0, 245, 255, 0.4)';
                btn.classList.remove('pulse'); // Stop pulsing when game starts
                console.log('Button set to: End Game (blue)');
            } else {
                btn.textContent = 'Start Game';
                btn.style.background = 'linear-gradient(135deg, var(--neon-green), #2ed600)';
                btn.style.color = 'black';
                btn.style.boxShadow = '0 4px 15px rgba(57, 255, 20, 0.4)';
                // Don't re-add pulse class when game ends - only pulse on initial load
                console.log('Button set to: Start Game (green)');
            }
        }
        async function endGame() {
            if (players.length === 0) {
                await customAlert('No players to record scores for!', ' No players');
                return;
            }
            
            // Check if any scores have been entered (prevent ending a game that hasn't started)
            let hasAnyScores = false;
            
            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                hasAnyScores = players.some(player => 
                    CROWNS_ROUNDS.some(round => (crownsScores[player.id]?.[round] || 0) !== 0)
                );
            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                hasAnyScores = players.some(player => 
                    GOLF_HOLES.some(hole => (golfScores[player.id]?.[hole] || 0) !== 0)
                );
            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                hasAnyScores = players.some(player => 
                    SCRABBLE_TURNS.some(turn => (scrabbleScores[player.id]?.[turn] || 0) !== 0)
                );
            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                hasAnyScores = players.some(player => 
                    Object.values(yahtzeeScores[player.id] || {}).some(score => score !== 0)
                );
            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                hasAnyScores = players.some(player => 
                    Object.values(phase10Scores[player.id] || {}).some(score => score !== 0)
                );
            } else if (currentGameType === 'darts') {
                // For darts, check if any legs have been won
                hasAnyScores = players.some(player => (dartsScores[player.id]?.legs || 0) > 0);
            } else {
                // For generic/standard games, check if anyone has a non-zero score
                hasAnyScores = players.some(player => player.score !== 0);
            }
            
            if (!hasAnyScores) {
                await customAlert('No scores have been entered yet. Play at least one round before ending the game!', ' No scores');
                return;
            }
            
            // Calculate final scores
            let playerScores = players.map(player => {
                let finalScore;
                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                    // Sum up all rounds for 5 Crowns
                    finalScore = CROWNS_ROUNDS.reduce((sum, round) => 
                        sum + (crownsScores[player.id][round] || 0), 0);
                } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                    // Calculate golf score based on mode
                    if (golfMode === 'advanced') {
                        // In advanced mode: Par + relative score for each hole
                        finalScore = 0;
                        GOLF_HOLES.forEach(hole => {
                            const par = golfCoursePar[hole] || 0;
                            const relativeScore = golfScores[player.id]?.[hole] || 0;
                            finalScore += par + relativeScore;
                        });
                    } else {
                        // In simple mode: Just sum the scores
                        finalScore = GOLF_HOLES.reduce((sum, hole) => 
                            sum + (golfScores[player.id]?.[hole] || 0), 0);
                    }
                } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    // Calculate Scrabble total: turns - unplayed + opponents
                    let total = 0;
                    SCRABBLE_TURNS.forEach(turn => {
                        total += scrabbleScores[player.id]?.[turn] || 0;
                    });
                    total -= scrabbleScores[player.id]?.['unplayed'] || 0;
                    total += scrabbleScores[player.id]?.['opponents'] || 0;
                    finalScore = total;
                } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                    // Calculate Yahtzee grand total: upper + lower sections + bonuses
                    const upperScore = (yahtzeeScores[player.id]?.ones || 0) + 
                                     (yahtzeeScores[player.id]?.twos || 0) + 
                                     (yahtzeeScores[player.id]?.threes || 0) + 
                                     (yahtzeeScores[player.id]?.fours || 0) + 
                                     (yahtzeeScores[player.id]?.fives || 0) + 
                                     (yahtzeeScores[player.id]?.sixes || 0) +
                                     (yahtzeeScores[player.id]?.upperBonus || 0);
                    const lowerScore = (yahtzeeScores[player.id]?.threeKind || 0) + 
                                     (yahtzeeScores[player.id]?.fourKind || 0) + 
                                     (yahtzeeScores[player.id]?.fullHouse || 0) + 
                                     (yahtzeeScores[player.id]?.smStraight || 0) + 
                                     (yahtzeeScores[player.id]?.lgStraight || 0) + 
                                     (yahtzeeScores[player.id]?.yahtzee || 0) + 
                                     (yahtzeeScores[player.id]?.chance || 0) + 
                                     (yahtzeeScores[player.id]?.yahtzeeBonus || 0);
                    finalScore = upperScore + lowerScore;
                } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                    // Calculate Phase 10 total: sum all phase scores
                    finalScore = 0;
                    if (phase10Scores[player.id]) {
                        Object.values(phase10Scores[player.id]).forEach(phaseScore => {
                            finalScore += phaseScore || 0;
                        });
                    }
                } else if (currentGameType === 'darts') {
                    // For darts, use LEGS WON (higher is better) instead of current score
                    // This prevents reading the reset score after a leg completes
                    finalScore = dartsScores[player.id]?.legs || 0;
                } else {
                    // For all other modes including generic, use the player's current score
                    finalScore = player.score;
                }
                return { player, finalScore };
            });
            console.log('Final scores:', playerScores);
            
            // Sort by score from best to worst based on game type
            const isLowerScoreWins = ['5crowns', 'golf', 'phase10'].includes(currentGameType);
            playerScores.sort((a, b) => {
                return isLowerScoreWins ? a.finalScore - b.finalScore : b.finalScore - a.finalScore;
            });
            
            const gameNames = {
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee',
                'general': 'General'
            };
            const gameName = gameNames[currentGameType] || 'General';
            const currentDate = new Date().toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: 'numeric' 
            });
            // Determine winner(s) and loser(s) based on game type
            let winners = [];
            let losers = [];
            
            // Since playerScores is now sorted best-to-worst, winners are always at the beginning
            const bestScore = playerScores[0].finalScore;
            const worstScore = playerScores[playerScores.length - 1].finalScore;
            
            // Find all players with best score (winners - tied)
            winners = playerScores.filter(p => p.finalScore === bestScore);
            
            // Find all players with worst score (losers - tied) 
            losers = playerScores.filter(p => p.finalScore === worstScore);
            console.log('Winners:', winners.map(w => ({name: w.player.name, score: w.finalScore})));
            console.log('Losers:', losers.map(l => ({name: l.player.name, score: l.finalScore})));
            
            // Determine if lower score is better for this game type
            const lowerIsBetter = ['golf', '5crowns', 'phase10'].includes(currentGameType);
            
            // Update walls with all players' scores
            playerScores.forEach(ps => {
                updateWalls(gameName, ps.player.name, ps.finalScore, lowerIsBetter);
            });
            
            // Win tracking now handled by universal completion system based on user choice
            // (No automatic tracking here to prevent double-tracking)
            
            // Create announcement text with proper singular/plural
            const getScoreUnit = (score) => {
                if (currentGameType === 'darts') {
                    return score === 1 ? 'leg' : 'legs';
                } else {
                    return score === 1 ? 'point' : 'points';
                }
            };
            
            let winnerText = winners.length > 1 
                ? `${winners.map(w => w.player.name).join(' and ')} tied with ${winners[0].finalScore} ${getScoreUnit(winners[0].finalScore)}!`
                : `${winners[0].player.name} is the Supreme Champion with ${winners[0].finalScore} ${getScoreUnit(winners[0].finalScore)}!`;
            
            // Create scores list for all players
            let scoresListText = playerScores.map(ps => 
                `${ps.player.name}: ${ps.finalScore} ${getScoreUnit(ps.finalScore)}`
            ).join('\n');
            
            // Speak the complete announcement: winner first, then all other players
            let voiceAnnouncement = `Game over! Winner: ${winnerText}`;
            
            // Sort playerScores for voice announcement (descending order - best to worst)
            // For lower-is-better games, reverse the sort so worst scores come last
            const sortedForVoice = lowerIsBetter 
                ? [...playerScores].reverse() // For golf/5crowns: highest scores last
                : [...playerScores]; // For other games: already sorted ascending, lowest last
            
            // Add other players' scores (excluding the winner)
            const otherPlayers = sortedForVoice.filter(ps => {
                // Filter out winner(s)
                return !winners.some(w => w.player.id === ps.player.id);
            });
            
            if (otherPlayers.length > 0) {
                // Build list of other players' scores in descending order
                const scoreUnit = currentGameType === 'darts' ? 'legs' : 'points';
                const otherScores = otherPlayers.map(ps => 
                    `${ps.player.name}: ${ps.finalScore} ${ps.finalScore === 1 ? scoreUnit.slice(0, -1) : scoreUnit}`
                ).join(', ');
                voiceAnnouncement += `. Other scores: ${otherScores}`;
            }
            
            speak(voiceAnnouncement);
            
            // Use universal game completion system for all non-Golf games
            if (currentGameType === 'scrabble') {
                // Format scores for Scrabble (needs .total instead of .finalScore)
                const formattedScores = playerScores.map(ps => ({
                    name: ps.player.name,
                    total: ps.finalScore,
                    player: ps.player
                }));
                
                // For Scrabble, winner has highest score (now at index 0 due to best-to-worst sorting)
                const winner = playerScores[0];
                const winnerData = {
                    name: winner.player.name,
                    player: winner.player,
                    total: winner.finalScore
                };
                
                await handleUniversalGameCompletion(currentGameType, winnerData, formattedScores);
            } else if (currentGameType === 'golf') {
                // For Golf games, combine winner announcement with save option
                // Format scores as HTML list
                const scoresHTML = playerScores.map(ps => 
                    `${ps.player.name}: ${ps.finalScore} points`
                ).join('<br>');
                
                const message = `<strong>${winnerText}</strong><br><br>${scoresHTML}`;
                const result = await showGolfScorecardSaveModal(message);
                
                if (result.action === 'save') {
                    // Track wins if checkbox checked (only for golf since other games track automatically)
                    if (result.saveWinLoss) {
                        trackGameResults(currentGameType, playerScores, winners);
                    }
                    
                    // Save full scorecard if checkbox checked
                    if (result.saveScorecard) {
                        saveGolfScorecard(playerScores, currentDate, result.notes);
                    } else if (result.notes && result.notes.length > 0) {
                        // If only notes (no scorecard), still show confirmation
                        await customAlert('Notes saved!', ' Saved');
                    }
                }
            } else {
                // Use universal game completion system for all non-Golf games
                const formattedScores = playerScores.map(ps => ({
                    name: ps.player.name,
                    total: ps.finalScore,
                    player: ps.player
                }));
                
                // Get winner data
                const winnerData = winners.length > 0 ? {
                    name: winners[0].player.name,
                    player: winners[0].player,
                    total: winners[0].finalScore
                } : null;
                
                await handleUniversalGameCompletion(currentGameType, winnerData, formattedScores);
            }
            
            // Reset game state
            gameInProgress = false;
            updateGameStateButton();
            
            // For darts, reset for next game but keep players
            if (currentGameType === 'darts') {
                gameStarted = false;
                
                // Reset the keypad flag so it can be rendered again
                dartsKeypadRendered = false;
                
                // Keep players in the array so they can be used for next game
                // Just reset their darts scores
                dartsScores = {};
            }
        }
        async function saveGolfScorecard(playerScores, dateStr, notes = '') {
            // Create scorecard data
            const scorecard = {
                date: dateStr,
                course: currentGolfCourse || 'Unknown Course',
                mode: golfMode,
                players: players.map(p => p.name),
                scores: {},
                par: golfMode === 'advanced' ? {...golfCoursePar} : null,
                hcp: golfMode === 'advanced' ? {...golfCourseHCP} : null,
                notes: notes, // Save notes with scorecard
                finalScores: playerScores.map(ps => ({
                    name: ps.player.name,
                    total: ps.finalScore
                }))
            };
            
            // Copy all player scores
            players.forEach(player => {
                scorecard.scores[player.name] = {...golfScores[player.id]};
            });
            
            // Load existing scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                }
            }
            
            // Add new scorecard
            savedScorecards.push(scorecard);
            
            // Keep only last 50 scorecards
            if (savedScorecards.length > 50) {
                savedScorecards = savedScorecards.slice(-50);
            }
            
            // Save
            localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(savedScorecards));
            
            await customAlert(`Scorecard saved successfully to the Options Menu!\n\nCourse: ${scorecard.course}\nDate: ${dateStr}\nWinner: ${scorecard.finalScores[0].name} (${scorecard.finalScores[0].total})`, ' Scorecard saved');
            console.log('Saved scorecard:', scorecard);
            
            // Refresh the hamburger menu dropdown
            populateHamburgerScorecardDropdown();
        }
        
        let currentScorecardIndex = null; // Track which scorecard is being viewed
        
        function populateHamburgerScorecardDropdown() {
            const dropdownList = document.getElementById('scorecardDropdownList');
            const selectedDisplay = document.getElementById('selectedScorecard');
            const dropdown = document.getElementById('scorecardDropdown');
            
            if (!dropdownList || !selectedDisplay) return;
            
            // Ensure dropdown is closed
            if (dropdown) dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            
            // Load saved scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                }
            }
            
            // Populate dropdown list
            dropdownList.innerHTML = '';
            if (savedScorecards.length === 0) {
                dropdownList.innerHTML = '<div class="dropdown-list-item-theme" style="color: var(--text-dim); cursor: default;">No saved scorecards</div>';
            } else {
                // Sort by date (newest first)
                savedScorecards.reverse();
                savedScorecards.forEach((sc, index) => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-list-item-theme';
                    item.textContent = `${sc.date} - ${sc.course} - ${sc.finalScores[0].name}`;
                    item.onclick = () => selectScorecard(index, sc);
                    dropdownList.appendChild(item);
                });
            }
            
            // Reset selection
            selectedDisplay.textContent = 'Select a Scorecard';
        }
        
        function toggleScorecardDropdown() {
            const dropdown = document.getElementById('scorecardDropdown');
            const dropdownList = document.getElementById('scorecardDropdownList');
            
            // Close other dropdowns
            document.querySelectorAll('.custom-dropdown').forEach(dd => {
                if (dd.id !== 'scorecardDropdown') {
                    dd.classList.remove('open');
                }
            });
            document.querySelectorAll('.custom-dropdown-list').forEach(ddl => {
                if (ddl.id !== 'scorecardDropdownList') {
                    ddl.classList.remove('open');
                }
            });
            
            // Toggle this dropdown
            dropdown.classList.toggle('open');
            dropdownList.classList.toggle('open');
        }
        
        function selectScorecard(index, scorecard) {
            const dropdown = document.getElementById('scorecardDropdown');
            const dropdownList = document.getElementById('scorecardDropdownList');
            const selectedDisplay = document.getElementById('selectedScorecard');
            
            // Close dropdown
            dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            
            // Update display
            selectedDisplay.textContent = `${scorecard.date} - ${scorecard.course}`;
            
            // Set current index
            currentScorecardIndex = index;
            
            // Close hamburger menu
            toggleMenu();
            
            // Display the scorecard in modal
            displayScorecard(index);
            
            // Show modal
            const modal = document.getElementById('savedScorecardsModal');
            modal.classList.add('show');
            
            // Reset dropdown display after a moment
            setTimeout(() => {
                selectedDisplay.textContent = 'Select a Scorecard';
            }, 300);
        }
        
        function displayScorecard(index) {
            const display = document.getElementById('scorecardDisplay');
            
            // Load scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                    return;
                }
            }
            
            savedScorecards.reverse(); // Match the order in dropdown
            const scorecard = savedScorecards[index];
            
            if (!scorecard) {
                display.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-dim);">Scorecard not found.</div>';
                return;
            }
            
            // Display scorecard details with tabs
            let html = `
                <div style="background: var(--card-bg); padding: 20px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                        <div style="font-size: 1.2rem; font-weight: 800; color: var(--text-primary);">
                            ${scorecard.course}
                        </div>
                        <div style="color: var(--text-dim); font-weight: 600;">
                            ${scorecard.date}
                        </div>
                    </div>
                    
                    <!-- Tab Navigation -->
                    <div class="tab-navigation" style="margin-bottom: 20px;">
                        <button class="tab-btn active" onclick="switchScorecardTab('final', ${index})">Final Scores</button>
                        <button class="tab-btn" onclick="switchScorecardTab('full', ${index})">Full Scorecard</button>
                    </div>
                    
                    <!-- Final Scores Tab Content -->
                    <div id="scorecardTabFinal" class="scorecard-tab-content" style="display: block;">
                        <table class="crowns-table" style="width: 100%; margin-bottom: 20px;">
                            <thead>
                                <tr>
                                    <th>Place</th>
                                    <th>Player</th>
                                    <th>Score</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            // Sort finalScores from best to worst based on game type
            const isLowerScoreWins = ['5crowns', 'golf', 'phase10'].includes(gameType);
            const sortedFinalScores = [...scorecard.finalScores].sort((a, b) => {
                return isLowerScoreWins ? a.total - b.total : b.total - a.total;
            });
            
            sortedFinalScores.forEach((ps, idx) => {
                html += `
                    <tr>
                        <td style="text-align: center;">${idx + 1}</td>
                        <td>${escapeHtml(ps.name)}</td>
                        <td style="text-align: center;">${ps.total}</td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
            `;
            
            // Add notes section in Final Scores tab only
            const notesValue = scorecard.notes || '';
            if (notesValue) {
                html += `
                    <div style="margin-top: 15px; padding: 15px; background: rgba(0, 245, 255, 0.1); border-left: 3px solid var(--neon-blue); border-radius: 6px;">
                        <div style="font-weight: 700; margin-bottom: 8px; color: var(--text-primary);">Notes:</div>
                        <div style="color: var(--text-primary); white-space: pre-wrap;">${escapeHtml(notesValue)}</div>
                    </div>
                `;
            }
            
            html += `
                    </div>
                    
                    <!-- Full Scorecard Tab Content -->
                    <div id="scorecardTabFull" class="scorecard-tab-content" style="display: none;">
            `;
            
            // Build the full scorecard grid
            html += renderFullScorecardGrid(scorecard);
            
            html += `
                    </div>
            `;
            
            html += `
                </div>
            `;
            
            display.innerHTML = html;
        }
        
        function switchScorecardTab(tabName, index) {
            // Update tab buttons
            const tabs = document.querySelectorAll('#scorecardDisplay .tab-btn');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Add active class to clicked button
            if (window.event && window.event.target) {
                window.event.target.classList.add('active');
            }
            
            // Show/hide tab content
            const finalTab = document.getElementById('scorecardTabFinal');
            const fullTab = document.getElementById('scorecardTabFull');
            
            if (tabName === 'final') {
                if (finalTab) finalTab.style.display = 'block';
                if (fullTab) fullTab.style.display = 'none';
            } else if (tabName === 'full') {
                if (finalTab) finalTab.style.display = 'none';
                if (fullTab) fullTab.style.display = 'block';
            }
        }
        
        function renderFullScorecardGrid(scorecard) {
            let html = '<div class="crowns-container">';
            
            // Create golf scorecard table
            html += '<table class="crowns-table golf-table" style="width: 100%;">';
            
            // Header row with player names
            html += '<thead><tr><th class="crowns-hole-label golf-info-column">Tee</th>';
            
            // Add PAR and HCP columns if in advanced mode
            if (scorecard.mode === 'advanced' && scorecard.par) {
                html += '<th class="crowns-hole-label golf-info-column">Par</th>';
                html += '<th class="crowns-hole-label golf-info-column">HCP</th>';
            }
            
            // Player columns
            scorecard.players.forEach(playerName => {
                html += `<th class="crowns-player-header">${escapeHtml(playerName)}</th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // Hole rows
            const holes = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'OUT', '10', '11', '12', '13', '14', '15', '16', '17', '18', 'IN', 'TOT'];
            
            holes.forEach(hole => {
                // Determine if this is a total row
                const isTotalRow = hole === 'OUT' || hole === 'IN' || hole === 'TOT';
                const rowClass = isTotalRow ? 'total-row' : '';
                // Add special class for OUT row to get border
                const outRowClass = hole === 'OUT' ? ' golf-out-row' : '';
                
                html += `<tr class="${rowClass}${outRowClass}">`;
                html += `<td class="crowns-hole-label golf-info-column">${hole}</td>`;
                
                // PAR and HCP columns (if advanced mode)
                if (scorecard.mode === 'advanced' && scorecard.par) {
                    if (isTotalRow) {
                        html += '<td class="crowns-score golf-info-column"></td>';
                        html += '<td class="crowns-score golf-info-column"></td>';
                    } else {
                        const par = scorecard.par[hole] || '';
                        const hcp = scorecard.hcp[hole] || '';
                        html += `<td class="crowns-score golf-info-column">${par}</td>`;
                        html += `<td class="crowns-score golf-info-column">${hcp}</td>`;
                    }
                }
                
                // Player score columns
                scorecard.players.forEach(playerName => {
                    const playerScores = scorecard.scores[playerName] || {};
                    let score = playerScores[hole] || '';
                    
                    // Calculate OUT, IN, TOT if not present
                    if (hole === 'OUT' && !score) {
                        score = ['1','2','3','4','5','6','7','8','9'].reduce((sum, h) => sum + (parseInt(playerScores[h]) || 0), 0);
                        if (score === 0) score = '';
                    } else if (hole === 'IN' && !score) {
                        score = ['10','11','12','13','14','15','16','17','18'].reduce((sum, h) => sum + (parseInt(playerScores[h]) || 0), 0);
                        if (score === 0) score = '';
                    } else if (hole === 'TOT' && !score) {
                        score = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18'].reduce((sum, h) => sum + (parseInt(playerScores[h]) || 0), 0);
                        if (score === 0) score = '';
                    }
                    
                    // Add proper class for score cells
                    const cellClass = isTotalRow ? '' : 'crowns-score';
                    html += `<td class="${cellClass}">${score}</td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '</div>';
            
            return html;
        }
        
        
        // ===== WINS TRACKER FUNCTIONS =====
        
        function trackGameResults(gameType, playerScores, winners) {
            console.log('=== trackGameResults DEBUG ===');
            console.log('gameType:', gameType);
            console.log('playerScores:', JSON.stringify(playerScores));
            console.log('winners:', JSON.stringify(winners));
            
            // Load existing wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                }
            }
            
            // Initialize game type if not exists
            if (!winsData[gameType]) {
                winsData[gameType] = {};
            }
            
            console.log('Processing', playerScores.length, 'players');
            
            // Track each player
            playerScores.forEach(ps => {
                const playerName = ps.player.name;
                console.log('Processing player:', playerName, 'Score:', ps.finalScore);
                
                // Find existing player with same name (case-insensitive)
                let existingPlayerName = null;
                for (const name in winsData[gameType]) {
                    if (name.toLowerCase() === playerName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
                
                // Use existing name if found, otherwise use new name
                const normalizedName = existingPlayerName || playerName;
                console.log('Using normalized name:', normalizedName);
                
                // Initialize player if not exists
                if (!winsData[gameType][normalizedName]) {
                    winsData[gameType][normalizedName] = {
                        played: 0,
                        wins: 0
                    };
                    console.log('Initialized new player:', normalizedName);
                }
                
                // Increment games played
                winsData[gameType][normalizedName].played++;
                console.log(normalizedName, 'played incremented to:', winsData[gameType][normalizedName].played);
                
                // Check if this player won
                const isWinner = winners.some(w => w.player.id === ps.player.id);
                console.log(normalizedName, 'is winner?', isWinner);
                if (isWinner) {
                    winsData[gameType][normalizedName].wins++;
                    console.log(normalizedName, 'wins incremented to:', winsData[gameType][normalizedName].wins);
                }
            });
            
            console.log('Final winsData before save:', JSON.stringify(winsData));
            
            // Save updated data
            localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
        }
        
        function toggleWinsTrackerDropdown() {
            const dropdown = document.getElementById('winsTrackerDropdown');
            const dropdownList = document.getElementById('winsTrackerDropdownList');
            
            // Close other dropdowns
            document.querySelectorAll('.custom-dropdown').forEach(dd => {
                if (dd.id !== 'winsTrackerDropdown') {
                    dd.classList.remove('open');
                }
            });
            document.querySelectorAll('.custom-dropdown-list').forEach(ddl => {
                if (ddl.id !== 'winsTrackerDropdownList') {
                    ddl.classList.remove('open');
                }
            });
            
            // Toggle this dropdown
            dropdown.classList.toggle('open');
            dropdownList.classList.toggle('open');
        }
        
        function selectWinsTrackerGame(gameType) {
            const dropdown = document.getElementById('winsTrackerDropdown');
            const dropdownList = document.getElementById('winsTrackerDropdownList');
            const selectedDisplay = document.getElementById('selectedWinsTracker');
            
            // Close dropdown
            dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            
            // Game names mapping
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            // Update display
            selectedDisplay.textContent = gameNames[gameType];
            
            // Close hamburger menu
            toggleMenu();
            
            // Display wins tracker for this game
            displayWinsTracker(gameType);
            
            // Reset dropdown display after a moment
            setTimeout(() => {
                selectedDisplay.textContent = 'Select a Game';
            }, 300);
        }
        
        function showWinsTrackerMenu() {
            const modal = document.getElementById('winsTrackerModal');
            const title = document.getElementById('winsTrackerTitle');
            const display = document.getElementById('winsTrackerDisplay');
            
            title.innerHTML = 'Game Statistics';
            
            const gameTypes = [
                { id: 'golf', name: 'Golf' },
                { id: '5crowns', name: '5 Crowns' },
                { id: 'scrabble', name: 'Scrabble' },
                { id: 'darts', name: 'Darts' },
                { id: 'yahtzee', name: 'Yahtzee' },
                { id: 'phase10', name: 'Phase 10' },
                { id: 'farkle', name: 'Farkle' },
                { id: 'general', name: 'General' }
            ];
            
            let html = '<div style="padding: 20px; text-align: center;">';
            html += '<div style="margin-bottom: 20px; color: var(--text-dim);">Select a game to view statistics and scorecards:</div>';
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 300px; margin: 0 auto;">';
            
            gameTypes.forEach(game => {
                html += `
                    <button 
                        class="final-scores-ok-btn" 
                        onclick="displayWinsTracker('${game.id}')"
                        style="margin: 0; padding: 15px 10px; font-size: 0.9rem;"
                    >
                        ${game.name}
                    </button>
                `;
            });
            
            html += '</div></div>';
            
            display.innerHTML = html;
            modal.classList.add('show');
        }
        
        function displayWinsTracker(gameType) {
            console.log('=== displayWinsTracker called ===');
            console.log('gameType:', gameType);
            
            const modal = document.getElementById('winsTrackerModal');
            const title = document.getElementById('winsTrackerTitle');
            const display = document.getElementById('winsTrackerDisplay');
            
            // Game names mapping
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            title.innerHTML = `${gameNames[gameType]} Statistics`;
            
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                }
            }
            
            console.log('winsData:', winsData);
            
            const gameData = winsData[gameType] || {};
            const players = Object.keys(gameData);
            
            console.log('gameData:', gameData);
            console.log('players:', players);
            
            // Add tabs for all game types
            let html = '';
            console.log(`Creating ${gameType} tabs`);
            html += `
                <div class="tab-navigation" style="margin-bottom: 20px;">
                    <button class="tab-btn active" onclick="switchWinsTrackerTab('${gameType}', 'stats')">Statistics</button>
                    <button class="tab-btn" onclick="switchWinsTrackerTab('${gameType}', 'scorecards')">Scorecards</button>
                </div>
                <div id="winsTrackerStatsTab" class="wins-tracker-tab" style="display: block;">
            `;
            
            if (players.length === 0) {
                console.log('No players found, using empty state');
                html += '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No games recorded yet.</div>';
                html += '</div><div id="winsTrackerScorecardsTab" class="wins-tracker-tab" style="display: none;">';
                
                // Always load scorecards even if no win/loss stats
                const savedScorecards = loadGameScorecards(gameType);
                if (savedScorecards.length > 0) {
                if (savedScorecards.length > 0) {
                    html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    savedScorecards.reverse().forEach((scorecard, idx) => {
                        const actualIndex = savedScorecards.length - 1 - idx;
                        const date = scorecard.date;
                        const dateStr = date; // Already formatted in our storage
                        
                        // Handle players - could be array of names or objects
                        let playerNames = '';
                        if (Array.isArray(scorecard.players)) {
                            playerNames = scorecard.players.join(', ');
                        } else if (scorecard.finalScores) {
                            playerNames = scorecard.finalScores.map(s => s.name).join(', ');
                        } else {
                            playerNames = 'Unknown';
                        }
                        
                        // Get game-specific display info
                        let gameInfo = '';
                        if (gameType === 'golf' && scorecard.course) {
                            gameInfo = scorecard.course;
                        } else if (gameType === 'darts' && scorecard.gameSettings) {
                            gameInfo = playerNames; // Show player names instead of game settings
                        } else if (gameType === '5crowns') {
                            gameInfo = playerNames; // Show player names instead of round count
                        } else if (gameType === 'scrabble') {
                            gameInfo = playerNames; // Show player names instead of turn count
                        } else if (gameType === 'yahtzee') {
                            gameInfo = playerNames; // Show player names instead of 'Full Game'
                        } else if (gameType === 'phase10') {
                            gameInfo = playerNames; // Show player names instead of phase count
                        } else {
                            gameInfo = playerNames; // Show player names instead of 'Complete Game'
                        }
                        
                        html += `
                            <div class="saved-scorecard-item" 
                                 style="display: flex; align-items: center; justify-content: space-between; gap: 10px;
                                        cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; 
                                        transition: all 0.2s ease;">
                                <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;" onclick="viewGameScorecardFromWins('${gameType}', ${actualIndex})">
                                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                                        <div style="font-weight: 700; color: black; flex: 1; text-align: left;">${escapeHtml(gameInfo)}</div>
                                        <div style="font-weight: 600; color: black; text-align: right;">${dateStr}</div>
                                    </div>
                                    ${gameType === 'golf' ? `<div style="color: black; font-size: 0.9em; text-align: left;">${escapeHtml(playerNames)}</div>` : ''}
                                </div>
                                <button class="delete-btn" onclick="event.stopPropagation(); window.deleteGameScorecardFromWins('${gameType}', ${actualIndex})" 
                                        style="width: 36px; height: 36px; font-size: 1.1rem; flex-shrink: 0;"></button>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    html += '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No scorecards saved yet.</div>';
                }
                    
                    html += '</div>';
                    display.innerHTML = html;
                } else {
                    display.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No games recorded yet for this game type.</div>';
                }
            } else {
                console.log('Players found:', players.length, 'players');
                // Sort players by win percentage (descending)
                players.sort((a, b) => {
                    const aPercent = gameData[a].played > 0 ? (gameData[a].wins / gameData[a].played) * 100 : 0;
                    const bPercent = gameData[b].played > 0 ? (gameData[b].wins / gameData[b].played) * 100 : 0;
                    return bPercent - aPercent;
                });
                
                console.log('About to build stats table');
                html += `
                    <table class="crowns-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 100px;">Player</th>
                                <th style="width: 60px; padding: 4px 8px;">Played</th>
                                <th style="width: 50px; padding: 4px 8px;">Wins</th>
                                <th style="width: 45px; padding: 4px 2px;">%</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                players.forEach(playerName => {
                    const stats = gameData[playerName];
                    const percentage = stats.played > 0 ? ((stats.wins / stats.played) * 100).toFixed(1) : '0.0';
                    
                    html += `
                        <tr>
                            <td style="text-align: left;">
                                <input type="text" value="${escapeHtml(playerName)}" 
                                       class="wins-tracker-input" 
                                       onchange="updateWinsTrackerPlayerName('${gameType}', '${escapeHtml(playerName)}', this.value)"
                                       style="width: 100%; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                            </td>
                            <td style="padding: 4px 8px;">
                                <input type="number" value="${stats.played}" 
                                       class="wins-tracker-input" 
                                       inputmode="numeric"
                                       onchange="updateWinsTrackerStat('${gameType}', '${escapeHtml(playerName)}', 'played', this.value)"
                                       style="width: 44px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                            </td>
                            <td style="padding: 4px 8px;">
                                <input type="number" value="${stats.wins}" 
                                       class="wins-tracker-input" 
                                       inputmode="numeric"
                                       onchange="updateWinsTrackerStat('${gameType}', '${escapeHtml(playerName)}', 'wins', this.value)"
                                       style="width: 34px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                            </td>
                            <td style="font-weight: 700; color: var(--neon-blue); padding: 4px 2px; text-align: center;">${percentage}%</td>
                            <td style="text-align: center;">
                                <button class="delete-btn" onclick="deleteWinsTrackerEntry('${gameType}', '${escapeHtml(playerName)}')" style="width: 36px; height: 36px; font-size: 1.1rem;"></button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
                
                // Close stats tab and add scorecards tab for all game types
                console.log(`Adding ${gameType} scorecards tab for players exist case`);
                html += '</div><div id="winsTrackerScorecardsTab" class="wins-tracker-tab" style="display: none;">';
                
                // Load scorecards for this game type
                const savedScorecards = loadGameScorecards(gameType);
                console.log(`${gameType} saved scorecards:`, savedScorecards.length, 'scorecards');
                if (savedScorecards.length > 0) {
                    html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    savedScorecards.reverse().forEach((scorecard, idx) => {
                        const actualIndex = savedScorecards.length - 1 - idx;
                        const dateStr = scorecard.date; // Already formatted in our storage
                        
                        // Handle players - could be array of names or objects
                        let playerNames = '';
                        if (Array.isArray(scorecard.players)) {
                            playerNames = scorecard.players.join(', ');
                        } else if (scorecard.finalScores) {
                            playerNames = scorecard.finalScores.map(s => s.name).join(', ');
                        } else {
                            playerNames = 'Unknown';
                        }
                        
                        // Get game-specific display info
                        let gameInfo = '';
                        if (gameType === 'golf' && scorecard.course) {
                            gameInfo = scorecard.course;
                        } else if (gameType === 'darts' && scorecard.gameSettings) {
                            gameInfo = playerNames; // Show player names instead of game settings
                        } else if (gameType === '5crowns') {
                            gameInfo = playerNames; // Show player names instead of round count
                        } else if (gameType === 'scrabble') {
                            gameInfo = playerNames; // Show player names instead of turn count
                        } else if (gameType === 'yahtzee') {
                            gameInfo = playerNames; // Show player names instead of 'Full Game'
                        } else if (gameType === 'phase10') {
                            gameInfo = playerNames; // Show player names instead of phase count
                        } else {
                            gameInfo = playerNames; // Show player names instead of 'Complete Game'
                        }
                        
                        html += `
                            <div class="saved-scorecard-item" 
                                 style="display: flex; align-items: center; justify-content: space-between; gap: 10px;
                                        cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; 
                                        transition: all 0.2s ease;">
                                <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;" onclick="viewGameScorecardFromWins('${gameType}', ${actualIndex})">
                                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                                        <div style="font-weight: 700; color: black; flex: 1; text-align: left;">${escapeHtml(gameInfo)}</div>
                                        <div style="font-weight: 600; color: black; text-align: right;">${dateStr}</div>
                                    </div>
                                    ${gameType === 'golf' ? `<div style="color: black; font-size: 0.9em; text-align: left;">${escapeHtml(playerNames)}</div>` : ''}
                                </div>
                                <button class="delete-btn" onclick="event.stopPropagation(); window.deleteGameScorecardFromWins('${gameType}', ${actualIndex})" 
                                        style="width: 36px; height: 36px; font-size: 1.1rem; flex-shrink: 0;"></button>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    html += '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No scorecards saved yet.</div>';
                }
                html += '</div>';
                
                console.log('Final HTML structure length:', html.length);
                console.log('Final HTML preview (first 500 chars):', html.substring(0, 500));
                console.log('Final HTML preview (last 500 chars):', html.substring(html.length - 500));
                console.log('Setting display.innerHTML for players exist case');
                display.innerHTML = html;
            }
            
            console.log('=== displayWinsTracker complete ===');
            // Show modal
            modal.classList.add('show');
        }
        
        function updateWinsTrackerPlayerName(gameType, oldName, newName) {
            newName = newName.trim();
            if (!newName || newName === oldName) return;
            
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    return;
                }
            }
            
            if (winsData[gameType] && winsData[gameType][oldName]) {
                // Check if there's already a player with the new name (case-insensitive)
                let existingPlayerName = null;
                for (const name in winsData[gameType]) {
                    if (name !== oldName && name.toLowerCase() === newName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
                
                if (existingPlayerName) {
                    // Merge the data into existing player
                    winsData[gameType][existingPlayerName].played += winsData[gameType][oldName].played;
                    winsData[gameType][existingPlayerName].wins += winsData[gameType][oldName].wins;
                    delete winsData[gameType][oldName];
                } else {
                    // Just rename the player
                    winsData[gameType][newName] = winsData[gameType][oldName];
                    delete winsData[gameType][oldName];
                }
                
                // Save
                localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
                
                // Refresh display
                displayWinsTracker(gameType);
            }
        }
        
        function updateWinsTrackerStat(gameType, playerName, stat, value) {
            value = parseInt(value) || 0;
            if (value < 0) value = 0;
            
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    return;
                }
            }
            
            // Find existing player with same name (case-insensitive)
            let existingPlayerName = null;
            if (winsData[gameType]) {
                for (const name in winsData[gameType]) {
                    if (name.toLowerCase() === playerName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
            }
            
            if (existingPlayerName) {
                // Update stat
                winsData[gameType][existingPlayerName][stat] = value;
                
                // Make sure wins doesn't exceed played
                if (stat === 'played' && winsData[gameType][existingPlayerName].wins > value) {
                    winsData[gameType][existingPlayerName].wins = value;
                }
                if (stat === 'wins' && value > winsData[gameType][existingPlayerName].played) {
                    winsData[gameType][existingPlayerName].played = value;
                }
                
                // Save
                localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
                
                // Refresh display
                displayWinsTracker(gameType);
            }
        }
        

        function switchWinsTrackerTab(gameType, tab) {
            const tabBtns = document.querySelectorAll('#winsTrackerDisplay .tab-btn');
            tabBtns.forEach(btn => {
                btn.classList.remove('active');
                // Add active class to the correct button
                if ((tab === 'stats' && btn.textContent.trim() === 'Statistics') ||
                    (tab === 'scorecards' && btn.textContent.trim() === 'Scorecards')) {
                    btn.classList.add('active');
                }
            });
            
            const statsTab = document.getElementById('winsTrackerStatsTab');
            const scorecardsTab = document.getElementById('winsTrackerScorecardsTab');
            
            if (tab === 'stats') {
                statsTab.style.display = 'block';
                scorecardsTab.style.display = 'none';
            } else {
                statsTab.style.display = 'none';
                scorecardsTab.style.display = 'block';
            }
            
            // Show/hide Delete All button - show for all game types' scorecards tabs
            const deleteAllBtn = document.getElementById('deleteAllScorecardsBtn');
            if (deleteAllBtn) {
                if (tab === 'scorecards') {
                    deleteAllBtn.style.display = 'inline-block';
                    // Update the onclick to handle the current game type
                    deleteAllBtn.setAttribute('onclick', `window.deleteAllGameScorecards('${gameType}')`);
                } else {
                    deleteAllBtn.style.display = 'none';
                }
            }
        }
        
        function viewGolfScorecardFromWins(index) {
            const savedScorecards = localStorage.getItem('scorekeeper_golf_scorecards');
            if (!savedScorecards) return;
            
            try {
                const scorecards = JSON.parse(savedScorecards);
                if (!scorecards || scorecards.length === 0) return;
                
                // Close wins tracker modal
                document.getElementById('winsTrackerModal').classList.remove('show');
                
                // Set current viewed scorecard
                currentScorecardIndex = index;
                
                // Display the scorecard using the existing display function
                displayScorecard(index);
                
                // Show the saved scorecards modal
                document.getElementById('savedScorecardsModal').classList.add('show');
            } catch (e) {
                console.error('Error viewing scorecard:', e);
                customAlert('Error loading scorecard: ' + e.message, ' Error');
            }
        }
        
        // deleteGolfScorecardFromWins function moved to global scope above
        
        // deleteAllGameScorecards function moved to global scope above
        
        // Keep the old Golf function name for backward compatibility
        async function deleteAllGolfScorecards() {
            await window.deleteAllGameScorecards('golf');
        }
        
        
        function closeWinsTrackerModal() {
            const modal = document.getElementById('winsTrackerModal');
            modal.classList.remove('show');
        }
        
        
        function updatePlayerWins(playerName, gameType, isWinner = true) {
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    winsData = {};
                }
            }
            
            // Initialize game type if needed
            if (!winsData[gameType]) {
                winsData[gameType] = {};
            }
            
            // Find existing player (case-insensitive)
            let existingPlayerName = null;
            for (const name in winsData[gameType]) {
                if (name.toLowerCase() === playerName.toLowerCase()) {
                    existingPlayerName = name;
                    break;
                }
            }
            
            if (existingPlayerName) {
                // Update existing player
                winsData[gameType][existingPlayerName].played++;
                if (isWinner) {
                    winsData[gameType][existingPlayerName].wins++;
                }
            } else {
                // Add new player
                winsData[gameType][playerName] = {
                    played: 1,
                    wins: isWinner ? 1 : 0
                };
            }
            
            // Save
            localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
            console.log('Updated wins for', playerName, 'in', gameType, '- Winner:', isWinner);
        }
        
        function deleteWinsTrackerEntry(gameType, playerName) {
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    return;
                }
            }
            
            // Find existing player with same name (case-insensitive)
            let existingPlayerName = null;
            if (winsData[gameType]) {
                for (const name in winsData[gameType]) {
                    if (name.toLowerCase() === playerName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
            }
            
            // Delete the player entry
            if (existingPlayerName) {
                delete winsData[gameType][existingPlayerName];
                
                // Save back to localStorage
                localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
                
                // Refresh display
                displayWinsTracker(gameType);
            }
        }
        
        // Auto-save notes with debounce to avoid saving on every keystroke
        let autoSaveNotesTimeout;
        function autoSaveScorecardNotes() {
            clearTimeout(autoSaveNotesTimeout);
            autoSaveNotesTimeout = setTimeout(() => {
                saveEditedNotes(true); // true = silent save (no alert)
            }, 1000); // Save 1 second after user stops typing
        }
        
        async function saveEditedNotes(silent = false) {
            if (currentScorecardIndex === null) return;
            
            const notesTextarea = document.getElementById('viewScorecardNotes');
            if (!notesTextarea) return;
            
            const newNotes = notesTextarea.value.trim();
            
            // Load scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                    return;
                }
            }
            
            // Update notes in the scorecard
            savedScorecards.reverse(); // Match the order in dropdown
            if (savedScorecards[currentScorecardIndex]) {
                savedScorecards[currentScorecardIndex].notes = newNotes;
            }
            savedScorecards.reverse(); // Reverse back to original order
            
            // Save updated list
            localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(savedScorecards));
            
            // Show confirmation only if not silent
            if (!silent) {
                await customAlert('Notes saved successfully!', ' Saved');
                // Refresh the display
                displayScorecard(currentScorecardIndex);
            }
        }
        
        function closeSavedScorecardsModal() {
            const modal = document.getElementById('savedScorecardsModal');
            modal.classList.remove('show');
            currentScorecardIndex = null;
        }
        
        async function deleteCurrentScorecard() {
            if (currentScorecardIndex === null) return;
            
            const confirmed = await customConfirm('Are you sure you want to delete this scorecard? This action cannot be undone.', ' Delete Scorecard');
            if (!confirmed) return;
            
            // Load scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                    return;
                }
            }
            
            savedScorecards.reverse(); // Match the order in dropdown
            savedScorecards.splice(currentScorecardIndex, 1);
            savedScorecards.reverse(); // Reverse back to original order
            
            // Save updated list
            localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(savedScorecards));
            
            // Refresh hamburger dropdown
            populateHamburgerScorecardDropdown();
            
            // Close modal
            closeSavedScorecardsModal();
            
            await customAlert('Scorecard deleted successfully.', ' Deleted');
        }
        
        function toggleVoiceHelp() {
            const content = document.getElementById('voiceHelpContent');
            const toggle = document.getElementById('voiceHelpToggle');
            const header = document.querySelector('.voice-help-header');
            
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                toggle.classList.remove('open');
                if (header) header.classList.remove('open');
            } else {
                content.classList.add('open');
                toggle.classList.add('open');
                if (header) header.classList.add('open');
            }
        }
        window.toggleMenu = function() {
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            const hamburger = document.getElementById('hamburgerBtn');
            
            if (!menu || !overlay || !hamburger) {
                console.error('toggleMenu: Missing required elements');
                return;
            }
            
            const isActive = menu.classList.contains('active');
            
            if (isActive) {
                menu.classList.remove('active');
                overlay.classList.remove('active');
                hamburger.classList.remove('active');
            } else {
                menu.classList.add('active');
                overlay.classList.add('active');
                hamburger.classList.add('active');
            }
        };
        
        // Verify toggleMenu is accessible
        console.log(' toggleMenu function defined:', typeof window.toggleMenu);
        function toggleInputMode() {
            const toggle = document.getElementById('inputModeToggle');
            const voiceLabel = document.getElementById('voiceLabel');
            const manualLabel = document.getElementById('manualLabel');
            const voiceBtn = document.getElementById('voiceBtn');
            
            if (toggle.checked) {
                // Manual mode
                inputMode = 'manual';
                voiceLabel.classList.remove('active');
                manualLabel.classList.add('active');
                
                // Cancel any ongoing voice operations
                cancelAllVoiceOperations();
                
                // Mark voice button as inactive (but don't disable so click can show message)
                if (voiceBtn) {
                    voiceBtn.classList.add('manual-mode-inactive');
                    voiceBtn.title = 'Voice input is disabled in Manual mode. Switch to Voice mode in the menu ().';
                }
                
                // Save preference
                localStorage.setItem('scorekeeper_input_mode', 'manual');
                
                console.log(' Switched to Manual Input mode');
            } else {
                // Voice mode
                inputMode = 'voice';
                voiceLabel.classList.add('active');
                manualLabel.classList.remove('active');
                
                // Enable voice button
                if (voiceBtn) {
                    voiceBtn.classList.remove('manual-mode-inactive');
                    voiceBtn.title = 'Click to start voice input';
                }
                
                // Save preference
                localStorage.setItem('scorekeeper_input_mode', 'voice');
                
                console.log(' Switched to Voice Input mode');
            }
        }
        
        // Load input mode preference on page load
        function loadInputMode() {
            const savedMode = localStorage.getItem('scorekeeper_input_mode') || 'voice';
            const toggle = document.getElementById('inputModeToggle');
            
            if (!toggle) {
                console.warn('inputModeToggle element not found');
                return;
            }
            
            if (savedMode === 'manual') {
                toggle.checked = true;
                toggleInputMode();
            } else {
                toggle.checked = false;
                inputMode = 'voice';
            }
        }
        function detectGameType(transcript) {
            const lower = transcript.toLowerCase();
            
            if (lower.includes('golf')) return 'golf';
            if (lower.includes('5 crown') || lower.includes('five crown')) return '5crowns';
            if (lower.includes('phase 10') || lower.includes('phase ten') || lower.includes('face 10') || lower.includes('face ten')) return 'phase10';
            if (lower.includes('farkle') || lower.includes('farkel')) return 'farkle';
            if (lower.includes('dart')) return 'darts';
            if (lower.includes('scrabble')) return 'scrabble';
            if (lower.includes('yahtzee') || lower.includes('yatzy')) return 'yahtzee';
            if (lower.includes('general')) return 'general';
            
            // If no match found, default to 'general' for any other game name
            // This allows users to say any game name and we'll use the general format
            return 'general';
        }
        function convertWordToNumber(word) {
            const numbers = {
                'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
                'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,
                'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14,
                'fifteen': 15, 'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19,
                'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,
                'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90,
                'hundred': 100
            };
            
            const lower = word.toLowerCase().trim();
            
            // Check if it's already a number
            if (!isNaN(lower)) {
                return parseInt(lower);
            }
            
            // Check if it's a simple number word
            if (numbers[lower] !== undefined) {
                return numbers[lower];
            }
            
            // Handle compound numbers like "twenty one" or "twenty-one"
            const parts = lower.split(/[\s-]+/);
            if (parts.length === 2) {
                const first = numbers[parts[0]] || 0;
                const second = numbers[parts[1]] || 0;
                if (first > 0 && second > 0 && first >= 20) {
                    return first + second;
                }
            }
            
            return null;
        }
        function correctPronunciation(name) {
            const corrections = {
                'ghee': 'Guy',
                'gee': 'Guy',
                'g': 'Guy',
                'ge': 'Guy',
                'key': 'Guy'
            };
            
            const lowerName = name.toLowerCase().trim();
            
            // Only correct if it's actually a mispronunciation
            // Don't "correct" if user typed the actual name (preserve their capitalization)
            if (corrections[lowerName]) {
                return corrections[lowerName];
            }
            
            // Return original name with original capitalization preserved
            return name;
        }
        // Fuzzy match player name - finds closest match by pronunciation/similarity
        function findClosestPlayer(spokenName) {
            if (!spokenName || players.length === 0) return null;
            
            const spoken = spokenName.toLowerCase().trim();
            
            // First, try exact match
            let player = players.find(p => p.name.toLowerCase() === spoken);
            if (player) return player;
            
            // Try with pronunciation correction
            const corrected = correctPronunciation(spoken);
            player = players.find(p => p.name.toLowerCase() === corrected.toLowerCase());
            if (player) return player;
            
            // Try partial contains match
            player = players.find(p => 
                p.name.toLowerCase().includes(spoken) || 
                spoken.includes(p.name.toLowerCase())
            );
            if (player) return player;
            
            // Calculate similarity scores for all players
            const scores = players.map(p => {
                const playerName = p.name.toLowerCase();
                let score = 0;
                
                // Exact match (already checked above, but just in case)
                if (playerName === spoken) return { player: p, score: 1000 };
                
                // Check if one contains the other
                if (playerName.includes(spoken) || spoken.includes(playerName)) {
                    score += 500;
                }
                
                // Check first letter match
                if (playerName[0] === spoken[0]) {
                    score += 100;
                }
                
                // Check length similarity
                const lengthDiff = Math.abs(playerName.length - spoken.length);
                score += Math.max(0, 50 - (lengthDiff * 10));
                
                // Count matching characters
                const matchingChars = [...spoken].filter(char => playerName.includes(char)).length;
                score += matchingChars * 10;
                
                // Phonetic similarity (vowels)
                const spokenVowels = spoken.match(/[aeiou]/g) || [];
                const playerVowels = playerName.match(/[aeiou]/g) || [];
                const vowelMatch = spokenVowels.filter(v => playerVowels.includes(v)).length;
                score += vowelMatch * 20;
                
                // Check for common sound substitutions
                const soundAlikeMap = {
                    'v': 'b', 'b': 'v',
                    'f': 'v', 'v': 'f',
                    't': 'd', 'd': 't',
                    'k': 'c', 'c': 'k',
                    's': 'z', 'z': 's',
                    'm': 'n', 'n': 'm'
                };
                
                let soundAlikeScore = 0;
                for (let i = 0; i < Math.min(spoken.length, playerName.length); i++) {
                    const spokenChar = spoken[i];
                    const playerChar = playerName[i];
                    if (spokenChar === playerChar) {
                        soundAlikeScore += 15;
                    } else if (soundAlikeMap[spokenChar] === playerChar || soundAlikeMap[playerChar] === spokenChar) {
                        soundAlikeScore += 10;
                    }
                }
                score += soundAlikeScore;
                
                return { player: p, score: score };
            });
            
            // Sort by score descending
            scores.sort((a, b) => b.score - a.score);
            
            console.log('Fuzzy match scores for "' + spoken + '":', scores.map(s => ({ name: s.player.name, score: s.score })));
            
            // Only return a match if the score is reasonably high
            if (scores[0].score > 50) {
                console.log('Fuzzy match found:', scores[0].player.name, 'with score:', scores[0].score);
                return scores[0].player;
            }
            
            return null;
        }
        function switchTab(tabName) {
            // Cancel any voice operations when switching tabs
            cancelAllVoiceOperations();
            
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                // Add active class to the matching button
                if ((tabName === 'scorekeeper' && btn.textContent.trim() === 'Scoring') ||
                    (tabName === 'highscores' && btn.textContent.trim() === 'High Scores')) {
                    btn.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Show/hide game type row based on tab
            const gameTypeRow = document.querySelector('.game-type-row');
            
            if (tabName === 'scorekeeper') {
                document.getElementById('scorekeeperTab').classList.add('active');
                // Show add player section on scorekeeper tab only if user hasn't clicked "Done Adding"
                const addSection = document.getElementById('addPlayerSection');
                if (addSection && !isDoneAdding) {
                    addSection.style.display = 'flex';
                }
                // Show game type row on Scoring tab
                if (gameTypeRow) {
                    gameTypeRow.style.display = 'flex';
                }
            } else if (tabName === 'highscores') {
                console.log('=== SWITCHING TO WALLS TAB ===');
                document.getElementById('highScoresTab').classList.add('active');
                renderWalls();
                
                // Hide add player section on High Scores tab
                const addSection = document.getElementById('addPlayerSection');
                if (addSection) {
                    addSection.style.display = 'none';
                }
                // Hide game type row on High Scores tab
                if (gameTypeRow) {
                    gameTypeRow.style.display = 'none';
                }
                console.log('=== WALLS TAB SWITCH COMPLETE ===');
            }
        }
        function toggleScoringMode(mode) {
            scoringMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-toggle-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide modes
            if (mode === 'standard') {
                document.getElementById('standardMode').style.display = 'block';
                document.getElementById('crownsMode').classList.remove('active');
            } else {
                document.getElementById('standardMode').style.display = 'none';
                document.getElementById('crownsMode').classList.add('active');
                renderCrownsTable();
            }
        }
        function initializeCrownsScores() {
            players.forEach(player => {
                if (!crownsScores[player.id]) {
                    crownsScores[player.id] = {};
                    CROWNS_ROUNDS.forEach(round => {
                        crownsScores[player.id][round] = 0;
                    });
                    saveCrownsScores();
                }
                // Initialize current round tracker
                if (currentCrownsRound[player.id] === undefined) {
                    currentCrownsRound[player.id] = 0; // Start at round 0 (which is "3")
                }
            });
        }
        function addScoreToCurrentRound(playerId, points) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            // Get current round index for this player
            let roundIndex = currentCrownsRound[playerId] || 0;
            
            // If we're past the last round, don't add
            if (roundIndex >= CROWNS_ROUNDS.length) {
                speak('All rounds complete for ' + player.name);
                showVoiceFeedback(`All rounds complete for ${player.name}`, '');
                setTimeout(hideVoiceFeedback, 2000);
                return;
            }
            const round = CROWNS_ROUNDS[roundIndex];
            
            // Add score to current round
            crownsScores[playerId][round] = points;
            saveCrownsScores();
            
            // Move to next round
            currentCrownsRound[playerId] = roundIndex + 1;
            localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            
            // Provide feedback
            speak(`${points} points for ${player.name} in round ${round}`);
            showVoiceFeedback(`${player.name}: ${points} pts (Round ${round})`, '');
            setTimeout(hideVoiceFeedback, 1500);
            
            // Re-render table with highlight
            renderCrownsTableWithHighlight(playerId, round);
        }
        function renderCrownsTableWithHighlight(highlightPlayerId, highlightRound) {
            renderCrownsTable();
            
            // Add highlight class to the newly entered cell
            setTimeout(() => {
                const table = document.getElementById('crownsTable');
                const rows = table.querySelectorAll('tbody tr');
                const roundIndex = CROWNS_ROUNDS.indexOf(highlightRound);
                
                if (roundIndex >= 0 && rows[roundIndex]) {
                    const playerIndex = players.findIndex(p => p.id === highlightPlayerId);
                    if (playerIndex >= 0) {
                        const cells = rows[roundIndex].querySelectorAll('td');
                        // +1 because first cell is the round label
                        if (cells[playerIndex + 1]) {
                            cells[playerIndex + 1].classList.add('newly-entered');
                        }
                    }
                }
            }, 100);
        }
        function renderCrownsTable() {
            if (players.length === 0) {
                document.getElementById('crownsTable').innerHTML = '<tr><td style="padding: 15px 20px 20px 20px; text-align: left; color: var(--text-dim); line-height: 1.5; font-size: 0.9em;"><strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>1. Choose the game you want to play.<br>2. Add Player names.<br>3. Say \"Done Adding\" or Click the \"Done adding Player Names\" button, and the game will start.</td></tr>';
                return;
            }
            initializeCrownsScores();
            let html = '<thead><tr><th class="round-label"><span class="crown-icon"></span></th>';
            
            // Player name headers (editable)
            players.forEach(player => {
                html += `<th class="player-name-header" onclick="editPlayerNameInGrid(${player.id})" id="crown-header-${player.id}">${escapeHtml(player.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            // Round rows
            CROWNS_ROUNDS.forEach(round => {
                const isHighlighted = highlightedRound === round ? ' highlighted' : '';
                if (isHighlighted) {
                    console.log('Round', round, 'should be highlighted. Class:', 'round-label' + isHighlighted);
                }
                html += `<tr><td class="round-label${isHighlighted}" onclick="toggleRoundHighlight('${round}')">${round}</td>`;
                players.forEach(player => {
                    const score = crownsScores[player.id][round] || 0;
                    html += `<td onclick="editCrownsScore(${player.id}, '${round}')" class="editable">${score}</td>`;
                });
                html += '</tr>';
            });
            // Total row
            html += '<tr class="total-row"><td class="round-label">TOT.</td>';
            players.forEach(player => {
                const total = CROWNS_ROUNDS.reduce((sum, round) => sum + (crownsScores[player.id][round] || 0), 0);
                html += `<td>${total}</td>`;
            });
            html += '</tr>';
            html += '</tbody>';
            document.getElementById('crownsTable').innerHTML = html;
        }
        
        function toggleRoundHighlight(round) {
            console.log('=== toggleRoundHighlight called ===');
            console.log('Round clicked:', round);
            console.log('Current highlightedRound:', highlightedRound);
            
            // Toggle the highlight - if already highlighted, unhighlight it
            if (highlightedRound === round) {
                highlightedRound = null;
                console.log('Unhighlighting - set to null');
            } else {
                highlightedRound = round;
                console.log('Highlighting - set to:', round);
            }
            
            console.log('About to re-render table');
            renderCrownsTable();
            console.log('Table re-rendered');
        }
        function editPlayerNameInGrid(playerId) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const currentName = player.name;
            const cell = event.target;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.maxLength = 20;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                // If name is empty, delete the player and their column
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete player');
                    if (shouldDelete) {
                        // Remove player
                        players = players.filter(p => p.id !== playerId);
                        
                        // Remove their scores
                        delete crownsScores[playerId];
                        delete currentCrownsRound[playerId];
                        
                        savePlayers();
                        saveCrownsScores();
                        localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                    }
                    renderCrownsTable();
                    return;
                }
                
                // Update name if changed
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderCrownsTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function editPlayerNameInGolfGrid(playerId) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const currentName = player.name;
            const cell = event.target;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.maxLength = 20;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                // If name is empty, delete the player and their column
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        // Remove player
                        players = players.filter(p => p.id !== playerId);
                        
                        // Remove their scores
                        delete golfScores[playerId];
                        delete currentGolfHole[playerId];
                        
                        savePlayers();
                    }
                    renderGolfTable();
                    return;
                }
                
                // Update name if changed
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderGolfTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function editCrownsScore(playerId, round) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentScore = crownsScores[playerId][round] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="crowns-input-${playerId}-${round}" inputmode="numeric">`;
            
            const input = document.getElementById(`crowns-input-${playerId}-${round}`);
            input.focus();
            input.select();
            const saveScore = () => {
                const newScore = parseInt(input.value) || 0;
                crownsScores[playerId][round] = newScore;
                saveCrownsScores();
                renderCrownsTable();
            };
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function saveCrownsScores() {
            localStorage.setItem('scorekeeper_crowns_scores', JSON.stringify(crownsScores));
        }
        function loadCrownsScores() {
            const saved = localStorage.getItem('scorekeeper_crowns_scores');
            if (saved) {
                crownsScores = JSON.parse(saved);
            }
            
            const savedRounds = localStorage.getItem('scorekeeper_current_crowns_round');
            if (savedRounds) {
                currentCrownsRound = JSON.parse(savedRounds);
            }
        }
        // ===== GOLF SAVE/LOAD FUNCTIONS =====
        
        function saveGolfData() {
            localStorage.setItem('scorekeeper_golf_scores', JSON.stringify(golfScores));
            localStorage.setItem('scorekeeper_golf_par', JSON.stringify(golfCoursePar));
            localStorage.setItem('scorekeeper_golf_hcp', JSON.stringify(golfCourseHCP));
            localStorage.setItem('scorekeeper_golf_yrd', JSON.stringify(golfCourseYRD));
            localStorage.setItem('scorekeeper_golf_yrd_columns', JSON.stringify(golfCourseYrdColumns));
            localStorage.setItem('scorekeeper_golf_current_hole', JSON.stringify(currentGolfHole));
            localStorage.setItem('scorekeeper_current_golf_course', currentGolfCourse);
        }
        function loadGolfData() {
            const savedScores = localStorage.getItem('scorekeeper_golf_scores');
            if (savedScores) {
                golfScores = JSON.parse(savedScores);
            }
            
            const savedPar = localStorage.getItem('scorekeeper_golf_par');
            if (savedPar) {
                golfCoursePar = JSON.parse(savedPar);
            }
            
            const savedHcp = localStorage.getItem('scorekeeper_golf_hcp');
            if (savedHcp) {
                golfCourseHCP = JSON.parse(savedHcp);
            }
            
            const savedYrd = localStorage.getItem('scorekeeper_golf_yrd');
            if (savedYrd) {
                golfCourseYRD = JSON.parse(savedYrd);
            }
            
            const savedYrdColumns = localStorage.getItem('scorekeeper_golf_yrd_columns');
            if (savedYrdColumns) {
                golfCourseYrdColumns = JSON.parse(savedYrdColumns);
                // Ensure only 3 columns (remove Gold, Black, Green if they exist)
                if (golfCourseYrdColumns.length > 3) {
                    golfCourseYrdColumns = golfCourseYrdColumns.slice(0, 3);
                    localStorage.setItem('scorekeeper_golf_yrd_columns', JSON.stringify(golfCourseYrdColumns));
                }
            }
            
            const savedHole = localStorage.getItem('scorekeeper_golf_current_hole');
            if (savedHole) {
                currentGolfHole = JSON.parse(savedHole);
            }
            
            const savedCourse = localStorage.getItem('scorekeeper_current_golf_course');
            if (savedCourse) {
                currentGolfCourse = savedCourse;
                // Populate the dropdown display
                const selectedSpan = document.getElementById('selectedCourseName');
                if (selectedSpan) {
                    selectedSpan.textContent = currentGolfCourse;
                }
            }
        }
        function showVoiceFeedback(text, transcript) {
            const feedback = document.getElementById('voiceFeedback');
            const transcriptEl = document.getElementById('voiceTranscript');
            document.querySelector('.voice-feedback-text').textContent = text;
            // Use innerHTML instead of textContent to allow buttons to render
            transcriptEl.innerHTML = transcript || '';
            feedback.classList.add('show');
        }
        // ===== GOLF GRID FUNCTIONS =====
        
        function initializeGolfScores() {
            // Only initialize if golfScores doesn't exist
            if (!golfScores) {
                golfScores = {};
            }
            if (!currentGolfHole) {
                currentGolfHole = {};
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!golfScores[player.id]) {
                    golfScores[player.id] = {};
                    GOLF_HOLES.forEach(hole => {
                        golfScores[player.id][hole] = 0;
                    });
                }
                // Initialize current hole tracker for new players
                if (currentGolfHole[player.id] === undefined) {
                    currentGolfHole[player.id] = 0; // Start at hole 1 (index 0)
                }
            });
            
            console.log('Initialized golf scores:', golfScores);
        }
        function renderGolfTable() {
            const courseSelector = document.getElementById('golfCourseSelector');
            
            if (players.length === 0) {
                document.getElementById('golfTable').innerHTML = '<tr><td style="padding: 15px 20px 20px 20px; text-align: left; color: var(--text-dim); line-height: 1.5; font-size: 0.9em;"><strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>1. Choose the game you want to play.<br>2. Add Player names.<br>3. Say \"Done Adding\" or Click the \"Done adding Player Names\" button, and the game will start.</td></tr>';
                
                // Hide course selector when no players
                if (courseSelector) courseSelector.style.display = 'none';
                return;
            }
            // Show course selector when players exist
            if (courseSelector) {
                courseSelector.style.display = 'block';
            }
            
            // Check if each data type has any values (for conditional column display)
            const hasParData = Object.keys(golfCoursePar).length > 0;
            const hasHcpData = Object.keys(golfCourseHCP).length > 0;
            const hasYrdData = Object.keys(golfCourseYRD).length > 0;
            
            let html = '<thead><tr>';
            
            // Tee column header
            html += '<th class="crowns-hole-label golf-info-column">Tee</th>';
            
            // Show Par, HCP, and YRD columns if data exists (course is loaded)
            if (hasParData) html += '<th class="crowns-hole-label golf-info-column">Par</th>';
            if (hasHcpData) html += '<th class="crowns-hole-label golf-info-column">HCP</th>';
            if (hasYrdData) {
                // Add 3 yardage columns with editable names
                golfCourseYrdColumns.forEach((colName, idx) => {
                    html += `<th class="crowns-hole-label golf-info-column yrd-column-header" onclick="editYrdColumnName(${idx})" title="Click to edit color name">${escapeHtml(colName)}</th>`;
                });
            }
            
            // Player name headers (editable)
            players.forEach(player => {
                html += `<th class="crowns-player-header" onclick="editPlayerNameInGolfGrid(${player.id})">${escapeHtml(player.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Front 9 holes (1-9)
            for (let i = 0; i < 9; i++) {
                const hole = GOLF_HOLES[i];
                html += `<tr><td class="crowns-hole-label golf-info-column">${hole}</td>`;
                
                // Show Par, HCP, YRD columns if data exists
                if (hasParData) {
                    const par = golfCoursePar[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editPar('${hole}')">${par || ''}</td>`;
                }
                if (hasHcpData) {
                    const hcp = golfCourseHCP[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editHCP('${hole}')">${hcp || ''}</td>`;
                }
                if (hasYrdData) {
                    // Render 3 yardage columns
                    const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
                    yrdArray.forEach((yrdVal, idx) => {
                        html += `<td class="crowns-score golf-info-column" onclick="editYRD('${hole}', ${idx})">${yrdVal || ''}</td>`;
                    });
                }
                
                // Player score columns - show total strokes
                players.forEach(player => {
                    const scoreValue = golfScores[player.id]?.[hole] || 0;
                    const isCurrentHole = currentGolfHole[player.id] === i;
                    const highlightClass = isCurrentHole ? 'crowns-score-highlight' : '';
                    
                    // Display total strokes (or empty if 0)
                    const displayScore = scoreValue || '';
                    
                    html += `<td class="crowns-score editable ${highlightClass}" onclick="editGolfScore(${player.id}, '${hole}')">${displayScore}</td>`;
                });
                html += '</tr>';
            }
            
            // Front 9 Out subtotal row
            html += '<tr class="total-row golf-out-row"><td class="crowns-hole-label golf-info-column">OUT</td>';
            
            // Show course data totals if they exist
            if (hasParData) {
                let front9Par = 0;
                for (let i = 0; i < 9; i++) {
                    front9Par += golfCoursePar[GOLF_HOLES[i]] || 0;
                }
                html += `<td class="crowns-score golf-info-column">${front9Par || ''}</td>`;
            }
            if (hasHcpData) {
                html += `<td class="crowns-score golf-info-column"></td>`; // Empty HCP cell
            }
            if (hasYrdData) {
                // Total yards for front 9 - for each of 3 columns
                for (let colIdx = 0; colIdx < 3; colIdx++) {
                    let front9YrdCol = 0;
                    for (let i = 0; i < 9; i++) {
                        const yrdArray = golfCourseYRD[GOLF_HOLES[i]] || [0, 0, 0];
                        front9YrdCol += yrdArray[colIdx] || 0;
                    }
                    html += `<td class="crowns-score golf-info-column">${front9YrdCol || ''}</td>`;
                }
            }
            
            players.forEach(player => {
                let frontTotal = 0;
                for (let i = 0; i < 9; i++) {
                    const hole = GOLF_HOLES[i];
                    frontTotal += golfScores[player.id]?.[hole] || 0;
                }
                html += `<td class="crowns-score">${frontTotal || ''}</td>`;
            });
            html += '</tr>';
            
            // Back 9 holes (10-18)
            for (let i = 9; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                html += `<tr><td class="crowns-hole-label golf-info-column">${hole}</td>`;
                
                // Show Par, HCP, YRD columns if data exists
                if (hasParData) {
                    const par = golfCoursePar[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editPar('${hole}')">${par || ''}</td>`;
                }
                if (hasHcpData) {
                    const hcp = golfCourseHCP[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editHCP('${hole}')">${hcp || ''}</td>`;
                }
                if (hasYrdData) {
                    // Render 3 yardage columns
                    const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
                    yrdArray.forEach((yrdVal, idx) => {
                        html += `<td class="crowns-score golf-info-column" onclick="editYRD('${hole}', ${idx})">${yrdVal || ''}</td>`;
                    });
                }
                
                // Player score columns - show total strokes
                players.forEach(player => {
                    const scoreValue = golfScores[player.id]?.[hole] || 0;
                    const isCurrentHole = currentGolfHole[player.id] === i;
                    const highlightClass = isCurrentHole ? 'crowns-score-highlight' : '';
                    
                    // Display total strokes (or empty if 0)
                    const displayScore = scoreValue || '';
                    
                    html += `<td class="crowns-score editable ${highlightClass}" onclick="editGolfScore(${player.id}, '${hole}')">${displayScore}</td>`;
                });
                html += '</tr>';
            }
            
            // Back 9 IN subtotal row
            html += '<tr class="total-row"><td class="crowns-hole-label golf-info-column">IN</td>';
            
            // Show course data totals if they exist
            if (hasParData) {
                let back9Par = 0;
                for (let i = 9; i < 18; i++) {
                    back9Par += golfCoursePar[GOLF_HOLES[i]] || 0;
                }
                html += `<td class="crowns-score golf-info-column">${back9Par || ''}</td>`;
            }
            if (hasHcpData) {
                html += `<td class="crowns-score golf-info-column"></td>`; // Empty HCP cell
            }
            if (hasYrdData) {
                // Total yards for back 9 - for each of 3 columns
                for (let colIdx = 0; colIdx < 3; colIdx++) {
                    let back9YrdCol = 0;
                    for (let i = 9; i < 18; i++) {
                        const yrdArray = golfCourseYRD[GOLF_HOLES[i]] || [0, 0, 0];
                        back9YrdCol += yrdArray[colIdx] || 0;
                    }
                    html += `<td class="crowns-score golf-info-column">${back9YrdCol || ''}</td>`;
                }
            }
            
            players.forEach(player => {
                let backTotal = 0;
                for (let i = 9; i < 18; i++) {
                    const hole = GOLF_HOLES[i];
                    backTotal += golfScores[player.id]?.[hole] || 0;
                }
                html += `<td class="crowns-score">${backTotal || ''}</td>`;
            });
            html += '</tr>';
            
            // TOTAL row
            html += '<tr class="total-row"><td class="crowns-hole-label golf-info-column">TOT.</td>';
            
            // Show course data totals if they exist
            if (hasParData) {
                let totalPar = 0;
                GOLF_HOLES.forEach(hole => {
                    totalPar += golfCoursePar[hole] || 0;
                });
                html += `<td class="crowns-score golf-info-column">${totalPar || ''}</td>`;
            }
            if (hasHcpData) {
                html += `<td class="crowns-score golf-info-column"></td>`; // Empty HCP cell
            }
            if (hasYrdData) {
                // Total yards for 18 holes - for each of 3 columns
                for (let colIdx = 0; colIdx < 3; colIdx++) {
                    let totalYrdCol = 0;
                    GOLF_HOLES.forEach(hole => {
                        const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
                        totalYrdCol += yrdArray[colIdx] || 0;
                    });
                    html += `<td class="crowns-score golf-info-column">${totalYrdCol || ''}</td>`;
                }
            }
            
            players.forEach(player => {
                let total = 0;
                GOLF_HOLES.forEach(hole => {
                    total += golfScores[player.id]?.[hole] || 0;
                });
                html += `<td class="crowns-score">${total || ''}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('golfTable').innerHTML = html;
        }
        function editPar(hole) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentPar = golfCoursePar[hole] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentPar}" id="par-input-${hole}" inputmode="numeric" min="1" max="9">`;
            
            const input = document.getElementById(`par-input-${hole}`);
            input.focus();
            input.select();
            const savePar = () => {
                const newPar = parseInt(input.value);
                if (!isNaN(newPar) && newPar > 0) {
                    golfCoursePar[hole] = newPar;
                } else if (input.value === '' || input.value === '0') {
                    delete golfCoursePar[hole];
                }
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', savePar);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editHCP(hole) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentHCP = golfCourseHCP[hole] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentHCP}" id="hcp-input-${hole}" inputmode="numeric" min="1" max="18">`;
            
            const input = document.getElementById(`hcp-input-${hole}`);
            input.focus();
            input.select();
            const saveHCP = () => {
                const newHCP = parseInt(input.value);
                if (!isNaN(newHCP) && newHCP > 0) {
                    golfCourseHCP[hole] = newHCP;
                } else if (input.value === '' || input.value === '0') {
                    delete golfCourseHCP[hole];
                }
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', saveHCP);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editYRD(hole, colIdx) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
            const currentYRD = yrdArray[colIdx] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentYRD}" id="yrd-input-${hole}-${colIdx}" inputmode="numeric" min="1" max="999">`;
            
            const input = document.getElementById(`yrd-input-${hole}-${colIdx}`);
            input.focus();
            input.select();
            const saveYRD = () => {
                const newYRD = parseInt(input.value);
                
                // Initialize array if it doesn't exist
                if (!golfCourseYRD[hole]) {
                    golfCourseYRD[hole] = [0, 0, 0];
                }
                
                if (!isNaN(newYRD) && newYRD > 0) {
                    golfCourseYRD[hole][colIdx] = newYRD;
                } else if (input.value === '' || input.value === '0') {
                    golfCourseYRD[hole][colIdx] = 0;
                }
                
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', saveYRD);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        async function editYrdColumnName(colIdx) {
            const currentName = golfCourseYrdColumns[colIdx];
            const newName = await customPrompt(`Edit tee box color name:`, ` Edit column name`, currentName);
            
            if (newName && newName.trim()) {
                golfCourseYrdColumns[colIdx] = newName.trim();
                saveGolfData();
                renderGolfTable();
            }
        }
        function editYrdColumnNameInModal(colIdx) {
            // Use the columns being edited in the modal, not the global ones
            const editingColumns = window.currentEditingYrdColumns || golfCourseYrdColumns;
            const currentName = editingColumns[colIdx];
            
            // Find the header element
            const headers = document.querySelectorAll('.edit-course-grid-header');
            const headerCell = headers[3 + colIdx]; // First 3 are Tee, Par, HCP
            
            if (!headerCell) return;
            
            // Replace with input
            headerCell.innerHTML = `<input type="text" class="edit-yrd-name-input" id="yrd-name-input-${colIdx}" value="${escapeHtml(currentName)}" maxlength="20" style="width: 100%; padding: 8px; background: rgba(0, 245, 255, 0.2); border: 2px solid var(--neon-blue); border-radius: 6px; color: var(--text-primary); font-family: Outfit, sans-serif; font-size: 0.9rem; font-weight: 700; text-align: center;">`;
            
            const input = document.getElementById(`yrd-name-input-${colIdx}`);
            input.focus();
            input.select();
            
            // Save on blur or Enter
            const saveEdit = () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    // If empty, restore original name
                    headerCell.textContent = currentName;
                    headerCell.style.cursor = 'pointer';
                    return;
                }
                
                // Update the stored columns
                editingColumns[colIdx] = newName;
                window.currentEditingYrdColumns = editingColumns;
                
                // Update the header
                headerCell.textContent = newName;
                headerCell.style.cursor = 'pointer';
            };
            
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        async function saveGolfCourse() {
            const courseName = document.getElementById('golfCourseName').value.trim();
            
            if (!courseName) {
                await customAlert('Please enter a course name', ' Course name required');
                return;
            }
            
            // Check if par values are set
            const hasParData = Object.keys(golfCoursePar).length > 0;
            if (!hasParData) {
                await customAlert('Please enter Par values for the holes before saving', ' Par values required');
                return;
            }
            
            // Save course data
            savedGolfCourses[courseName] = {
                par: {...golfCoursePar},
                hcp: {...golfCourseHCP},
                yrd: {...golfCourseYRD},
                yrdColumns: [...golfCourseYrdColumns]
            };
            
            currentGolfCourse = courseName;
            
            localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
            
            // Save current golf data
            saveGolfData();
            
            // Update the datalist
            updateSavedCoursesList();
            
            await customAlert(`Course "${courseName}" saved successfully!`, ' Course saved');
            console.log('Saved golf course:', courseName);
        }
        function editCourse(courseName) {
            if (!savedGolfCourses[courseName]) {
                customAlert(`Course "${courseName}" not found.`, ' Course not found');
                return;
            }
            
            // Close dropdown
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Store the original course name for reference
            window.editingCourseName = courseName;
            
            // Get course data
            const course = savedGolfCourses[courseName];
            
            // Populate the edit modal
            const modal = document.getElementById('editCourseModal');
            const nameInput = document.getElementById('editCourseName');
            const gridContainer = document.getElementById('editCourseGrid');
            
            nameInput.value = courseName;
            
            // Build the grid
            let html = `
                <div class="edit-course-grid-header">Tee</div>
                <div class="edit-course-grid-header">Par</div>
                <div class="edit-course-grid-header">HCP</div>
            `;
            
            // Add 4 YRD column headers: Gold, Blue, White, Red
            // Always use these 4 as defaults
            let courseYrdColumns = course.yrdColumns || ['Gold', 'Blue', 'White', 'Red'];
            
            // Ensure we have exactly 4 columns
            if (courseYrdColumns.length < 4) {
                // Pad with defaults if less than 4
                const defaultNames = ['Gold', 'Blue', 'White', 'Red'];
                while (courseYrdColumns.length < 4) {
                    courseYrdColumns.push(defaultNames[courseYrdColumns.length]);
                }
            } else if (courseYrdColumns.length > 4) {
                courseYrdColumns = courseYrdColumns.slice(0, 4);
            }
            
            // Store these for use in the modal editing
            window.currentEditingYrdColumns = [...courseYrdColumns];
            
            courseYrdColumns.forEach((colName, idx) => {
                html += `<div class="edit-course-grid-header" onclick="editYrdColumnNameInModal(${idx})" style="cursor: pointer;" title="Click to edit color name">${escapeHtml(colName)}</div>`;
            });
            
            for (let i = 0; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                const par = course.par[hole] || '';
                const hcp = course.hcp[hole] || '';
                const yrdArray = course.yrd?.[hole] || [0, 0, 0, 0];
                
                html += `
                    <div class="edit-course-grid-item" style="font-weight: 700;">${hole}</div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-par-${hole}" value="${par}" min="1" max="9" inputmode="numeric">
                    </div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-hcp-${hole}" value="${hcp}" min="1" max="18" inputmode="numeric">
                    </div>
                `;
                
                // Add 4 YRD input fields (Gold, Blue, White, Red)
                for (let colIdx = 0; colIdx < 4; colIdx++) {
                    const yrdVal = yrdArray[colIdx] || '';
                    html += `
                        <div class="edit-course-grid-item">
                            <input type="number" class="edit-course-input" id="edit-yrd-${hole}-${colIdx}" value="${yrdVal}" min="1" max="999" inputmode="numeric">
                        </div>
                    `;
                }
            }
            
            gridContainer.innerHTML = html;
            
            // Show modal
            modal.classList.add('show');
        }
        function addNewCourse() {
            // Close dropdown
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Mark that we're creating a new course (not editing)
            window.editingCourseName = null;
            
            // Populate the edit modal with empty data
            const modal = document.getElementById('editCourseModal');
            const nameInput = document.getElementById('editCourseName');
            const gridContainer = document.getElementById('editCourseGrid');
            
            if (!modal || !nameInput || !gridContainer) {
                console.error('Modal elements not found!');
                return;
            }
            
            nameInput.value = '';
            
            // Build the grid with empty values
            let html = `
                <div class="edit-course-grid-header">Tee</div>
                <div class="edit-course-grid-header">Par</div>
                <div class="edit-course-grid-header">HCP</div>
            `;
            
            // Add 4 YRD column headers: Gold, Blue, White, Red
            const displayColumns = ['Gold', 'Blue', 'White', 'Red'];
            
            // Store these for use in the modal editing
            window.currentEditingYrdColumns = [...displayColumns];
            
            displayColumns.forEach((colName, idx) => {
                html += `<div class="edit-course-grid-header" onclick="editYrdColumnNameInModal(${idx})" style="cursor: pointer;" title="Click to edit color name">${escapeHtml(colName)}</div>`;
            });
            
            for (let i = 0; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                
                html += `
                    <div class="edit-course-grid-item" style="font-weight: 700;">${hole}</div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-par-${hole}" value="" min="1" max="9" inputmode="numeric" placeholder="Par">
                    </div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-hcp-${hole}" value="" min="1" max="18" inputmode="numeric" placeholder="HCP">
                    </div>
                `;
                
                // Add 4 YRD input fields (Gold, Blue, White, Red)
                for (let colIdx = 0; colIdx < 4; colIdx++) {
                    html += `
                        <div class="edit-course-grid-item">
                            <input type="number" class="edit-course-input" id="edit-yrd-${hole}-${colIdx}" value="" min="1" max="999" inputmode="numeric" placeholder="Yds">
                        </div>
                    `;
                }
            }
            
            gridContainer.innerHTML = html;
            
            // Show modal
            modal.classList.add('show');
        }
        function closeEditCourseModal() {
            const modal = document.getElementById('editCourseModal');
            modal.classList.remove('show');
            window.editingCourseName = null;
            window.currentEditingYrdColumns = null;
        }
        async function saveEditedCourse() {
            const originalName = window.editingCourseName;
            const newName = document.getElementById('editCourseName').value.trim();
            
            if (!newName) {
                await customAlert('Please enter a course name', ' Course name required');
                return;
            }
            
            // Collect Par and HCP values
            const newPar = {};
            const newHcp = {};
            const newYrd = {};
            let hasParData = false;
            
            for (let i = 0; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                const parInput = document.getElementById(`edit-par-${hole}`);
                const hcpInput = document.getElementById(`edit-hcp-${hole}`);
                
                const parValue = parseInt(parInput.value);
                const hcpValue = parseInt(hcpInput.value);
                
                if (!isNaN(parValue) && parValue > 0) {
                    newPar[hole] = parValue;
                    hasParData = true;
                }
                
                if (!isNaN(hcpValue) && hcpValue > 0) {
                    newHcp[hole] = hcpValue;
                }
                
                // Collect 4 YRD values (Gold, Blue, White, Red)
                const yrdArray = [0, 0, 0, 0];
                let hasYrdData = false;
                for (let colIdx = 0; colIdx < 4; colIdx++) {
                    const yrdInput = document.getElementById(`edit-yrd-${hole}-${colIdx}`);
                    const yrdValue = parseInt(yrdInput.value);
                    if (!isNaN(yrdValue) && yrdValue > 0) {
                        yrdArray[colIdx] = yrdValue;
                        hasYrdData = true;
                    }
                }
                
                if (hasYrdData) {
                    newYrd[hole] = yrdArray;
                }
            }
            
            // Use the edited yrdColumns from the modal, not the global ones
            const newYrdColumns = window.currentEditingYrdColumns || ['Gold', 'Blue', 'White', 'Red'];
            
            if (!hasParData) {
                await customAlert('Please enter at least one Par value', ' Par values required');
                return;
            }
            
            // Check if name changed and new name already exists
            if (newName !== originalName && savedGolfCourses[newName]) {
                const overwrite = await customConfirm(`A course named "${newName}" already exists. Do you want to overwrite it?`, ' Course exists');
                if (!overwrite) {
                    return;
                }
            }
            
            // Remove old course if name changed
            if (newName !== originalName) {
                delete savedGolfCourses[originalName];
            }
            
            // Save updated course
            savedGolfCourses[newName] = {
                par: newPar,
                hcp: newHcp,
                yrd: newYrd,
                yrdColumns: newYrdColumns
            };
            
            localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
            
            // Update datalist
            updateSavedCoursesList();
            
            // If this is the currently loaded course, update it
            if (currentGolfCourse === originalName) {
                currentGolfCourse = newName;
                golfCoursePar = {...newPar};
                golfCourseHCP = {...newHcp};
                golfCourseYRD = {...newYrd};
                golfCourseYrdColumns = [...newYrdColumns];
                
                const selectedSpan = document.getElementById('selectedCourseName');
                if (selectedSpan) {
                    selectedSpan.textContent = newName;
                }
                
                saveGolfData();
                renderGolfTable();
            }
            
            // Close edit modal
            const editModal = document.getElementById('editCourseModal');
            editModal.classList.remove('show');
            window.editingCourseName = null;
            
            // Show success message
            const isNewCourse = !originalName;
            const successMessage = isNewCourse ? 
                `Course "${newName}" created successfully!` : 
                `Course "${newName}" updated successfully!`;
            await customAlert(successMessage, isNewCourse ? ' Course created' : ' Course updated');
            
            console.log('Updated golf course:', newName);
        }
        async function deleteCourse(courseName) {
            const confirm = await customConfirm(`Are you sure you want to delete "${courseName}"? This cannot be undone.`, ' Delete course');
            
            if (confirm) {
                delete savedGolfCourses[courseName];
                localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
                
                // Update dropdown list
                updateSavedCoursesList();
                
                // Show success message
                showVoiceFeedback(`Course Deleted: ${courseName}`, 'Successfully removed');
                setTimeout(hideVoiceFeedback, 2000);
                
                console.log('Deleted golf course:', courseName);
            }
        }
        function updateSavedCoursesList() {
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (!dropdownList) return;
            
            dropdownList.innerHTML = '';
            
            const courseNames = Object.keys(savedGolfCourses);
            const selectedSpan = document.getElementById('selectedCourseName');
            
            if (courseNames.length === 0) {
                // If no courses, show "Add a course" as the selected text
                if (selectedSpan) {
                    selectedSpan.textContent = 'Add a course';
                }
                
                // Don't populate dropdown list - clicking will directly open modal
            } else {
                // When courses exist, show "Select a course" if no course is currently loaded
                if (selectedSpan && !currentGolfCourse) {
                    selectedSpan.textContent = 'Select a course';
                }
                
                // Show all courses
                courseNames.forEach(courseName => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-list-item';
                    
                    // Create course name span (clickable to load)
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'dropdown-course-name';
                    nameSpan.textContent = courseName;
                    nameSpan.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        selectCourseFromDropdown(courseName);
                    });
                    
                    // Create buttons container
                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'dropdown-course-actions';
                    
                    // Edit button
                    const editBtn = document.createElement('button');
                    editBtn.className = 'dropdown-action-btn';
                    editBtn.innerHTML = '';
                    editBtn.title = 'Edit course';
                    editBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        editCourse(courseName);
                    });
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'dropdown-action-btn';
                    deleteBtn.innerHTML = '';
                    deleteBtn.title = 'Delete course';
                    deleteBtn.addEventListener('click', async function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        await deleteCourse(courseName);
                    });
                    
                    buttonsDiv.appendChild(editBtn);
                    buttonsDiv.appendChild(deleteBtn);
                    
                    item.appendChild(nameSpan);
                    item.appendChild(buttonsDiv);
                    dropdownList.appendChild(item);
                });
                
                // Add "Add New Course" button at bottom
                const addButton = document.createElement('div');
                addButton.className = 'dropdown-add-new-btn';
                addButton.innerHTML = ' Add new course';
                addButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    addNewCourse();
                });
                dropdownList.appendChild(addButton);
            }
        }
        function toggleGolfCourseDropdown() {
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            
            if (!dropdown || !dropdownList) {
                return;
            }
            
            // If no courses exist, directly open the Add Course dialog
            const courseNames = Object.keys(savedGolfCourses);
            
            if (courseNames.length === 0) {
                addNewCourse();
                return;
            }
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        function selectCourseFromDropdown(courseName) {
            const selectedSpan = document.getElementById('selectedCourseName');
            if (selectedSpan) {
                selectedSpan.textContent = courseName;
            }
            
            // Close the dropdown
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Load the course
            loadCourseByName(courseName);
        }
        
        function toggleGameTypeDropdown() {
            const dropdown = document.getElementById('gameTypeDropdown');
            const dropdownList = document.getElementById('gameTypeDropdownList');
            
            if (!dropdown || !dropdownList) return;
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        
        function selectGameType(gameValue) {
            console.log('=== selectGameType called ===');
            console.log('gameValue:', gameValue);
            
            const selectedSpan = document.getElementById('selectedGameType');
            const hiddenSelect = document.getElementById('gameType');
            const dropdown = document.getElementById('gameTypeDropdown');
            const dropdownList = document.getElementById('gameTypeDropdownList');
            
            // Get display name from the clicked item
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            if (selectedSpan) {
                selectedSpan.textContent = gameNames[gameValue] || gameValue;
            }
            
            // Update hidden select
            if (hiddenSelect) {
                hiddenSelect.value = gameValue;
                console.log('Updated hidden select to:', hiddenSelect.value);
            }
            
            // Explicitly set currentGameType
            currentGameType = gameValue;
            console.log('Set currentGameType to:', currentGameType);
            
            // Close dropdown
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Trigger change
            console.log('About to call changeGameType()');
            changeGameType();
        }
        
        function toggleThemeDropdown() {
            const dropdown = document.getElementById('themeDropdown');
            const dropdownList = document.getElementById('themeDropdownList');
            
            if (!dropdown || !dropdownList) return;
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        
        function selectTheme(themeValue) {
            const selectedSpan = document.getElementById('selectedTheme');
            const hiddenSelect = document.getElementById('themeSelect');
            const dropdown = document.getElementById('themeDropdown');
            const dropdownList = document.getElementById('themeDropdownList');
            
            // Get display name
            const themeNames = {
                'stainless': 'Steel',
                'default': 'Neon'
            };
            
            if (selectedSpan) {
                selectedSpan.textContent = themeNames[themeValue] || themeValue;
            }
            
            // Update hidden select
            if (hiddenSelect) {
                hiddenSelect.value = themeValue;
            }
            
            // Close dropdown
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Trigger theme change
            changeTheme();
        }
        
        function loadCourseByName(courseName) {
            if (!savedGolfCourses[courseName]) {
                customAlert(`Course "${courseName}" not found.`, ' Course not found');
                return;
            }
            
            // Load course data
            const courseData = savedGolfCourses[courseName];
            golfCoursePar = {...courseData.par};
            golfCourseHCP = {...courseData.hcp};
            golfCourseYRD = {...(courseData.yrd || {})};
            
            // Load column names if saved with course, otherwise use defaults
            if (courseData.yrdColumns) {
                golfCourseYrdColumns = [...courseData.yrdColumns];
            } else {
                golfCourseYrdColumns = ['Blue', 'White', 'Red'];
            }
            
            currentGolfCourse = courseName;
            
            saveGolfData();
            renderGolfTable();
            
            // Show feedback
            showVoiceFeedback(`Course Loaded: ${courseName}`, `Par ${Object.values(golfCoursePar).reduce((sum, val) => sum + val, 0)}`);
            setTimeout(hideVoiceFeedback, 2000);
            
            console.log('Loaded golf course:', courseName);
        }
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            // Close golf course dropdown
            const golfDropdown = document.getElementById('golfCourseDropdown');
            const golfDropdownList = document.getElementById('golfCourseDropdownList');
            
            if (golfDropdown && golfDropdownList && 
                !golfDropdown.contains(e.target) && 
                !golfDropdownList.contains(e.target)) {
                golfDropdown.classList.remove('open');
                golfDropdownList.classList.remove('open');
            }
            
            // Close game type dropdown
            const gameDropdown = document.getElementById('gameTypeDropdown');
            const gameDropdownList = document.getElementById('gameTypeDropdownList');
            
            if (gameDropdown && gameDropdownList && 
                !gameDropdown.contains(e.target) && 
                !gameDropdownList.contains(e.target)) {
                gameDropdown.classList.remove('open');
                gameDropdownList.classList.remove('open');
            }
            
            // Close theme dropdown
            const themeDropdown = document.getElementById('themeDropdown');
            const themeDropdownList = document.getElementById('themeDropdownList');
            
            if (themeDropdown && themeDropdownList && 
                !themeDropdown.contains(e.target) && 
                !themeDropdownList.contains(e.target)) {
                themeDropdown.classList.remove('open');
                themeDropdownList.classList.remove('open');
            }
            
            // Close scorecard dropdown
            const scorecardDropdown = document.getElementById('scorecardDropdown');
            const scorecardDropdownList = document.getElementById('scorecardDropdownList');
            
            if (scorecardDropdown && scorecardDropdownList && 
                !scorecardDropdown.contains(e.target) && 
                !scorecardDropdownList.contains(e.target)) {
                scorecardDropdown.classList.remove('open');
                scorecardDropdownList.classList.remove('open');
            }
            
            // Close wins tracker dropdown
            const winsTrackerDropdown = document.getElementById('winsTrackerDropdown');
            const winsTrackerDropdownList = document.getElementById('winsTrackerDropdownList');
            
            if (winsTrackerDropdown && winsTrackerDropdownList && 
                !winsTrackerDropdown.contains(e.target) && 
                !winsTrackerDropdownList.contains(e.target)) {
                winsTrackerDropdown.classList.remove('open');
                winsTrackerDropdownList.classList.remove('open');
            }
        });
        function loadSavedGolfCourses() {
            const saved = localStorage.getItem('scorekeeper_golf_courses');
            if (saved) {
                try {
                    savedGolfCourses = JSON.parse(saved);
                    
                    const standardNames = ['Blue', 'White', 'Red'];
                    
                    // Clean up any courses that have more than 3 yardage columns
                    Object.keys(savedGolfCourses).forEach(courseName => {
                        const course = savedGolfCourses[courseName];
                        
                        // Limit yrdColumns to 3 and replace Gold, Black, Green
                        if (course.yrdColumns) {
                            if (course.yrdColumns.length > 3) {
                                course.yrdColumns = course.yrdColumns.slice(0, 3);
                            }
                            // Replace Gold, Black, Green with Blue, White, Red
                            course.yrdColumns = course.yrdColumns.map((name, idx) => {
                                if (['Gold', 'Black', 'Green'].includes(name)) {
                                    return standardNames[idx] || name;
                                }
                                return name;
                            });
                        } else {
                            course.yrdColumns = standardNames;
                        }
                        
                        // Limit each hole's yardage array to 3 values
                        if (course.yrd) {
                            Object.keys(course.yrd).forEach(hole => {
                                if (Array.isArray(course.yrd[hole]) && course.yrd[hole].length > 3) {
                                    course.yrd[hole] = course.yrd[hole].slice(0, 3);
                                }
                            });
                        }
                    });
                    
                    // Save cleaned data back to localStorage
                    localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
                } catch (e) {
                    console.error('Error loading golf courses:', e);
                }
            }
            // Always update the list to show proper default text
            updateSavedCoursesList();
        }
        function editGolfScore(playerId, hole) {
            // Cancel voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const cell = event.target;
            const currentScore = golfScores[playerId][hole] || 0;
            // Always use number input for total strokes
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="golf-input-${playerId}-${hole}" inputmode="numeric" min="0" max="20">`;
            
            const input = document.getElementById(`golf-input-${playerId}-${hole}`);
            input.focus();
            input.select();
            const saveScore = () => {
                const newScore = parseInt(input.value) || 0;
                if (!isNaN(newScore) && newScore >= 0) {
                    if (!golfScores[playerId]) {
                        golfScores[playerId] = {};
                    }
                    golfScores[playerId][hole] = newScore;
                }
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function addScoreToCurrentGolfHole(playerId, points) {
            const holeIndex = currentGolfHole[playerId];
            if (holeIndex >= GOLF_HOLES.length) {
                console.log('All holes completed for player', playerId);
                return false;
            }
            
            const hole = GOLF_HOLES[holeIndex];
            golfScores[playerId][hole] = points;
            
            // Move to next hole
            currentGolfHole[playerId] = holeIndex + 1;
            
            saveGolfData();
            
            console.log(`Added ${points} for player ${playerId} in hole ${hole}`);
            renderGolfTableWithHighlight(playerId, hole);
            
            return true;
        }
        function renderGolfTableWithHighlight(playerId, hole) {
            renderGolfTable();
            
            // Add temporary highlight animation
            setTimeout(() => {
                const cells = document.querySelectorAll('.crowns-score-highlight');
                cells.forEach(cell => {
                    cell.classList.remove('crowns-score-highlight');
                });
            }, 2000);
        }
        function toggleGolfMode() {
            const toggle = document.getElementById('golfModeToggle');
            const simpleLabel = document.getElementById('simpleLabel');
            const advancedLabel = document.getElementById('advancedLabel');
            
            if (toggle.checked) {
                // Advanced mode
                golfMode = 'advanced';
                simpleLabel.classList.remove('active');
                advancedLabel.classList.add('active');
                
                // Save preference
                localStorage.setItem('scorekeeper_golf_mode', 'advanced');
                
                console.log(' Switched to Advanced Golf mode');
                
                // Show helpful message
                showVoiceFeedback('Advanced Golf Mode', 'Enter course, set Par/HCP, use "over/under" scoring');
                setTimeout(hideVoiceFeedback, 3000);
                
                // Re-render golf table with advanced features
                renderGolfTable();
            } else {
                // Simple mode
                golfMode = 'simple';
                simpleLabel.classList.add('active');
                advancedLabel.classList.remove('active');
                
                // Save preference
                localStorage.setItem('scorekeeper_golf_mode', 'simple');
                
                console.log(' Switched to Simple Golf mode');
                
                // Show helpful message
                showVoiceFeedback('Simple Golf Mode', 'Standard stroke count scoring');
                setTimeout(hideVoiceFeedback, 2000);
                
                // Re-render golf table in simple mode
                renderGolfTable();
            }
        }
        
        // Load golf mode preference on page load
        function loadGolfMode() {
            const savedMode = localStorage.getItem('scorekeeper_golf_mode') || 'simple';
            const toggle = document.getElementById('golfModeToggle');
            
            if (toggle && savedMode === 'advanced') {
                toggle.checked = true;
                toggleGolfMode();
            } else if (toggle) {
                toggle.checked = false;
                golfMode = 'simple';
            }
        }
        // ===== SCRABBLE GRID FUNCTIONS =====
        
        function initializeScrabbleScores() {
            // Only initialize if scrabbleScores doesn't exist
            if (!scrabbleScores) {
                scrabbleScores = {};
            }
            if (!currentScrabbleTurn) {
                currentScrabbleTurn = {};
            }
            
            // Only reset turns if we're starting fresh (no existing scores)
            if (Object.keys(scrabbleScores).length === 0) {
                SCRABBLE_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
                scrabbleMaxTurn = 12;
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!scrabbleScores[player.id]) {
                    scrabbleScores[player.id] = {};
                    SCRABBLE_TURNS.forEach(turn => {
                        scrabbleScores[player.id][turn] = 0;
                    });
                    scrabbleScores[player.id]['unplayed'] = 0;
                    scrabbleScores[player.id]['opponents'] = 0;
                }
                // Initialize current turn tracker for new players
                if (currentScrabbleTurn[player.id] === undefined) {
                    currentScrabbleTurn[player.id] = 0; // Start at turn 1 (index 0)
                }
            });
            
            console.log('Initialized Scrabble scores:', scrabbleScores);
        }
        function renderScrabbleTable() {
            const buttonContainer = document.getElementById('scrabbleButtons');
            
            console.log('=== RENDER SCRABBLE TABLE ===');
            console.log('Players:', players.length);
            console.log('scrabbleScores:', JSON.stringify(scrabbleScores, null, 2));
            
            if (players.length === 0) {
                document.getElementById('scrabbleTable').innerHTML = '<tr><td style="padding: 15px 20px 20px 20px; text-align: left; color: var(--text-dim); line-height: 1.5; font-size: 0.9em;"><strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>1. Choose the game you want to play.<br>2. Add Player names.<br>3. Say \"Done Adding\" or Click the \"Done adding Player Names\" button, and the game will start.</td></tr>';
                // Hide buttons when no players
                if (buttonContainer) buttonContainer.style.display = 'none';
                return;
            }
            // Show buttons when players exist
            if (buttonContainer) buttonContainer.style.display = 'flex';
            let html = '<thead><tr><th class="crowns-hole-label">TURN</th>';
            
            // Header row with player names (editable)
            players.forEach(player => {
                html += `<th class="crowns-player-header" onclick="editPlayerNameInScrabbleGrid(${player.id})">${escapeHtml(player.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Turn rows
            SCRABBLE_TURNS.forEach((turn, index) => {
                html += `<tr><td class="crowns-hole-label">${turn}</td>`;
                players.forEach(player => {
                    const score = scrabbleScores[player.id]?.[turn] || 0;
                    const isCurrentTurn = currentScrabbleTurn[player.id] === index;
                    const highlightClass = isCurrentTurn ? 'crowns-score-highlight' : '';
                    html += `<td class="crowns-score ${highlightClass}" onclick="editScrabbleScore(${player.id}, '${turn}')">${score}</td>`;
                });
                html += '</tr>';
            });
            
            // Unplayed Tiles row
            html += '<tr><td class="crowns-hole-label" style="background: rgba(255,0,110,0.1);">Unplayed Tiles</td>';
            players.forEach(player => {
                const score = scrabbleScores[player.id]?.['unplayed'] || 0;
                // Display as negative number (except 0)
                const displayScore = score === 0 ? 0 : -score;
                console.log(`Rendering ${player.name} unplayed: ${displayScore}`);
                html += `<td class="crowns-score" style="background: rgba(255,0,110,0.1);" onclick="editScrabbleScore(${player.id}, 'unplayed')">${displayScore}</td>`;
            });
            html += '</tr>';
            
            // Opponents' Tiles row
            html += '<tr><td class="crowns-hole-label" style="background: rgba(0,245,255,0.1);">Opponents\' Tiles</td>';
            players.forEach(player => {
                const score = scrabbleScores[player.id]?.['opponents'] || 0;
                console.log(`Rendering ${player.name} opponents: ${score}`);
                html += `<td class="crowns-score" style="background: rgba(0,245,255,0.1);" onclick="editScrabbleScore(${player.id}, 'opponents')">${score}</td>`;
            });
            html += '</tr>';
            
            // Total row
            html += '<tr class="crowns-total-row"><td class="crowns-hole-label">Total Points</td>';
            players.forEach(player => {
                // Sum turn scores, subtract unplayed, add opponents
                let total = 0;
                SCRABBLE_TURNS.forEach(turn => {
                    total += scrabbleScores[player.id]?.[turn] || 0;
                });
                total -= scrabbleScores[player.id]?.['unplayed'] || 0;
                total += scrabbleScores[player.id]?.['opponents'] || 0;
                html += `<td class="crowns-total">${total}</td>`;
            });
            html += '</tr></tbody>';
            
            document.getElementById('scrabbleTable').innerHTML = html;
        }
        function editPlayerNameInScrabbleGrid(playerId) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const currentName = player.name;
            const cell = event.target;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.maxLength = 20;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete scrabbleScores[playerId];
                        delete currentScrabbleTurn[playerId];
                        savePlayers();
                    }
                    renderScrabbleTable();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderScrabbleTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function editScrabbleScore(playerId, turn) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentScore = scrabbleScores[playerId][turn] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="scrabble-input-${playerId}-${turn}" inputmode="numeric">`;
            
            const input = document.getElementById(`scrabble-input-${playerId}-${turn}`);
            input.focus();
            input.select();
            const saveScore = () => {
                const newScore = parseInt(input.value) || 0;
                scrabbleScores[playerId][turn] = newScore;
                
                // If unplayed tiles changed, recalculate opponents' tiles distribution
                if (turn === 'unplayed') {
                    console.log('Unplayed tiles changed - recalculating distribution');
                    recalculateScrabbleOpponentsTiles();
                }
                
                renderScrabbleTable();
            };
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        
        function recalculateScrabbleOpponentsTiles() {
            console.log('=== RECALCULATING OPPONENTS TILES ===');
            
            // Calculate total unplayed tiles
            let totalUnplayed = 0;
            let playersWithNoTiles = [];
            
            players.forEach(player => {
                const unplayed = scrabbleScores[player.id]?.['unplayed'] || 0;
                console.log(`${player.name}: ${unplayed} unplayed tiles`);
                if (unplayed === 0) {
                    playersWithNoTiles.push(player);
                } else {
                    totalUnplayed += unplayed;
                }
            });
            
            console.log(`Total unplayed: ${totalUnplayed}`);
            console.log(`Players with no tiles: ${playersWithNoTiles.map(p => p.name).join(', ')}`);
            
            // Calculate points per player with no tiles
            let pointsPerPlayer = 0;
            if (playersWithNoTiles.length > 0) {
                pointsPerPlayer = Math.floor(totalUnplayed / playersWithNoTiles.length);
                console.log(`Points per player: ${totalUnplayed}  ${playersWithNoTiles.length} = ${pointsPerPlayer}`);
            }
            
            // Update opponents' tiles for all players
            players.forEach(player => {
                const unplayed = scrabbleScores[player.id]?.['unplayed'] || 0;
                if (unplayed === 0) {
                    // No unplayed tiles - collect from others
                    scrabbleScores[player.id]['opponents'] = pointsPerPlayer;
                    console.log(`${player.name}: opponents set to ${pointsPerPlayer}`);
                } else {
                    // Has unplayed tiles - don't collect
                    scrabbleScores[player.id]['opponents'] = 0;
                    console.log(`${player.name}: opponents set to 0`);
                }
            });
        }
        function addScoreToCurrentScrabbleTurn(playerId, points) {
            const turnIndex = currentScrabbleTurn[playerId];
            if (turnIndex >= SCRABBLE_TURNS.length) {
                console.log('All turns completed for player', playerId);
                return false;
            }
            
            const turn = SCRABBLE_TURNS[turnIndex];
            scrabbleScores[playerId][turn] = points;
            
            // Move to next turn
            currentScrabbleTurn[playerId] = turnIndex + 1;
            
            console.log(`Added ${points} for player ${playerId} in turn ${turn}`);
            renderScrabbleTableWithHighlight(playerId, turn);
            
            return true;
        }
        function renderScrabbleTableWithHighlight(playerId, turn) {
            renderScrabbleTable();
            
            setTimeout(() => {
                const cells = document.querySelectorAll('.crowns-score-highlight');
                cells.forEach(cell => {
                    cell.classList.remove('crowns-score-highlight');
                });
            }, 2000);
        }
        function addScrabbleRow() {
            // Cancel any voice operations when manually adding a row
            cancelAllVoiceOperations();
            
            // Increment the maximum turn number
            scrabbleMaxTurn++;
            const newTurn = scrabbleMaxTurn.toString();
            
            // Add the new turn to the SCRABBLE_TURNS array
            SCRABBLE_TURNS.push(newTurn);
            
            // Initialize scores for the new turn for all players
            players.forEach(player => {
                if (scrabbleScores[player.id]) {
                    scrabbleScores[player.id][newTurn] = 0;
                }
            });
            
            console.log(`Added turn ${newTurn} to Scrabble grid`);
            
            // Re-render the table
            renderScrabbleTable();
            
            // Show feedback
            speak(`Turn ${newTurn} added`);
            showVoiceFeedback(`Turn ${newTurn} added to grid`, '');
            setTimeout(hideVoiceFeedback, 1500);
        }
        // ===== SCRABBLE FINAL SCORING ADJUSTMENTS =====
        
        let scrabbleFinalPlayerIndex = 0;
        let scrabbleLeftoverTiles = {};
        let scrabbleIsCollectingTiles = false;
        let scrabbleProcessingResponse = false; // Prevent duplicate processing
        let scrabbleSpeaking = false; // Track when computer is speaking to prevent interruption
        
        function scrabbleFinalAdjustments() {
            if (players.length === 0) {
                customAlert('No players to adjust scores for!', ' No Players');
                return;
            }
            // Reset collection state FIRST
            scrabbleFinalPlayerIndex = 0;
            scrabbleLeftoverTiles = {};
            scrabbleIsCollectingTiles = true;
            scrabbleProcessingResponse = false;
            
            // Make sure recognition is running BEFORE speaking (allows interruption)
            if (!isListening && recognition) {
                try {
                    intentionallyStopped = false; // Clear flag before starting
                    isListening = true;
                    recognition.start();
                    updateVoiceButtonState();
                    console.log('Recognition started for Scrabble final adjustments');
                } catch (e) {
                    if (e.name === 'InvalidStateError') {
                        console.log('Recognition already running');
                        isListening = true;
                    } else {
                        console.error('Could not start recognition:', e);
                    }
                }
            }
            
            // Speak the intro (protected from interruption until complete)
            speak('Time for final scoring adjustments. I will ask each player for their unplayed tiles. You can say skip to enter manually.', true);
            
            // Start collecting for first player
            setTimeout(() => {
                askForUnplayedTiles();
            }, 5000); // 5 seconds - longer wait to ensure intro speech completes
        }
        
        function askForUnplayedTiles() {
            if (scrabbleFinalPlayerIndex >= players.length) {
                // All players done, calculate final scores
                finishScrabbleFinalAdjustments();
                return;
            }
            
            const player = players[scrabbleFinalPlayerIndex];
            
            // Reset processing flag for this player
            scrabbleProcessingResponse = false;
            
            // Make sure recognition is running
            if (!isListening && recognition) {
                try {
                    intentionallyStopped = false; // Clear flag before starting
                    isListening = true; // Set BEFORE starting
                    recognition.start();
                    updateVoiceButtonState();
                } catch (e) {
                    if (e.name !== 'InvalidStateError') {
                        console.error('Could not start recognition:', e);
                        isListening = false;
                    } else {
                        isListening = true; // Already running, set to true
                    }
                }
            }
            
            // Only mention "skip" option for the first player
            if (scrabbleFinalPlayerIndex === 0) {
                speak(`How many unplayed tiles for ${player.name}? Say a number, say skip, or click Manual Entry.`, true);
                showVoiceFeedback(
                    `Waiting for ${player.name}'s unplayed tiles...`, 
                    `<button onclick="manualEntryForUnplayedTiles()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, var(--neon-blue), #00c4cc); color: black; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">Manual Entry</button>`
                );
            } else {
                speak(`How many unplayed tiles for ${player.name}?`, true);
                showVoiceFeedback(
                    `Waiting for ${player.name}'s unplayed tiles...`, 
                    `<button onclick="manualEntryForUnplayedTiles()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, var(--neon-blue), #00c4cc); color: black; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">Manual Entry</button>`
                );
            }
        }
        
        function processUnplayedTilesResponse(transcript) {
            // Prevent duplicate processing from interim results
            if (scrabbleProcessingResponse) {
                console.log(' Already processing response, ignoring duplicate:', transcript);
                return;
            }
            
            console.log(' Processing unplayed tiles response:', transcript);
            
            const player = players[scrabbleFinalPlayerIndex];
            
            // Check for skip/manual command
            if (transcript.includes('skip') || transcript.includes('manual') || transcript.includes('enter')) {
                scrabbleProcessingResponse = true; // Mark as processing
                
                speak(`Skipping ${player.name}. You can enter their tiles manually.`, true);
                showVoiceFeedback(`Skipped ${player.name}`, 'Enter manually in grid');
                
                // Set to 0 as placeholder (can be edited manually)
                scrabbleLeftoverTiles[player.id] = 0;
                
                // Immediately update the grid to show 0 unplayed tiles
                scrabbleScores[player.id]['unplayed'] = 0;
                renderScrabbleTable();
                
                // Move to next player
                scrabbleFinalPlayerIndex++;
                
                setTimeout(() => {
                    scrabbleProcessingResponse = false; // Reset flag before moving on
                    if (scrabbleFinalPlayerIndex < players.length) {
                        askForUnplayedTiles();
                    } else {
                        hideVoiceFeedback();
                        finishScrabbleFinalAdjustments();
                    }
                }, 5000); // 5 seconds to ensure speech completes
                return;
            }
            
            // Convert transcript to number with improved recognition
            let points = convertWordToNumber(transcript);
            
            // Additional number patterns for better recognition
            if (points === null) {
                // Try parsing digits directly
                const digitMatch = transcript.match(/\d+/);
                if (digitMatch) {
                    points = parseInt(digitMatch[0]);
                }
            }
            
            // Check for common misrecognitions
            if (points === null) {
                const numberWords = {
                    'won': 1, 'to': 2, 'too': 2, 'for': 4, 'ate': 8,
                    'ate': 8, 'none': 0, 'no': 0, 'oh': 0
                };
                if (numberWords.hasOwnProperty(transcript)) {
                    points = numberWords[transcript];
                }
            }
            
            if (points !== null && points >= 0) {
                scrabbleProcessingResponse = true; // Mark as processing
                
                scrabbleLeftoverTiles[player.id] = points;
                
                // Immediately update the grid to show unplayed tiles
                scrabbleScores[player.id]['unplayed'] = points;
                renderScrabbleTable();
                
                console.log(` ${player.name}: ${points} unplayed tiles`);
                
                if (points === 0) {
                    speak(`${player.name}, zero unplayed tiles.`, true);
                } else {
                    speak(`${player.name}, ${points} ${points === 1 ? 'point' : 'points'} in unplayed tiles.`, true);
                }
                
                showVoiceFeedback(`${player.name}: ${points} unplayed tiles`, transcript);
                
                // Move to next player
                scrabbleFinalPlayerIndex++;
                
                setTimeout(() => {
                    scrabbleProcessingResponse = false; // Reset flag before moving on
                    if (scrabbleFinalPlayerIndex < players.length) {
                        askForUnplayedTiles();
                    } else {
                        hideVoiceFeedback();
                        finishScrabbleFinalAdjustments();
                    }
                }, 5000); // 5 seconds to ensure speech completes before next question
            } else {
                console.log(` Could not recognize number from: "${transcript}"`);
                
                // Don't keep repeating - just show the error once
                if (!scrabbleProcessingResponse) {
                    scrabbleProcessingResponse = true; // Prevent repeating
                    
                    speak('I did not understand that number. Please say the number again, or click Manual Entry.');
                    
                    // Show feedback with properly rendered button
                    const feedbackDiv = document.getElementById('voiceFeedback');
                    const feedbackText = document.getElementById('feedbackText');
                    const feedbackSubtext = document.getElementById('feedbackSubtext');
                    
                    if (feedbackDiv && feedbackText && feedbackSubtext) {
                        feedbackText.textContent = 'Number not recognized';
                        feedbackSubtext.innerHTML = `"${transcript}"<br><button onclick="manualEntryForUnplayedTiles()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, var(--neon-blue), #00c4cc); color: black; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">Manual Entry</button>`;
                        feedbackDiv.classList.add('active');
                    }
                    
                    // Reset processing flag after a delay to allow retry
                    setTimeout(() => {
                        scrabbleProcessingResponse = false;
                    }, 2000);
                }
            }
        }
        
        async function manualEntryForUnplayedTiles() {
            const player = players[scrabbleFinalPlayerIndex];
            
            // Cancel all voice operations when using manual entry
            cancelAllVoiceOperations();
            
            // Prompt for manual entry
            const input = await customPrompt(`${player.name}: How many points in unplayed tiles?`, '0', ' Unplayed tiles');
            
            if (input === null) {
                // User cancelled - ask again with voice
                askForUnplayedTiles();
                return;
            }
            
            const points = parseInt(input) || 0;
            
            // Mark as processing to prevent voice interference
            scrabbleProcessingResponse = true;
            
            // Store the value
            scrabbleLeftoverTiles[player.id] = points;
            
            // Immediately update the grid to show unplayed tiles
            scrabbleScores[player.id]['unplayed'] = points;
            renderScrabbleTable();
            
            console.log(`${player.name}: ${points} unplayed tiles (manual entry)`);
            
            // Provide feedback
            speak(`${player.name}, ${points} ${points === 1 ? 'point' : 'points'} in unplayed tiles.`);
            showVoiceFeedback(`${player.name}: ${points} unplayed tiles`, 'Manual entry');
            
            // Move to next player
            scrabbleFinalPlayerIndex++;
            
            setTimeout(() => {
                if (scrabbleFinalPlayerIndex < players.length) {
                    askForUnplayedTiles();
                } else {
                    hideVoiceFeedback();
                    finishScrabbleFinalAdjustments();
                }
            }, 2000); // Shorter wait since manual entry is deliberate
        }
        
        async function finishScrabbleFinalAdjustments() {
            scrabbleIsCollectingTiles = false;
            scrabbleProcessingResponse = false; // Reset flag
            scrabbleSpeaking = false; // Ensure speech flag is cleared
            
            console.log('=== FINISHING SCRABBLE FINAL ADJUSTMENTS ===');
            console.log('Leftover tiles collected:', scrabbleLeftoverTiles);
            console.log('Players:', players.map(p => p.name));
            
            // Calculate totals
            let totalLeftover = 0;
            let playersWithNoTiles = [];
            
            players.forEach(player => {
                const leftover = scrabbleLeftoverTiles[player.id] || 0;
                console.log(`${player.name} (ID: ${player.id}): ${leftover} unplayed tiles`);
                if (leftover === 0) {
                    playersWithNoTiles.push(player);
                    console.log(`   ${player.name} has NO tiles (will receive points)`);
                } else {
                    totalLeftover += leftover;
                    console.log(`   ${player.name} has ${leftover} tiles (will lose points)`);
                }
            });
            
            console.log('Total leftover points:', totalLeftover);
            console.log('Players with no tiles:', playersWithNoTiles.map(p => p.name));
            
            // Calculate points to distribute to players with no leftover tiles
            let pointsPerPlayer = 0;
            if (playersWithNoTiles.length > 0) {
                pointsPerPlayer = Math.floor(totalLeftover / playersWithNoTiles.length);
                console.log(`Points per player with no tiles: ${totalLeftover}  ${playersWithNoTiles.length} = ${pointsPerPlayer}`);
            } else {
                console.log('No players with zero tiles - no points to distribute');
            }
            
            // Apply adjustments
            players.forEach(player => {
                const leftover = scrabbleLeftoverTiles[player.id] || 0;
                
                if (leftover > 0) {
                    // Deduct leftover tiles
                    scrabbleScores[player.id]['unplayed'] = leftover;
                    scrabbleScores[player.id]['opponents'] = 0;
                    console.log(`${player.name}: SET unplayed=${leftover}, opponents=0`);
                } else {
                    // No leftover - collect points from others
                    scrabbleScores[player.id]['unplayed'] = 0;
                    scrabbleScores[player.id]['opponents'] = pointsPerPlayer;
                    console.log(`${player.name}: SET unplayed=0, opponents=${pointsPerPlayer}`);
                }
            });
            
            console.log('Final scrabbleScores:', scrabbleScores);
            
            // Re-render the table
            renderScrabbleTable();
            
            // Calculate final scores with pre-adjustment scores for tiebreaker
            let finalScores = players.map(player => {
                let preAdjustmentTotal = 0;
                SCRABBLE_TURNS.forEach(turn => {
                    preAdjustmentTotal += scrabbleScores[player.id]?.[turn] || 0;
                });
                
                const unplayed = scrabbleScores[player.id]?.['unplayed'] || 0;
                const opponents = scrabbleScores[player.id]?.['opponents'] || 0;
                const finalTotal = preAdjustmentTotal - unplayed + opponents;
                
                console.log(`${player.name} final: ${preAdjustmentTotal} turns - ${unplayed} unplayed + ${opponents} opponents = ${finalTotal}`);
                
                return { 
                    player, 
                    total: finalTotal,
                    preAdjustmentTotal: preAdjustmentTotal  // Store for tiebreaker
                };
            });
            
            // Sort by final score, with tiebreaker using pre-adjustment score
            finalScores.sort((a, b) => {
                if (b.total !== a.total) {
                    return b.total - a.total;  // Primary: highest final score
                } else {
                    return b.preAdjustmentTotal - a.preAdjustmentTotal;  // Tiebreaker: highest pre-adjustment score
                }
            });
            
            // Check if winner was determined by tiebreaker
            const winner = finalScores[0];
            const topScore = winner.total;
            const playersWithTopScore = finalScores.filter(item => item.total === topScore);
            const wonByTiebreaker = playersWithTopScore.length > 1 && 
                                   playersWithTopScore[0].preAdjustmentTotal !== playersWithTopScore[1].preAdjustmentTotal;
            
            // Show results with universal completion system
            const formattedScores = finalScores.map(item => ({
                name: item.player.name,
                total: item.total,
                player: item.player
            }));
            
            const winnerData = {
                name: winner.player.name,
                player: winner.player,
                total: winner.total
            };
            
            await handleUniversalGameCompletion('scrabble', winnerData, formattedScores);
            
            // Create proper Supreme Champion announcement with all scores
            const winnerText = wonByTiebreaker 
                ? `${winner.player.name} is the Supreme Champion with ${winner.total} points on a tiebreaker!`
                : `${winner.player.name} is the Supreme Champion with ${winner.total} points!`;
            
            // Get other players' scores (excluding winner)
            const otherPlayers = finalScores.filter(score => score.player.id !== winner.player.id);
            let voiceAnnouncement = `Game over! Winner: ${winnerText}`;
            
            if (otherPlayers.length > 0) {
                const otherScores = otherPlayers.map(score => 
                    `${score.player.name}: ${score.total} ${score.total === 1 ? 'point' : 'points'}`
                ).join(', ');
                voiceAnnouncement += `. Other scores: ${otherScores}`;
            }
            
            speak(voiceAnnouncement, true);
            
            // Update walls with all player scores (higher is better in Scrabble)
            finalScores.forEach(item => {
                updateWalls('Scrabble', item.player.name, item.total, false);
            });
            
            console.log('Updated walls with Scrabble scores');
        }
        function hideVoiceFeedback() {
            setTimeout(() => {
                document.getElementById('voiceFeedback').classList.remove('show');
            }, 300);
        }
        // ===== YAHTZEE GRID FUNCTIONS =====
        
        function initializeYahtzeeScores() {
            // Only initialize if yahtzeeScores doesn't exist
            if (!yahtzeeScores) {
                yahtzeeScores = {};
            }
            if (!yahtzeeUsedCategories) {
                yahtzeeUsedCategories = {};
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!yahtzeeScores[player.id]) {
                    yahtzeeScores[player.id] = {
                        // Upper Section
                        ones: 0,
                        twos: 0,
                        threes: 0,
                        fours: 0,
                        fives: 0,
                        sixes: 0,
                        upperTotal: 0,
                        upperBonus: 0,
                        // Lower Section
                        threeKind: 0,
                        fourKind: 0,
                        fullHouse: 0,
                        smStraight: 0,
                        lgStraight: 0,
                        yahtzee: 0,
                        chance: 0,
                        yahtzeeBonus: 0 // For additional Yahtzees
                    };
                }
                // Initialize used categories tracker
                if (!yahtzeeUsedCategories[player.id]) {
                    yahtzeeUsedCategories[player.id] = {};
                }
            });
            
            console.log('Initialized Yahtzee scores:', yahtzeeScores);
        }
        function renderYahtzeeTable() {
            console.log('=== RENDER YAHTZEE TABLE ===');
            console.log('Players:', players.length);
            console.log('yahtzeeScores:', JSON.stringify(yahtzeeScores, null, 2));
            
            if (players.length === 0) {
                document.getElementById('yahtzeeTable').innerHTML = '<tr><td style="padding: 15px 20px 20px 20px; text-align: left; color: var(--text-dim); line-height: 1.5; font-size: 0.9em;"><strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>1. Choose the game you want to play.<br>2. Add Player names.<br>3. Say \"Done Adding\" or Click the \"Done adding Player Names\" button, and the game will start.</td></tr>';
                return;
            }
            let html = '<thead><tr><th class="crowns-hole-label" style="min-width: 120px;">CATEGORY</th>';
            
            // Player headers
            players.forEach(player => {
                html += `<th class="crowns-player-header">
                    <div style="cursor: pointer;" onclick="editYahtzeePlayerName(${player.id})">${player.name}</div>
                </th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // UPPER SECTION
            html += '<tr class="section-divider"><td colspan="' + (players.length + 1) + '" style="background: var(--neon-blue); color: black; font-weight: 800; text-align: center; padding: 8px;">UPPER SECTION</td></tr>';
            
            const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
            const upperNames = ['Aces (1s)', 'Twos (2s)', 'Threes (3s)', 'Fours (4s)', 'Fives (5s)', 'Sixes (6s)'];
            
            upperCategories.forEach((cat, idx) => {
                html += `<tr><td class="crowns-hole-label">${upperNames[idx]}</td>`;
                players.forEach(player => {
                    const score = yahtzeeScores[player.id][cat] || 0;
                    const used = yahtzeeUsedCategories[player.id][cat];
                    const cellClass = used ? 'yahtzee-used' : 'yahtzee-available';
                    html += `<td class="${cellClass}" onclick="enterYahtzeeScore(${player.id}, '${cat}')" style="cursor: pointer;">${score > 0 ? score : (used ? '0' : '-')}</td>`;
                });
                html += '</tr>';
            });
            
            // Upper section total
            html += '<tr style="background: rgba(0, 245, 255, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">TOTAL</td>';
            players.forEach(player => {
                const total = (yahtzeeScores[player.id].ones || 0) + 
                             (yahtzeeScores[player.id].twos || 0) + 
                             (yahtzeeScores[player.id].threes || 0) + 
                             (yahtzeeScores[player.id].fours || 0) + 
                             (yahtzeeScores[player.id].fives || 0) + 
                             (yahtzeeScores[player.id].sixes || 0);
                html += `<td style="font-weight: 700;">${total}</td>`;
            });
            html += '</tr>';
            
            // Bonus (35 points if total >= 63)
            html += '<tr style="background: rgba(255, 215, 0, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">BONUS 35 (if 63)</td>';
            players.forEach(player => {
                const total = (yahtzeeScores[player.id].ones || 0) + 
                             (yahtzeeScores[player.id].twos || 0) + 
                             (yahtzeeScores[player.id].threes || 0) + 
                             (yahtzeeScores[player.id].fours || 0) + 
                             (yahtzeeScores[player.id].fives || 0) + 
                             (yahtzeeScores[player.id].sixes || 0);
                const bonus = total >= 63 ? 35 : 0;
                yahtzeeScores[player.id].upperBonus = bonus;
                html += `<td style="font-weight: 700; color: ${bonus > 0 ? '#28a745' : 'inherit'};">${bonus > 0 ? '+35' : '-'}</td>`;
            });
            html += '</tr>';
            
            // LOWER SECTION
            html += '<tr class="section-divider"><td colspan="' + (players.length + 1) + '" style="background: var(--neon-pink); color: black; font-weight: 800; text-align: center; padding: 8px;">LOWER SECTION</td></tr>';
            
            const lowerCategories = [
                { key: 'threeKind', name: '3 of a Kind', desc: 'Total of all dice' },
                { key: 'fourKind', name: '4 of a Kind', desc: 'Total of all dice' },
                { key: 'fullHouse', name: 'Full House', desc: '25 points' },
                { key: 'smStraight', name: 'Small Straight', desc: '30 points' },
                { key: 'lgStraight', name: 'Large Straight', desc: '40 points' },
                { key: 'yahtzee', name: 'YAHTZEE', desc: '50 points' },
                { key: 'chance', name: 'Chance', desc: 'Total of all dice' }
            ];
            
            lowerCategories.forEach(cat => {
                html += `<tr><td class="crowns-hole-label">${cat.name}<br><span style="font-size: 0.7em; opacity: 0.7;">${cat.desc}</span></td>`;
                players.forEach(player => {
                    const score = yahtzeeScores[player.id][cat.key] || 0;
                    const used = yahtzeeUsedCategories[player.id][cat.key];
                    const cellClass = used ? 'yahtzee-used' : 'yahtzee-available';
                    html += `<td class="${cellClass}" onclick="enterYahtzeeScore(${player.id}, '${cat.key}')" style="cursor: pointer;">${score > 0 ? score : (used ? '0' : '-')}</td>`;
                });
                html += '</tr>';
            });
            
            // Yahtzee Bonus
            html += '<tr style="background: rgba(255, 215, 0, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">Yahtzee Bonus<br><span style="font-size: 0.7em; opacity: 0.7;">100 per extra</span></td>';
            players.forEach(player => {
                const bonus = yahtzeeScores[player.id].yahtzeeBonus || 0;
                html += `<td style="font-weight: 700; color: ${bonus > 0 ? '#28a745' : 'inherit'};">${bonus > 0 ? bonus : '-'}</td>`;
            });
            html += '</tr>';
            
            // Lower section total
            html += '<tr style="background: rgba(0, 245, 255, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">LOWER TOTAL</td>';
            players.forEach(player => {
                const total = (yahtzeeScores[player.id].threeKind || 0) + 
                             (yahtzeeScores[player.id].fourKind || 0) + 
                             (yahtzeeScores[player.id].fullHouse || 0) + 
                             (yahtzeeScores[player.id].smStraight || 0) + 
                             (yahtzeeScores[player.id].lgStraight || 0) + 
                             (yahtzeeScores[player.id].yahtzee || 0) + 
                             (yahtzeeScores[player.id].chance || 0) + 
                             (yahtzeeScores[player.id].yahtzeeBonus || 0);
                html += `<td style="font-weight: 700;">${total}</td>`;
            });
            html += '</tr>';
            
            // GRAND TOTAL
            html += '<tr style="background: rgba(255, 0, 110, 0.2);"><td class="crowns-hole-label" style="font-weight: 800; font-size: 1.1em;">GRAND TOTAL</td>';
            players.forEach(player => {
                const upperTotal = (yahtzeeScores[player.id].ones || 0) + 
                                  (yahtzeeScores[player.id].twos || 0) + 
                                  (yahtzeeScores[player.id].threes || 0) + 
                                  (yahtzeeScores[player.id].fours || 0) + 
                                  (yahtzeeScores[player.id].fives || 0) + 
                                  (yahtzeeScores[player.id].sixes || 0) +
                                  (yahtzeeScores[player.id].upperBonus || 0);
                const lowerTotal = (yahtzeeScores[player.id].threeKind || 0) + 
                                  (yahtzeeScores[player.id].fourKind || 0) + 
                                  (yahtzeeScores[player.id].fullHouse || 0) + 
                                  (yahtzeeScores[player.id].smStraight || 0) + 
                                  (yahtzeeScores[player.id].lgStraight || 0) + 
                                  (yahtzeeScores[player.id].yahtzee || 0) + 
                                  (yahtzeeScores[player.id].chance || 0) + 
                                  (yahtzeeScores[player.id].yahtzeeBonus || 0);
                const grandTotal = upperTotal + lowerTotal;
                player.score = grandTotal; // Update player's main score
                html += `<td style="font-weight: 800; font-size: 1.1em; color: var(--neon-blue);">${grandTotal}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('yahtzeeTable').innerHTML = html;
            savePlayers(); // Save updated totals
        }
        async function enterYahtzeeScore(playerId, category) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            // Allow overwriting scores - remove the used category check
            // if (yahtzeeUsedCategories[playerId][category]) {
            //     customAlert(`${category} has already been used for ${player.name}!`, ' Category Used');
            //     return;
            // }
            
            const cell = event.target;
            const currentScore = yahtzeeScores[playerId][category] || 0;
            const categoryInfo = YAHTZEE_CATEGORIES[category];
            
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="yahtzee-input-${playerId}-${category}" inputmode="numeric">`;
            
            const input = document.getElementById(`yahtzee-input-${playerId}-${category}`);
            input.focus();
            input.select();
            
            const saveScore = () => {
                const score = parseInt(input.value);
                
                if (isNaN(score) || score < 0) {
                    customAlert('Please enter a valid score (0 or greater)', ' Invalid Score');
                    renderYahtzeeTable();
                    return;
                }
                
                // Save state for undo
                saveStateForUndo(`${player.name} - ${categoryInfo.name}: ${score}`);
                
                // Set the score
                yahtzeeScores[playerId][category] = score;
                yahtzeeUsedCategories[playerId][category] = true;
                
                // Check for Yahtzee bonus (if scoring additional yahtzees)
                if (category === 'yahtzee' && score === 50 && yahtzeeUsedCategories[playerId].yahtzee && yahtzeeScores[playerId].yahtzee > 0) {
                    yahtzeeScores[playerId].yahtzeeBonus = (yahtzeeScores[playerId].yahtzeeBonus || 0) + 100;
                    speak(`Yahtzee bonus! ${player.name} gets 100 extra points!`);
                }
                
                saveYahtzeeData();
                renderYahtzeeTable();
                
                // No voice feedback for manual input
            };
            
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editYahtzeePlayerName(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const currentName = player.name;
            const cell = event.target;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete yahtzeeScores[playerId];
                        delete yahtzeeUsedCategories[playerId];
                        savePlayers();
                    }
                    renderYahtzeeTable();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderYahtzeeTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function saveYahtzeeData() {
            localStorage.setItem('scorekeeper_yahtzee_scores', JSON.stringify(yahtzeeScores));
            localStorage.setItem('scorekeeper_yahtzee_used', JSON.stringify(yahtzeeUsedCategories));
        }
        function loadYahtzeeData() {
            const savedScores = localStorage.getItem('scorekeeper_yahtzee_scores');
            const savedUsed = localStorage.getItem('scorekeeper_yahtzee_used');
            
            if (savedScores) {
                yahtzeeScores = JSON.parse(savedScores);
            }
            if (savedUsed) {
                yahtzeeUsedCategories = JSON.parse(savedUsed);
            }
        }
        // ===== PHASE 10 GRID FUNCTIONS =====
        
        function initializePhase10Scores() {
            if (!phase10Scores) {
                phase10Scores = {};
            }
            if (!phase10Completed) {
                phase10Completed = {};
            }
            
            players.forEach(player => {
                if (!phase10Scores[player.id]) {
                    phase10Scores[player.id] = {};
                    PHASE10_PHASES.forEach(phase => {
                        phase10Scores[player.id][phase.num] = 0;
                    });
                }
                if (!phase10Completed[player.id]) {
                    phase10Completed[player.id] = {};
                }
            });
            
            console.log('Initialized Phase 10 scores:', phase10Scores);
        }
        function renderPhase10Table() {
            console.log('=== RENDER PHASE 10 TABLE ===');
            console.log('Players:', players.length);
            
            if (players.length === 0) {
                document.getElementById('phase10Table').innerHTML = '<tr><td style="padding: 15px 20px 20px 20px; text-align: left; color: var(--text-dim); line-height: 1.5; font-size: 0.9em;"><strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>1. Choose the game you want to play.<br>2. Add Player names.<br>3. Say \"Done Adding\" or Click the \"Done adding Player Names\" button, and the game will start.</td></tr>';
                return;
            }
            let html = '<thead><tr><th class="crowns-hole-label" style="min-width: 140px;">PHASE</th>';
            
            players.forEach(player => {
                html += `<th class="crowns-player-header">
                    <div style="cursor: pointer;" onclick="editPhase10PlayerName(${player.id})">${player.name}</div>
                </th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            PHASE10_PHASES.forEach(phase => {
                html += `<tr>`;
                html += `<td class="crowns-hole-label"><strong>Phase ${phase.num}</strong><br><span style="font-size: 0.7em; opacity: 0.7;">${phase.name}</span></td>`;
                
                players.forEach(player => {
                    const score = phase10Scores[player.id][phase.num] || 0;
                    const completed = phase10Completed[player.id][phase.num];
                    const cellStyle = completed ? 'background: rgba(0, 245, 255, 0.2); font-weight: 700;' : '';
                    const displayScore = completed ? ` ${score}` : score;
                    html += `<td style="cursor: pointer; ${cellStyle}" onclick="enterPhase10Score(${player.id}, ${phase.num})">${displayScore > 0 || completed ? displayScore : '-'}</td>`;
                });
                
                html += '</tr>';
            });
            
            // Total row
            html += '<tr style="border-top: 2px solid var(--neon-blue); background: rgba(255, 0, 110, 0.2);"><td class="crowns-hole-label" style="font-weight: 800; font-size: 1.1em;">TOTAL</td>';
            players.forEach(player => {
                let total = 0;
                PHASE10_PHASES.forEach(phase => {
                    total += phase10Scores[player.id][phase.num] || 0;
                });
                player.score = total;
                html += `<td style="font-weight: 800; font-size: 1.1em; color: var(--neon-pink);">${total}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('phase10Table').innerHTML = html;
            savePlayers();
        }
        async function enterPhase10Score(playerId, phaseNum) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const cell = event.target;
            const currentScore = phase10Scores[playerId][phaseNum] || 0;
            const isCompleted = phase10Completed[playerId][phaseNum];
            
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="phase10-input-${playerId}-${phaseNum}" inputmode="numeric">`;
            
            const input = document.getElementById(`phase10-input-${playerId}-${phaseNum}`);
            input.focus();
            input.select();
            
            const saveScore = () => {
                const score = parseInt(input.value);
                
                if (isNaN(score) || score < 0) {
                    customAlert('Please enter a valid score (0 or greater)', ' Invalid Score');
                    renderPhase10Table();
                    return;
                }
                
                saveStateForUndo(`${player.name} - Phase ${phaseNum}: ${score}`);
                
                phase10Scores[playerId][phaseNum] = score;
                // Mark as completed if score is 0 (phase was completed)
                if (score === 0) {
                    phase10Completed[playerId][phaseNum] = true;
                }
                
                savePhase10Data();
                renderPhase10Table();
                
                // No voice feedback for manual input
            };
            
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editPhase10PlayerName(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const currentName = player.name;
            const cell = event.target;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete phase10Scores[playerId];
                        delete phase10Completed[playerId];
                        savePlayers();
                    }
                    renderPhase10Table();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderPhase10Table();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function savePhase10Data() {
            localStorage.setItem('scorekeeper_phase10_scores', JSON.stringify(phase10Scores));
            localStorage.setItem('scorekeeper_phase10_completed', JSON.stringify(phase10Completed));
        }
        function loadPhase10Data() {
            const savedScores = localStorage.getItem('scorekeeper_phase10_scores');
            const savedCompleted = localStorage.getItem('scorekeeper_phase10_completed');
            
            if (savedScores) {
                phase10Scores = JSON.parse(savedScores);
            }
            if (savedCompleted) {
                phase10Completed = JSON.parse(savedCompleted);
            }
        }
        // ===== GENERIC GRID FUNCTIONS (for General/Darts/Farkle) =====
        
        function initializeGenericGridScores() {
            // Only initialize if genericGridScores doesn't exist
            if (!genericGridScores) {
                genericGridScores = {};
            }
            if (!currentGenericTurn) {
                currentGenericTurn = {};
            }
            
            // Only reset turns if we're starting fresh (no existing scores)
            if (Object.keys(genericGridScores).length === 0) {
                GENERIC_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
                genericMaxTurn = 12;
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!genericGridScores[player.id]) {
                    genericGridScores[player.id] = {};
                    GENERIC_TURNS.forEach(turn => {
                        genericGridScores[player.id][turn] = 0;
                    });
                }
                // Initialize current turn tracker for new players
                if (currentGenericTurn[player.id] === undefined) {
                    currentGenericTurn[player.id] = 0; // Start at turn 1 (index 0)
                }
            });
            
            console.log('Initialized Generic Grid scores:', genericGridScores);
        }
        function renderGenericGridTable() {
            const buttonContainer = document.getElementById('genericGridButtons');
            
            console.log('=== RENDER GENERIC GRID TABLE ===');
            console.log('Players:', players.length);
            console.log('genericGridScores:', JSON.stringify(genericGridScores, null, 2));
            
            if (players.length === 0) {
                document.getElementById('genericGridTable').innerHTML = '<tr><td style="padding: 15px 20px 20px 20px; text-align: left; color: var(--text-dim); line-height: 1.5; font-size: 0.9em;"><strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>To use voice recognition, go to Settings and enable the microphone for the Safari browser.<br><br>1. Choose the game you want to play.<br>2. Add Player names.<br>3. Say \"Done Adding\" or Click the \"Done adding Player Names\" button, and the game will start.</td></tr>';
                // Hide buttons when no players
                if (buttonContainer) buttonContainer.style.display = 'none';
                return;
            }
            // Show buttons when players exist
            if (buttonContainer) buttonContainer.style.display = 'flex';
            let html = '<thead><tr><th class="crowns-hole-label">TURN</th>';
            
            // Player headers - clickable to edit names
            players.forEach(player => {
                html += `<th class="crowns-player-header">
                    <div style="cursor: pointer;" onclick="editGenericGridPlayerName(${player.id})">${player.name}</div>
                </th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // Turn rows
            GENERIC_TURNS.forEach((turn, index) => {
                const isHighlighted = highlightedGenericTurn === turn ? ' highlighted' : '';
                html += `<tr>`;
                html += `<td class="crowns-hole-label${isHighlighted}" onclick="toggleGenericTurnHighlight('${turn}')" style="cursor: pointer;">${turn}</td>`;
                
                players.forEach(player => {
                    const score = genericGridScores[player.id][turn] || 0;
                    const isCurrentTurn = currentGenericTurn[player.id] === index;
                    const cellClass = isCurrentTurn ? 'current-turn-cell' : '';
                    html += `<td class="${cellClass}" onclick="editGenericGridScore(${player.id}, '${turn}')" style="cursor: pointer;">${score}</td>`;
                });
                
                html += '</tr>';
            });
            
            // Total row
            html += '<tr style="border-top: 2px solid var(--neon-blue); background: rgba(0, 245, 255, 0.1);"><td class="crowns-hole-label" style="font-weight: 800;">TOTAL</td>';
            players.forEach(player => {
                let total = 0;
                GENERIC_TURNS.forEach(turn => {
                    total += genericGridScores[player.id][turn] || 0;
                });
                player.score = total; // Update player's main score
                html += `<td style="font-weight: 800;">${total}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('genericGridTable').innerHTML = html;
            savePlayers(); // Save updated totals
        }
        
        function toggleGenericTurnHighlight(turn) {
            console.log('=== toggleGenericTurnHighlight called ===');
            console.log('Turn clicked:', turn);
            console.log('Current highlightedGenericTurn:', highlightedGenericTurn);
            
            // Toggle the highlight - if already highlighted, unhighlight it
            if (highlightedGenericTurn === turn) {
                highlightedGenericTurn = null;
                console.log('Unhighlighting - set to null');
            } else {
                highlightedGenericTurn = turn;
                console.log('Highlighting - set to:', turn);
            }
            
            console.log('About to re-render Generic Grid table');
            renderGenericGridTable();
            console.log('Generic Grid table re-rendered');
        }
        
        function addGenericRow() {
            // Add a new turn
            genericMaxTurn++;
            GENERIC_TURNS.push(genericMaxTurn.toString());
            
            // Initialize the new turn for all players
            players.forEach(player => {
                if (genericGridScores[player.id]) {
                    genericGridScores[player.id][genericMaxTurn.toString()] = 0;
                }
            });
            
            saveGenericGridData();
            renderGenericGridTable();
            
            speak(`Added turn ${genericMaxTurn}`);
            showVoiceFeedback(`Turn ${genericMaxTurn} added`, '');
            setTimeout(hideVoiceFeedback, 1500);
        }
        async function editGenericGridScore(playerId, turn) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const cell = event.target;
            const currentScore = genericGridScores[playerId][turn] || 0;
            
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="generic-input-${playerId}-${turn}" inputmode="numeric">`;
            
            const input = document.getElementById(`generic-input-${playerId}-${turn}`);
            input.focus();
            input.select();
            
            const saveScore = () => {
                const score = parseInt(input.value);
                
                if (isNaN(score)) {
                    customAlert('Please enter a valid number', ' Invalid Score');
                    renderGenericGridTable();
                    return;
                }
                
                // Save state for undo
                saveStateForUndo(`${player.name} - Turn ${turn}: ${score}`);
                
                genericGridScores[playerId][turn] = score;
                
                saveGenericGridData();
                renderGenericGridTable();
                
                // No voice feedback for manual input
            };
            
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editGenericGridPlayerName(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const currentName = player.name;
            const cell = event.target;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete genericGridScores[playerId];
                        delete currentGenericTurn[playerId];
                        savePlayers();
                    }
                    renderGenericGridTable();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderGenericGridTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function addScoreToCurrentGenericTurn(playerId, points) {
            const player = players.find(p => p.id === playerId);
            if (!player) return false;
            // Get current turn index for this player
            let turnIndex = currentGenericTurn[playerId] || 0;
            
            // If we're past the last turn, don't add
            if (turnIndex >= GENERIC_TURNS.length) {
                speak('All turns complete for ' + player.name);
                showVoiceFeedback(`All turns complete for ${player.name}`, '');
                setTimeout(hideVoiceFeedback, 2000);
                return false;
            }
            const turn = GENERIC_TURNS[turnIndex];
            
            // Add score to current turn
            genericGridScores[playerId][turn] = points;
            saveGenericGridData();
            
            // Move to next turn
            currentGenericTurn[playerId] = turnIndex + 1;
            localStorage.setItem('scorekeeper_current_generic_turn', JSON.stringify(currentGenericTurn));
            
            // Provide feedback
            speak(`${points} points for ${player.name} in turn ${turn}`);
            showVoiceFeedback(`${player.name}: ${points} pts (Turn ${turn})`, '');
            setTimeout(hideVoiceFeedback, 1500);
            
            // Re-render table with highlight
            renderGenericGridTableWithHighlight(playerId, turn);
            return true;
        }
        function renderGenericGridTableWithHighlight(playerId, turn) {
            renderGenericGridTable();
            
            // Highlight the updated cell
            setTimeout(() => {
                const table = document.getElementById('genericGridTable');
                const headers = table.querySelectorAll('th.crowns-player-header');
                
                let playerColumnIndex = -1;
                headers.forEach((header, index) => {
                    const player = players[index];
                    if (player && player.id === playerId) {
                        playerColumnIndex = index + 1; // +1 because first column is turn labels
                    }
                });
                
                if (playerColumnIndex !== -1) {
                    const turnIndex = GENERIC_TURNS.indexOf(turn);
                    if (turnIndex !== -1) {
                        const rows = table.querySelectorAll('tbody tr');
                        const targetRow = rows[turnIndex];
                        if (targetRow) {
                            const cells = targetRow.querySelectorAll('td');
                            const targetCell = cells[playerColumnIndex];
                            if (targetCell) {
                                targetCell.style.animation = 'highlightCell 1s ease';
                                setTimeout(() => {
                                    targetCell.style.animation = '';
                                }, 1000);
                            }
                        }
                    }
                }
            }, 50);
        }
        function saveGenericGridData() {
            localStorage.setItem('scorekeeper_generic_grid_scores', JSON.stringify(genericGridScores));
            localStorage.setItem('scorekeeper_current_generic_turn', JSON.stringify(currentGenericTurn));
            localStorage.setItem('scorekeeper_generic_turns', JSON.stringify(GENERIC_TURNS));
            localStorage.setItem('scorekeeper_generic_max_turn', genericMaxTurn.toString());
        }
        function loadGenericGridData() {
            const savedScores = localStorage.getItem('scorekeeper_generic_grid_scores');
            const savedTurn = localStorage.getItem('scorekeeper_current_generic_turn');
            const savedTurns = localStorage.getItem('scorekeeper_generic_turns');
            const savedMaxTurn = localStorage.getItem('scorekeeper_generic_max_turn');
            
            if (savedScores) {
                genericGridScores = JSON.parse(savedScores);
            }
            if (savedTurn) {
                currentGenericTurn = JSON.parse(savedTurn);
            }
            if (savedTurns) {
                GENERIC_TURNS = JSON.parse(savedTurns);
            }
            if (savedMaxTurn) {
                genericMaxTurn = parseInt(savedMaxTurn);
            }
        }
        // ===== TEXT PREPROCESSING FOR VOICE RECOGNITION =====
        function preprocessTranscript(transcript) {
            let processed = transcript.toLowerCase().trim();
            
            console.log('Original transcript:', transcript);
            
            // Fix common misrecognitions
            // "Had" at the start is almost always "Add"
            if (processed.startsWith('had ')) {
                processed = 'add ' + processed.substring(4);
                console.log('Corrected "had" to "add"');
            }
            
            // "At" at the start is almost always "Add"
            if (processed.startsWith('at ')) {
                processed = 'add ' + processed.substring(3);
                console.log('Corrected "at" to "add"');
            }
            
            // Fix "twenty four" when it should be "twenty for"
            // "20 for Steven" often misheard as "24 Steven" or "twenty four Steven"
            // Pattern: [number ending in 0-9] + "four" + [name]  [number] + "for" + [name]
            processed = processed.replace(/\b(ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred)\s+four\s+/gi, '$1 for ');
            processed = processed.replace(/\b(\d+)\s*four\s+/gi, '$1 for ');
            processed = processed.replace(/\b(10|11|12|13|14|15|16|17|18|19|20|30|40|50|60|70|80|90|100)\s*4\s+/gi, '$1 for ');
            console.log('After "four"  "for" correction:', processed);
            
            // Replace "had" with "add" throughout
            processed = processed.replace(/\bhad\b/gi, 'add');
            
            // Replace "at" with "add" when followed by a name (for adding players)
            // "at Guy"  "add Guy"
            // "at Emma and Jonathan"  "add Emma and Jonathan"
            processed = processed.replace(/\bat\s+([A-Z])/gi, 'add $1');
            
            // Improve "done" detection - common misrecognitions
            processed = processed.replace(/\bdon\b/gi, 'done');
            processed = processed.replace(/\bdun\b/gi, 'done');
            processed = processed.replace(/\bdum\b/gi, 'done');
            processed = processed.replace(/\bdone\b/gi, 'done');
            
            // FIX NUMBER MISINTERPRETATIONS AT END OF SCORING COMMANDS
            // These only apply when they appear at the end after a name
            // "give Ellen too"  "give Ellen 2"
            // "Jonathan for"  "Jonathan 4"
            // "Emma to"  "Emma 2"
            // "Guy fore"  "Guy 4"
            
            // Pattern: [name] + [misheard number word at end]
            // Match "too", "to", "two" at end  2
            processed = processed.replace(/\b(too|to|two)$/i, '2');
            
            // Match "for", "fore", "four" at end  4
            processed = processed.replace(/\b(for|fore|four)$/i, '4');
            
            // Also handle in "give [name] [number]" pattern
            processed = processed.replace(/\bgive\s+(\w+)\s+(too|to|two)$/i, 'give $1 2');
            processed = processed.replace(/\bgive\s+(\w+)\s+(for|fore|four)$/i, 'give $1 4');
            
            // Handle in "[number] for [name]" - but preserve legitimate "for"
            // Only if "for" is at position where number should be
            // "to for Emma"  "2 for Emma" (to  2, keep "for")
            processed = processed.replace(/^(too|to|two)\s+for\s+/i, '2 for ');
            
            // More comprehensive number word corrections at end of commands
            processed = processed.replace(/\b(won|one)$/i, '1');
            processed = processed.replace(/\b(tree|free|three)$/i, '3');
            processed = processed.replace(/\b(fife|five)$/i, '5');
            processed = processed.replace(/\b(sex|six)$/i, '6');
            processed = processed.replace(/\b(ate|eight)$/i, '8');
            processed = processed.replace(/\b(mine|nine)$/i, '9');
            
            console.log('After number corrections:', processed);
            
            // FIX GUY NAME RECOGNITION - catch all variations
            // "give me 7"  "give guy 7"
            // "give d7"  "give guy 7"
            // "give g7"  "give guy 7"
            // Common patterns where Guy is misheard
            processed = processed.replace(/\bgive\s+me\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+d\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+g\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+ghee\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+gee\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+key\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+ge\b/gi, 'give guy');
            
            // Handle patterns like "d7", "g7", "d 7", "g 7"
            processed = processed.replace(/\b([dg])\s*(\d+)\b/gi, 'guy $2');
            
            // Handle standalone variations at word boundaries
            processed = processed.replace(/\bghee\b/gi, 'guy');
            processed = processed.replace(/\bgee\b/gi, 'guy');
            processed = processed.replace(/\bkey\b/gi, 'guy');
            processed = processed.replace(/\bge\b/gi, 'guy');
            
            // Handle "for" patterns: "5 for me"  "5 for guy"
            processed = processed.replace(/\bfor\s+me\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+d\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+g\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+ghee\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+gee\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+key\b/gi, 'for guy');
            
            // Handle "change/update" patterns
            processed = processed.replace(/\b(change|update)\s+me\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+d\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+g\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+ghee\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+gee\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+key\b/gi, '$1 guy');
            
            // Handle at start of command: "me 5"  "guy 5", "d 5"  "guy 5"
            if (processed.match(/^(me|d|g|ghee|gee|key|ge)\s+\d+/i)) {
                processed = processed.replace(/^(me|d|g|ghee|gee|key|ge)\s+/i, 'guy ');
                console.log('Corrected name at start to "guy"');
            }
            
            // Sometimes "done" is heard at the end with extra words
            if (processed.includes('done')) {
                console.log('DONE word detected in transcript');
            }
            
            console.log('Preprocessed transcript:', processed);
            return processed;
        }
        function parseMultipleScores(transcript) {
            // Parse multiple score entries from a single transcript
            // Supports formats like:
            // "Guy 20 Jonathan 5 Jeff 75"
            // "Give Guy 20 Give Jonathan 5 Jeff 75"
            // "20 for Guy 5 for Jonathan 75 for Jeff"
            // "Guy gets 20 Jonathan gets 5"
            
            const scores = [];
            
            // Clean up the transcript - remove filler words
            let cleaned = transcript.toLowerCase();
            cleaned = cleaned.replace(/\b(give|gets?|scored?|points?|for)\b/g, ' ');
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            
            // Pattern 1: "name number name number" - most common
            // Look for patterns: word(s) followed by number
            const pattern1 = /([a-z]+(?:\s+[a-z]+)?)\s+(\d+)/gi;
            let matches = [...cleaned.matchAll(pattern1)];
            
            if (matches.length > 0) {
                matches.forEach(match => {
                    const name = match[1].trim();
                    const points = parseInt(match[2]);
                    
                    // Validate it's not a weird match
                    if (name.length > 0 && name.length < 30 && points >= 0 && points <= 9999) {
                        scores.push({ name, points });
                    }
                });
            }
            
            // If we found multiple scores, return them
            if (scores.length > 1) {
                console.log('Parsed multiple scores:', scores);
                return scores;
            }
            
            // Alternative pattern: "number name number name"
            const pattern2 = /(\d+)\s+([a-z]+(?:\s+[a-z]+)?)/gi;
            matches = [...cleaned.matchAll(pattern2)];
            
            if (matches.length > 1) {
                scores.length = 0; // Clear previous attempts
                matches.forEach(match => {
                    const points = parseInt(match[1]);
                    const name = match[2].trim();
                    
                    if (name.length > 0 && name.length < 30 && points >= 0 && points <= 9999) {
                        scores.push({ name, points });
                    }
                });
            }
            
            return scores.length > 1 ? scores : null;
        }
        function processVoiceCommand(originalTranscript) {
            // Preprocess to fix common misrecognitions
            const transcript = preprocessTranscript(originalTranscript);
            
            // Check for multi-score input (e.g., "Guy 20 Jonathan 5 Jeff 75")
            // This needs to be checked early before single-score processing
            if (gameInProgress && players.length > 0) {
                const multiScores = parseMultipleScores(transcript);
                if (multiScores && multiScores.length > 1) {
                    console.log('Detected multiple scores:', multiScores);
                    
                    let successCount = 0;
                    let feedbackMessages = [];
                    
                    multiScores.forEach(scoreEntry => {
                        const { name, points } = scoreEntry;
                        
                        // Find player (exact or fuzzy match)
                        let player = players.find(p => p.name.toLowerCase() === name.toLowerCase());
                        if (!player) {
                            player = findClosestPlayer(name);
                        }
                        
                        if (player) {
                            // Process score based on current game mode
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                addScoreToCurrentRound(player.id, points);
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                const success = addScoreToCurrentGolfHole(player.id, points);
                                if (success) {
                                    successCount++;
                                    feedbackMessages.push(`${player.name}: ${points}`);
                                }
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                const success = addScoreToCurrentScrabbleTurn(player.id, points);
                                if (success) {
                                    successCount++;
                                    feedbackMessages.push(`${player.name}: ${points}`);
                                }
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                const success = addScoreToCurrentGenericTurn(player.id, points);
                                if (success) {
                                    successCount++;
                                    feedbackMessages.push(`${player.name}: ${points}`);
                                }
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                // Phase 10 doesn't have automatic turn advancement via voice
                                player.score += points;
                                savePlayers();
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                // Yahtzee doesn't have automatic turn advancement via voice
                                player.score += points;
                                savePlayers();
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            } else {
                                // Standard mode
                                saveStateForUndo(`add ${points} to ${player.name}`);
                                player.score += points;
                                savePlayers();
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            }
                        }
                    });
                    
                    if (successCount > 0) {
                        // Player scoring interface removed - games use dedicated interfaces
                        const feedback = feedbackMessages.join(', ');
                        speak(`Scores added for ${successCount} player${successCount > 1 ? 's' : ''}`);
                        showVoiceFeedback(` ${successCount} score${successCount > 1 ? 's' : ''} added`, feedback);
                        setTimeout(hideVoiceFeedback, 2500);
                        return;
                    }
                }
            }
            
            // Check for button/menu commands first (before other checks)
            // These should work at any time
            
            // "Start Game" or "End Game" button
            if (transcript === 'start game' || transcript === 'start') {
                if (!gameInProgress) {
                    toggleGameState();
                    return;
                }
            }
            
            if (transcript === 'end game' || transcript === 'end' || 
                transcript === 'and game' || transcript === 'endgame' || 
                transcript === 'finish game' || transcript === 'finish' ||
                transcript === 'stop game' || transcript === 'stop') {
                if (gameInProgress) {
                    toggleGameState();
                    return;
                }
            }
            
            // "Reset Scores" button
            if (transcript === 'reset scores' || transcript === 'reset score') {
                resetScores();
                return;
            }
            
            // "Reset All" button
            if (transcript === 'reset all' || transcript === 'reset everything') {
                resetAll();
                return;
            }
            
            // Speaker ON commands
            if (transcript === 'sound on' || 
                transcript === 'computer voice on' || 
                transcript === 'computer on' || 
                transcript === 'speaker on' || 
                transcript === 'volume on') {
                if (isSpeakerMuted) {
                    toggleSpeaker();
                    showVoiceFeedback('Voice enabled', '');
                    setTimeout(hideVoiceFeedback, 1500);
                } else {
                    speak('Voice is already on');
                    showVoiceFeedback('Voice already on', '');
                    setTimeout(hideVoiceFeedback, 1500);
                }
                return;
            }
            
            // Speaker OFF commands
            if (transcript === 'sound off' || 
                transcript === 'computer voice off' || 
                transcript === 'computer off' || 
                transcript === 'speaker off' || 
                transcript === 'volume off') {
                if (!isSpeakerMuted) {
                    speak('Voice disabled');
                    showVoiceFeedback('Voice disabled', '');
                    setTimeout(() => {
                        toggleSpeaker();
                        hideVoiceFeedback();
                    }, 1500);
                } else {
                    showVoiceFeedback('Voice already off', '');
                    setTimeout(hideVoiceFeedback, 1500);
                }
                return;
            }
            
            // "Add More Players" button
            if (transcript === 'add more players' || transcript === 'more players') {
                addMorePlayerFields();
                showVoiceFeedback('Added more player fields', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            // "Done Adding Player Names" button
            if (transcript === 'done adding player names' || 
                transcript === 'done adding players' ||
                transcript === 'done adding names') {
                doneAdding();
                return;
            }
            
            // Tab switching: "Scoring", "High Scores"
            if (transcript === 'scoring' || transcript === 'scorekeeper') {
                switchTab('scorekeeper');
                showVoiceFeedback('Switched to Scoring tab', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            if (transcript === 'high scores' || transcript === 'scores') {
                switchTab('highscores');
                showVoiceFeedback('Switched to High Scores tab', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            // Scrabble buttons
            if (transcript === 'add new scoring row' || transcript === 'add row' || transcript === 'new row') {
                if (currentGameType === 'scrabble') {
                    addScrabbleRow();
                    return;
                } else if (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle') {
                    addGenericRow();
                    return;
                } else {
                    showVoiceFeedback('Only available in Scrabble, General, Darts, or Farkle modes', '');
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            
            if (transcript === 'final scoring adjustments' || 
                transcript === 'final adjustments' ||
                transcript === 'final scoring') {
                if (currentGameType === 'scrabble') {
                    scrabbleFinalAdjustments();
                    return;
                } else {
                    showVoiceFeedback('Only available in Scrabble mode', '');
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            
            // Ignore voice input while computer is speaking protected Scrabble instructions
            if (scrabbleSpeaking) {
                console.log(' Ignoring input while computer is speaking Scrabble instructions');
                return;
            }
            
            // Check if we're collecting Scrabble unplayed tiles
            if (scrabbleIsCollectingTiles) {
                processUnplayedTilesResponse(transcript);
                return;
            }
            
            // Check if we're asking for game type
            if (isAskingGameType) {
                // Ignore input during the initial speech to prevent self-listening
                if (window.gameTypeIgnoreUntil && Date.now() < window.gameTypeIgnoreUntil) {
                    console.log('Ignoring input during initial speech (self-listening prevention)');
                    return;
                }
                
                const gametype = detectGameType(transcript);
                if (gametype) {
                    window.gameTypeIgnoreUntil = null; // Clear ignore flag
                    currentGameType = gametype;
                    document.getElementById('gameType').value = gametype;
                    
                    // Update the custom dropdown display
                    const selectedGameSpan = document.getElementById('selectedGameType');
                    if (selectedGameSpan) {
                        const gameNames = {
                            'general': 'General',
                            'golf': 'Golf',
                            '5crowns': '5 Crowns',
                            'phase10': 'Phase 10',
                            'farkle': 'Farkle',
                            'darts': 'Darts',
                            'scrabble': 'Scrabble',
                            'yahtzee': 'Yahtzee'
                        };
                        selectedGameSpan.textContent = gameNames[gametype] || gametype;
                    }
                    
                    localStorage.setItem('scorekeeper_gametype', gametype);
                    
                    // Check for manually entered player names in the input fields
                    const manualPlayers = [];
                    const inputs = [
                        document.getElementById('playerNameInput1'),
                        document.getElementById('playerNameInput2'),
                        document.getElementById('playerNameInput3'),
                        document.getElementById('playerNameInput4')
                    ];
                    
                    // Also check any additional input fields that may have been added
                    const allInputs = document.querySelectorAll('#playerInputsContainer input[type="text"]');
                    
                    allInputs.forEach(input => {
                        if (input && input.value.trim() !== '') {
                            const name = input.value.trim();
                            const correctedName = correctPronunciation(name);
                            
                            // Check if player already exists
                            const existingPlayer = players.find(p => 
                                p.name.toLowerCase() === correctedName.toLowerCase()
                            );
                            
                            if (!existingPlayer) {
                                manualPlayers.push(correctedName);
                            }
                        }
                    });
                    
                    // Change game type (this switches to appropriate grid mode)
                    changeGameType();
                    
                    // Add manually entered players to the game
                    if (manualPlayers.length > 0) {
                        console.log('Adding manual players to game:', manualPlayers);
                        
                        manualPlayers.forEach(playerName => {
                            const newPlayer = {
                                id: Date.now() + Math.random(),
                                name: playerName,
                                score: 0
                            };
                            players.push(newPlayer);
                            
                            // Initialize grid scores based on game type
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                crownsScores[newPlayer.id] = {};
                                CROWNS_ROUNDS.forEach(round => {
                                    crownsScores[newPlayer.id][round] = 0;
                                });
                                currentCrownsRound[newPlayer.id] = 0;
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                golfScores[newPlayer.id] = {};
                                GOLF_HOLES.forEach(hole => {
                                    golfScores[newPlayer.id][hole] = 0;
                                });
                                currentGolfHole[newPlayer.id] = 0;
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                scrabbleScores[newPlayer.id] = {};
                                SCRABBLE_TURNS.forEach(turn => {
                                    scrabbleScores[newPlayer.id][turn] = 0;
                                });
                                scrabbleScores[newPlayer.id]['unplayed'] = 0;
                                scrabbleScores[newPlayer.id]['opponents'] = 0;
                                currentScrabbleTurn[newPlayer.id] = 0;
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                yahtzeeScores[newPlayer.id] = {
                                    ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                    upperTotal: 0, upperBonus: 0,
                                    threeKind: 0, fourKind: 0, fullHouse: 0,
                                    smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                    yahtzeeBonus: 0
                                };
                                yahtzeeUsedCategories[newPlayer.id] = {};
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                phase10Scores[newPlayer.id] = {};
                                PHASE10_PHASES.forEach(phase => {
                                    phase10Scores[newPlayer.id][phase.num] = 0;
                                });
                                phase10Completed[newPlayer.id] = {};
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                genericGridScores[newPlayer.id] = {};
                                GENERIC_TURNS.forEach(turn => {
                                    genericGridScores[newPlayer.id][turn] = 0;
                                });
                                currentGenericTurn[newPlayer.id] = 0;
                            }
                        });
                        
                        // Save and update tables - player scoring interface removed
                        savePlayers();
                        
                        // Render appropriate grid
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            saveCrownsScores();
                            renderCrownsTable();
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            renderGolfTable();
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            renderScrabbleTable();
                        } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                            saveYahtzeeData();
                            renderYahtzeeTable();
                        } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                            savePhase10Data();
                            renderPhase10Table();
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            saveGenericGridData();
                            renderGenericGridTable();
                        }
                        
                        // Clear input fields
                        allInputs.forEach(input => {
                            if (input) input.value = '';
                        });
                    }
                    
                    // Mark game as in progress
                    gameInProgress = true;
                    updateGameStateButton();
                    
                    isAskingGameType = false;
                    // Don't stop recognition - let it continue running
                    
                    const gameNames = {
                        'golf': 'Golf',
                        '5crowns': '5 Crowns',
                        'phase10': 'Phase 10',
                        'farkle': 'Farkle',
                        'darts': 'Darts',
                        'scrabble': 'Scrabble',
                        'yahtzee': 'Yahtzee',
                        'general': 'General'
                    };
                    
                    const playerCount = manualPlayers.length;
                    const playerMessage = playerCount > 0 ? ` ${playerCount} player${playerCount !== 1 ? 's' : ''} added.` : ' You can now add players.';
                    speak(`Great! ${gameNames[gametype]} selected.${playerMessage}`);
                    showVoiceFeedback(`${gameNames[gametype]} selected!`, transcript);
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                    speak('I didn\'t catch that. Please say Golf, 5 Crowns, Phase 10, Farkle, Darts, Scrabble, Yahtzee, or General.');
                    showVoiceFeedback('Game not recognized', transcript);
                    setTimeout(() => {
                        hideVoiceFeedback();
                        // Don't stop recognition - let user try again immediately
                    }, 3000);
                    return;
                }
            }
            // Check if user says "done" - should work to hide player entry section
            console.log('Checking done command. isAddingMode:', isAddingMode, 'transcript:', transcript);
            
            // Done command works in two contexts:
            // 1. When in voice adding mode (isAddingMode = true)
            // 2. When players exist and user wants to finish setup
            const isDoneCommand = transcript.includes('done') || 
                                  transcript.includes('finished') || 
                                  transcript.includes('that\'s it') ||
                                  transcript.includes('that is it') ||
                                  transcript.includes('stop');
            
            if (isDoneCommand && (isAddingMode || players.length > 0)) {
                console.log(' Done command MATCHED! Calling doneAdding()...');
                
                // Exit adding mode but keep recognition running
                isAddingMode = false;
                // Keep voice recognition running so user can continue with commands
                
                // Call the centralized doneAdding function
                doneAdding();
                return;
            }
            // Check if user wants to start adding players
            if (!isAddingMode && (
                transcript.startsWith('add players') ||
                transcript.startsWith('add names') ||
                transcript === 'add' ||
                transcript.startsWith('add player')
            )) {
                isAddingMode = true;
                addedPlayersInSession = [];
                showVoiceFeedback('Say names... (say "done" when finished)', '');
                return;
            }
            // If in adding mode, treat everything as a name to add
            if (isAddingMode) {
                let names;
                
                // Check if there are commas (typed) or not (voice)
                if (transcript.includes(',')) {
                    // Has commas - split on commas and "and"
                    names = transcript
                        .split(/\s*,\s*and\s+|\s*,\s*|\s+and\s+/)
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                } else {
                    // No commas - voice input - split on " and " AND each word
                    names = transcript
                        .replace(/\s+and\s+/g, ' ')  // Remove " and "
                        .split(/\s+/)  // Split on whitespace
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                }
                
                // Apply filters and corrections
                names = names
                    .filter(name => !['add', 'player', 'players', 'name', 'names', 'and'].includes(name))
                    .map(name => correctPronunciation(name));
                console.log('Adding mode - parsed names:', names);
                if (names.length > 0) {
                    let addedToFields = 0;
                    let addedToGame = 0;
                    
                    names.forEach(name => {
                        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
                        
                        // 1. POPULATE INPUT FIELD (visual feedback)
                        const container = document.getElementById('playerInputsContainer');
                        const allInputs = container.querySelectorAll('input[type="text"]');
                        let foundEmpty = false;
                        
                        for (let input of allInputs) {
                            if (!input.value.trim()) {
                                input.value = capitalizedName;
                                addedToFields++;
                                foundEmpty = true;
                                
                                // Add flash animation
                                input.style.animation = 'none';
                                setTimeout(() => {
                                    input.style.animation = 'pulse 0.5s ease';
                                }, 10);
                                
                                break;
                            }
                        }
                        
                        // If all fields are full, create new fields automatically
                        if (!foundEmpty) {
                            addMorePlayerFields();
                            // Try again to fill the newly created field
                            const newInputs = container.querySelectorAll('input[type="text"]');
                            for (let input of newInputs) {
                                if (!input.value.trim()) {
                                    input.value = capitalizedName;
                                    addedToFields++;
                                    break;
                                }
                            }
                        }
                        
                        // 2. IMMEDIATELY ADD TO GAME (functional)
                        // Check if player already exists
                        const existingPlayer = players.find(p => p.name.toLowerCase() === capitalizedName.toLowerCase());
                        if (!existingPlayer) {
                            const newPlayer = {
                                id: Date.now() + Math.random(),
                                name: capitalizedName,
                                score: 0
                            };
                            players.push(newPlayer);
                            addedToGame++;
                            
                            // Initialize grid scores if in grid mode
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                crownsScores[newPlayer.id] = {};
                                CROWNS_ROUNDS.forEach(round => {
                                    crownsScores[newPlayer.id][round] = 0;
                                });
                                currentCrownsRound[newPlayer.id] = 0;
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                golfScores[newPlayer.id] = {};
                                GOLF_HOLES.forEach(hole => {
                                    golfScores[newPlayer.id][hole] = 0;
                                });
                                currentGolfHole[newPlayer.id] = 0;
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                scrabbleScores[newPlayer.id] = {};
                                SCRABBLE_TURNS.forEach(turn => {
                                    scrabbleScores[newPlayer.id][turn] = 0;
                                });
                                scrabbleScores[newPlayer.id]['unplayed'] = 0;
                                scrabbleScores[newPlayer.id]['opponents'] = 0;
                                currentScrabbleTurn[newPlayer.id] = 0;
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                yahtzeeScores[newPlayer.id] = {
                                    ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                    upperTotal: 0, upperBonus: 0,
                                    threeKind: 0, fourKind: 0, fullHouse: 0,
                                    smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                    yahtzeeBonus: 0
                                };
                                yahtzeeUsedCategories[newPlayer.id] = {};
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                phase10Scores[newPlayer.id] = {};
                                PHASE10_PHASES.forEach(phase => {
                                    phase10Scores[newPlayer.id][phase.num] = 0;
                                });
                                phase10Completed[newPlayer.id] = {};
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                genericGridScores[newPlayer.id] = {};
                                GENERIC_TURNS.forEach(turn => {
                                    genericGridScores[newPlayer.id][turn] = 0;
                                });
                                currentGenericTurn[newPlayer.id] = 0;
                            }
                        }
                        
                        addedPlayersInSession.push(capitalizedName);
                    });
                    
                    // Save players but DON'T render the interface yet - we're still in adding mode
                    if (addedToGame > 0) {
                        savePlayers();
                        // Don't call renderPlayers() here - wait for "Done Adding"
                        
                        // Only render grid tables if in grid mode (they don't show +/- buttons)
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            saveCrownsScores();
                            renderCrownsTable();
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            renderGolfTable();
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            renderScrabbleTable();
                        } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                            saveYahtzeeData();
                            renderYahtzeeTable();
                        } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                            savePhase10Data();
                            renderPhase10Table();
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            saveGenericGridData();
                            renderGenericGridTable();
                        }
                    }
                    
                    const count = addedPlayersInSession.length;
                    showVoiceFeedback(`${addedToGame} player${addedToGame !== 1 ? 's' : ''} added!`, names.join(', '));
                }
                return;
            }
            // If not in adding mode, process other commands
            showVoiceFeedback('Processing...', transcript);
            // Command: Undo last action
            if (transcript === 'undo' || transcript === 'undo that' || transcript === 'go back') {
                undo();
                return;
            }
            // Command: Correction commands (undo and allow re-entry)
            if (transcript === 'make correction' || 
                transcript === 'fix scores' || 
                transcript === 'fix' ||
                transcript === 'wrong' ||
                transcript === 'wrong entry' ||
                transcript === 'wrong number' ||
                transcript === 'wrong score' ||
                transcript === 'delete' ||
                transcript === 'delete score' ||
                transcript === 'delete entry' ||
                transcript === 'remove' ||
                transcript === 'remove score' ||
                transcript === 'remove entry') {
                undo();
                speak('Score removed. Please enter the correct score.');
                showVoiceFeedback('Ready for correction...', 'Say the correct score');
                setTimeout(hideVoiceFeedback, 3000);
                return;
            }
            // Command: Final Scoring Adjustments (Scrabble only)
            if (transcript.includes('final scoring') || 
                transcript.includes('final adjustments') ||
                transcript === 'final scoring adjustments') {
                if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    console.log(' Final Scoring Adjustments command detected');
                    scrabbleFinalAdjustments();
                    return;
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                    speak('Final scoring adjustments are only available in Scrabble mode');
                    showVoiceFeedback('Not in Scrabble mode', 'Switch to Scrabble to use this feature');
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            // Command: Golf over/under scoring (Advanced mode only)
            if (golfMode === 'advanced' && scoringMode === 'golf' && currentGameType === 'golf') {
                // Patterns: "Jonathan 1 over", "Jonathan plus 1", "Jonathan 1 under", "Jonathan minus 1"
                const overUnderPattern = /^(\w+)\s+(\d+)?\s*(over|under|plus|minus)\s*(\d+)?$/i;
                const match = transcript.match(overUnderPattern);
                
                if (match) {
                    const nameInput = match[1];
                    const num1 = match[2];
                    const command = match[3].toLowerCase();
                    const num2 = match[4];
                    
                    // Get the number (could be before or after the command)
                    const number = parseInt(num1 || num2 || '1');
                    
                    // Find matching player
                    const matchedPlayer = players.find(p => 
                        p.name.toLowerCase().startsWith(nameInput.toLowerCase())
                    );
                    
                    if (matchedPlayer) {
                        // Determine if it's over or under
                        const isOver = (command === 'over' || command === 'plus');
                        const scoreValue = isOver ? number : -number;
                        
                        // Find current hole for this player
                        const holeIndex = currentGolfHole[matchedPlayer.id] || 0;
                        if (holeIndex >= GOLF_HOLES.length) {
                            speak(`${matchedPlayer.name} has completed all holes`);
                            showVoiceFeedback('All holes complete', 'Start a new game');
                            return;
                        }
                        
                        const currentHole = GOLF_HOLES[holeIndex];
                        const par = golfCoursePar[currentHole];
                        
                        if (!par) {
                            speak(`Please set par for hole ${currentHole} first`);
                            showVoiceFeedback('Par not set', `Set par for hole ${currentHole}`);
                            return;
                        }
                        
                        // Save state for undo
                        saveStateForUndo(`${matchedPlayer.name} ${scoreValue > 0 ? '+' : ''}${scoreValue} on hole ${currentHole}`);
                        
                        // Add score
                        if (!golfScores[matchedPlayer.id]) {
                            golfScores[matchedPlayer.id] = {};
                        }
                        golfScores[matchedPlayer.id][currentHole] = scoreValue;
                        
                        // Move to next hole
                        currentGolfHole[matchedPlayer.id] = holeIndex + 1;
                        
                        saveGolfData();
                        
                        // Announce the score
                        const actualScore = par + scoreValue;
                        let announcement;
                        if (scoreValue > 0) {
                            announcement = `${matchedPlayer.name}, ${number} over par. Score: ${actualScore}`;
                        } else if (scoreValue < 0) {
                            announcement = `${matchedPlayer.name}, ${Math.abs(number)} under par. Score: ${actualScore}`;
                        } else {
                            announcement = `${matchedPlayer.name}, par. Score: ${actualScore}`;
                        }
                        
                        speak(announcement);
                        showVoiceFeedback(announcement, `Hole ${currentHole}`);
                        
                        renderGolfTable();
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: Add single player (or multiple with commas/and)
            if (transcript.startsWith('add ')) {
                console.log(' Add command detected. Full transcript:', transcript);
                const namesString = transcript.replace('add ', '').trim();
                console.log('Names string extracted:', namesString);
                
                if (namesString && !['players', 'names', 'player', 'name'].includes(namesString)) {
                    let names;
                    
                    // Check if there are commas (typed input) or not (voice input)
                    if (namesString.includes(',')) {
                        // Has commas - split on commas and "and"
                        names = namesString
                            .split(/\s*,\s*and\s+|\s*,\s*|\s+and\s+/)
                            .map(name => name.trim())
                            .filter(name => name.length > 0);
                        console.log('Detected commas - using comma split');
                    } else {
                        // No commas - voice input - split on " and " AND treat each word as a name
                        // First remove "and" to get individual words
                        names = namesString
                            .replace(/\s+and\s+/g, ' ')  // Remove " and "
                            .split(/\s+/)  // Split on whitespace
                            .map(name => name.trim())
                            .filter(name => name.length > 0);
                        console.log('No commas detected - treating each word as a name');
                    }
                    
                    // Apply filters and corrections
                    names = names
                        .filter(name => !['add', 'player', 'players', 'name', 'names', 'and'].includes(name))
                        .map(name => correctPronunciation(name));
                    
                    console.log('Parsed names from "' + namesString + '":', names);
                    console.log('Number of names:', names.length);
                    
                    if (names.length > 0) {
                        // Save state for undo
                        saveStateForUndo(`add ${names.length} player${names.length > 1 ? 's' : ''}`);
                        
                        let addedCount = 0;
                        names.forEach((name, index) => {
                            console.log(`Processing name ${index + 1}/${names.length}:`, name);
                            const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
                            console.log('  Capitalized:', capitalizedName);
                            
                            // Populate field
                            const container = document.getElementById('playerInputsContainer');
                            if (container) {
                                const allInputs = container.querySelectorAll('input[type="text"]');
                                let foundEmpty = false;
                                
                                for (let input of allInputs) {
                                    if (!input.value.trim()) {
                                        input.value = capitalizedName;
                                        foundEmpty = true;
                                        console.log('   Added to field');
                                        
                                        // Add flash animation
                                        input.style.animation = 'none';
                                        setTimeout(() => {
                                            input.style.animation = 'pulse 0.5s ease';
                                        }, 10);
                                        
                                        break;
                                    }
                                }
                                
                                // If all fields are full, create new fields
                                if (!foundEmpty) {
                                    console.log('   All fields full, creating new row');
                                    addMorePlayerFields();
                                    const newInputs = container.querySelectorAll('input[type="text"]');
                                    for (let input of newInputs) {
                                        if (!input.value.trim()) {
                                            input.value = capitalizedName;
                                            console.log('   Added to new field');
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // Add to game immediately
                            const existingPlayer = players.find(p => p.name.toLowerCase() === capitalizedName.toLowerCase());
                            if (!existingPlayer) {
                                console.log('   Adding to game');
                                const newPlayer = {
                                    id: Date.now() + Math.random(),
                                    name: capitalizedName,
                                    score: 0
                                };
                                players.push(newPlayer);
                                addedCount++;
                                
                                // Initialize grid scores if in grid mode
                                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                    crownsScores[newPlayer.id] = {};
                                    CROWNS_ROUNDS.forEach(round => {
                                        crownsScores[newPlayer.id][round] = 0;
                                    });
                                    currentCrownsRound[newPlayer.id] = 0;
                                } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                    golfScores[newPlayer.id] = {};
                                    GOLF_HOLES.forEach(hole => {
                                        golfScores[newPlayer.id][hole] = 0;
                                    });
                                    currentGolfHole[newPlayer.id] = 0;
                                } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                    scrabbleScores[newPlayer.id] = {};
                                    SCRABBLE_TURNS.forEach(turn => {
                                        scrabbleScores[newPlayer.id][turn] = 0;
                                    });
                                    scrabbleScores[newPlayer.id]['unplayed'] = 0;
                                    scrabbleScores[newPlayer.id]['opponents'] = 0;
                                    currentScrabbleTurn[newPlayer.id] = 0;
                                } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                    yahtzeeScores[newPlayer.id] = {
                                        ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                        upperTotal: 0, upperBonus: 0,
                                        threeKind: 0, fourKind: 0, fullHouse: 0,
                                        smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                        yahtzeeBonus: 0
                                    };
                                    yahtzeeUsedCategories[newPlayer.id] = {};
                                } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                    phase10Scores[newPlayer.id] = {};
                                    PHASE10_PHASES.forEach(phase => {
                                        phase10Scores[newPlayer.id][phase.num] = 0;
                                    });
                                    phase10Completed[newPlayer.id] = {};
                                } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                    genericGridScores[newPlayer.id] = {};
                                    GENERIC_TURNS.forEach(turn => {
                                        genericGridScores[newPlayer.id][turn] = 0;
                                    });
                                    currentGenericTurn[newPlayer.id] = 0;
                                }
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                console.log('   Player already exists, skipping');
                            }
                        });
                        
                        if (addedCount > 0) {
                            savePlayers();
                            // Player scoring interface removed - games use dedicated interfaces
                            
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                saveCrownsScores();
                                renderCrownsTable();
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                renderGolfTable();
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                renderScrabbleTable();
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                saveYahtzeeData();
                                renderYahtzeeTable();
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                savePhase10Data();
                                renderPhase10Table();
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                saveGenericGridData();
                                renderGenericGridTable();
                            }
                        }
                        
                        const displayNames = names.join(', ');
                        showVoiceFeedback(`Added ${addedCount} player${addedCount > 1 ? 's' : ''}!`, displayNames);
                        setTimeout(hideVoiceFeedback, 1500);
                    }
                    return;
                }
            }
            // Command: Give points - "give [name] [number] points" or "give [name] [number]"
            const giveMatch = transcript.match(/give\s+(.+?)\s+(.+?)(?:\s+points?)?$/i);
            if (giveMatch) {
                const name = correctPronunciation(giveMatch[1].toLowerCase().trim());
                const numberPart = giveMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Give command match:', name, numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        // In 5 Crowns mode, add to current round
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // In Golf mode, add to current hole
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            // In Scrabble mode, add to current turn
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All 20 turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode
                            saveStateForUndo(`add ${points} to ${player.name}`);
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: "[number] for/to [name]" - e.g. "5 for Guy" or "5 to Guy"
            const forMatch = transcript.match(/^(.+?)\s+(?:for|to)\s+(.+)$/i);
            if (forMatch) {
                const numberPart = forMatch[1].trim();
                const name = correctPronunciation(forMatch[2].toLowerCase().trim());
                const points = convertWordToNumber(numberPart);
                
                console.log('For/To command match:', numberPart, 'for/to', name, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All 20 turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: "[name] [number]" - e.g. "Guy 5"
            // This pattern should come after "for/to" to avoid conflicts
            const nameNumberMatch = transcript.match(/^(.+?)\s+(\d+|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand)$/i);
            if (nameNumberMatch) {
                const name = correctPronunciation(nameNumberMatch[1].toLowerCase().trim());
                const numberPart = nameNumberMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Name-Number command match:', name, numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode
                            saveStateForUndo(`add ${points} to ${player.name}`);
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: "change [name] to [number]" or "update [name] to [number]" - UPDATE score instead of add
            const changeMatch = transcript.match(/(?:change|update)\s+(.+?)\s+to\s+(.+)$/i);
            if (changeMatch) {
                const name = correctPronunciation(changeMatch[1].toLowerCase().trim());
                const numberPart = changeMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Change command match:', name, 'to', numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            // Update the most recent round (go back one)
                            const currentRoundIndex = currentCrownsRound[player.id] || 0;
                            if (currentRoundIndex > 0) {
                                const previousRound = CROWNS_ROUNDS[currentRoundIndex - 1];
                                crownsScores[player.id][previousRound] = points;
                                saveCrownsScores();
                                renderCrownsTableWithHighlight(player.id, previousRound);
                                speak(`Updated ${player.name} round ${previousRound} to ${points}`);
                                showVoiceFeedback(`Round ${previousRound}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            }
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // Update the most recent hole (go back one)
                            const currentHoleIndex = currentGolfHole[player.id] || 0;
                            if (currentHoleIndex > 0) {
                                const previousHole = GOLF_HOLES[currentHoleIndex - 1];
                                golfScores[player.id][previousHole] = points;
                                renderGolfTableWithHighlight(player.id, previousHole);
                                speak(`Updated ${player.name} hole ${previousHole} to ${points}`);
                                showVoiceFeedback(`Hole ${previousHole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            }
                        } else {
                            // Standard mode - SET score (not add)
                            player.score = points;
                            savePlayers();
                            
                            speak(`${player.name} score updated to ${points}`);
                            showVoiceFeedback(`${player.name}: ${points} points`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: Simple format - "[number] [name]" (e.g. "20 Jonathan")
            // Check if first part is a number, second part is a name
            const numberFirstMatch = transcript.match(/^(.+?)[\s,]+(.+)$/i);
            if (numberFirstMatch) {
                const firstPart = numberFirstMatch[1].trim();
                const secondPart = numberFirstMatch[2].trim();
                const firstAsNumber = convertWordToNumber(firstPart);
                
                // If first part is a number, treat second part as name
                if (firstAsNumber !== null) {
                    const points = firstAsNumber;
                    const name = correctPronunciation(secondPart.toLowerCase().trim());
                    
                    console.log('Number-first pattern match:', points, name);
                    
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        // In 5 Crowns mode, add to current round
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // In Golf mode, add to current hole
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            // In Scrabble mode, add to current turn
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode
                            saveStateForUndo(`add ${points} to ${player.name}`);
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        // First part is a number but player not found
                        // Fall through to name-first pattern (maybe it's actually name-number format)
                        console.log('Number-first pattern: player not found, trying name-first');
                    }
                }
            }
            // Command: Simple format - "[name] [number]" or "[name], [number]"
            // This needs to handle both digits and number words
            const simpleAddMatch = transcript.match(/^(.+?)[\s,]+(.+)$/i);
            if (simpleAddMatch) {
                const name = correctPronunciation(simpleAddMatch[1].toLowerCase().trim());
                const numberPart = simpleAddMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Simple add match:', name, numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        // In 5 Crowns mode, add to current round
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // In Golf mode, add to current hole
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            // In Scrabble mode, add to current turn
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All 20 turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode - add to total
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: Subtract format - "[name] minus [number]" or "[name], minus [number]"
            const simpleSubtractMatch = transcript.match(/^(\w+(?:\s+\w+)*?)[\s,]+(?:minus|negative)\s+(\d+)$/i);
            if (simpleSubtractMatch) {
                const name = correctPronunciation(simpleSubtractMatch[1].toLowerCase().trim());
                const points = parseInt(simpleSubtractMatch[2]);
                
                // Try exact match first, then fuzzy match
                let player = players.find(p => 
                    p.name.toLowerCase() === name.toLowerCase() ||
                    p.name.toLowerCase().includes(name.toLowerCase()) || 
                    name.toLowerCase().includes(p.name.toLowerCase())
                );
                
                // If no exact match, try fuzzy matching
                if (!player) {
                    player = findClosestPlayer(name);
                    if (player) {
                        console.log('Fuzzy matched "' + name + '" to player:', player.name);
                    }
                }
                
                if (player) {
                    player.score -= points;
                    savePlayers();
                    
                    showVoiceFeedback(`-${points} from ${player.name}!`, transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    
                    const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                    if (scoreElement) {
                        scoreElement.classList.remove('pulse');
                        void scoreElement.offsetWidth;
                        scoreElement.classList.add('pulse');
                    }
                    return;
                } else {
                    showVoiceFeedback(`Player "${name}" not found`, transcript);
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            // Command: Take points - "take [number] from [name]" or "subtract [number] from [name]"
            const takeMatch = transcript.match(/(?:take|subtract|remove)\s+(\d+)(?:\s+points?)?\s+from\s+(\w+(?:\s+\w+)*)/i);
            if (takeMatch) {
                const points = parseInt(takeMatch[1]);
                const name = takeMatch[2].toLowerCase();
                const player = players.find(p => p.name.toLowerCase().includes(name) || name.includes(p.name.toLowerCase()));
                
                if (player) {
                    player.score -= points;
                    savePlayers();
                    
                    showVoiceFeedback(`-${points} from ${player.name}!`, transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    
                    const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                    if (scoreElement) {
                        scoreElement.classList.remove('pulse');
                        void scoreElement.offsetWidth;
                        scoreElement.classList.add('pulse');
                    }
                    return;
                } else {
                    showVoiceFeedback(`Player "${name}" not found`, transcript);
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            // Command: Reset scores
            if (transcript.includes('reset') && transcript.includes('score')) {
                if (players.length > 0) {
                    players.forEach(p => p.score = 0);
                    savePlayers();
                    
                    showVoiceFeedback('All scores reset!', transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    return;
                }
            }
            // Command: Reset all
            if (transcript.includes('reset') && (transcript.includes('all') || transcript.includes('everything'))) {
                if (players.length > 0) {
                    players = [];
                    savePlayers();
                    
                    showVoiceFeedback('Everything reset!', transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    return;
                }
            }
            // If nothing matched, show feedback
            showVoiceFeedback('Command not recognized', transcript);
            setTimeout(hideVoiceFeedback, 2000);
        }
        // Load players from localStorage on startup
        function loadPlayers() {
            // Clear players and scores on launch for fresh start
            players = [];
            crownsScores = {};
            currentCrownsRound = {};
            gameInProgress = false; // Reset game state on page load
            savePlayers();
            saveCrownsScores();
            localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            
            
            // Load game type (keep the last selected game, but not if it's general)
            const savedGameType = localStorage.getItem('scorekeeper_gametype');
            if (savedGameType && savedGameType !== 'general') {
                currentGameType = savedGameType;
                const hiddenSelect = document.getElementById('gameType');
                if (hiddenSelect) {
                    hiddenSelect.value = savedGameType;
                }
                // Also update the visible dropdown display
                const selectedSpan = document.getElementById('selectedGameType');
                const gameNames = {
                    'general': 'General',
                    'golf': 'Golf',
                    '5crowns': '5 Crowns',
                    'phase10': 'Phase 10',
                    'farkle': 'Farkle',
                    'darts': 'Darts',
                    'scrabble': 'Scrabble',
                    'yahtzee': 'Yahtzee'
                };
                if (selectedSpan) {
                    selectedSpan.textContent = gameNames[savedGameType] || savedGameType;
                }
                changeGameType();
            }
            // Load walls
            loadWalls();
            
            // Load 5 Crowns scores
            loadCrownsScores();
            // Check if we've asked for game type before
            const askedBefore = localStorage.getItem('scorekeeper_asked_gametype');
            hasAskedGameType = askedBefore === 'true';
            // If this is the first time and speech recognition is available, ask for game type
            if (!hasAskedGameType && recognition) {
                setTimeout(() => {
                    askForGameType();
                }, 1000); // Wait 1 second after page load
            }
            
            // Ensure Start Game button is green on load
            updateGameStateButton();
        }
        // Save players to localStorage
        function savePlayers() {
            localStorage.setItem('scorekeeper_players', JSON.stringify(players));
        }
        
        // Save player input field values to sessionStorage
        function savePlayerInputs() {
            const inputs = {
                input1: document.getElementById('playerNameInput1')?.value || '',
                input2: document.getElementById('playerNameInput2')?.value || '',
                input3: document.getElementById('playerNameInput3')?.value || '',
                input4: document.getElementById('playerNameInput4')?.value || ''
            };
            console.log('Saving player inputs:', inputs);
            sessionStorage.setItem('scorekeeper_player_inputs', JSON.stringify(inputs));
            
            // Verify it was saved
            const verification = sessionStorage.getItem('scorekeeper_player_inputs');
            console.log('Verification - data in sessionStorage:', verification);
        }
        
        // Load player input field values from sessionStorage
        function loadPlayerInputs() {
            console.log('=== Loading Player Inputs ===');
            console.log('Current URL:', window.location.href);
            console.log('Protocol:', window.location.protocol);
            console.log('All sessionStorage keys:', Object.keys(sessionStorage));
            console.log('sessionStorage length:', sessionStorage.length);
            console.log('Looking for key: scorekeeper_player_inputs');
            const saved = sessionStorage.getItem('scorekeeper_player_inputs');
            console.log('Loading player inputs from sessionStorage:', saved);
            if (saved) {
                const inputs = JSON.parse(saved);
                console.log('Parsed inputs:', inputs);
                const input1 = document.getElementById('playerNameInput1');
                const input2 = document.getElementById('playerNameInput2');
                const input3 = document.getElementById('playerNameInput3');
                const input4 = document.getElementById('playerNameInput4');
                
                console.log('Found input elements:', {input1: !!input1, input2: !!input2, input3: !!input3, input4: !!input4});
                
                if (input1) input1.value = inputs.input1 || '';
                if (input2) input2.value = inputs.input2 || '';
                if (input3) input3.value = inputs.input3 || '';
                if (input4) input4.value = inputs.input4 || '';
                
                console.log('Values set to:', {
                    input1: input1?.value,
                    input2: input2?.value,
                    input3: input3?.value,
                    input4: input4?.value
                });
            } else {
                console.log('No saved player inputs found in sessionStorage');
            }
        }
        // Game Start
        function toggleGameVariantDropdown() {
            const dropdown = document.getElementById('gameVariantDropdown');
            const dropdownList = document.getElementById('gameVariantDropdownList');
            
            if (!dropdown || !dropdownList) return;
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        
        function selectGameVariant(variant) {
            const selectedSpan = document.getElementById('selectedGameVariant');
            const dropdown = document.getElementById('gameVariantDropdown');
            const dropdownList = document.getElementById('gameVariantDropdownList');
            
            if (selectedSpan) {
                selectedSpan.textContent = variant;
            }
            
            // Close dropdown
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Set the starting score and trigger change
            startingScore = parseInt(variant);
            changeGameVariant();
        }
        
        function changeGameVariant() {
            // If game is in progress, update all player scores
            if (gameStarted) {
                players.forEach(player => {
                    if (dartsScores[player.id]) {
                        dartsScores[player.id].score = startingScore;
                        dartsScores[player.id].currentTurn = [];
                        dartsScores[player.id].doubledIn = !requireDoubleIn; // If double in not required, set to true
                        dartsScores[player.id].currentTurnTotal = 0;
                        dartsScores[player.id].currentTurnStartScore = startingScore;
                    }
                });
                renderGame();
            }
        }
        
        function startGameDarts() {
            if (players.length < 1) {
                return;
            }
            
            gameStarted = true;
            dartsScores = {};
            dartsHistory = [];
            dartsNextMultiplier = null;
            dartsKeypadRendered = false; // Reset flag for new game
            
            players.forEach(player => {
                dartsScores[player.id] = {
                    score: startingScore,
                    legs: 0,
                    sets: 0,
                    doubledIn: !requireDoubleIn,
                    currentTurn: [],
                    darts: 0,
                    currentTurnTotal: 0,
                    currentTurnStartScore: startingScore
                };
            });
            
            dartsCurrentPlayer = players[0].id;
            
            // Hide all other game modes
            const standardMode = document.getElementById('standardMode');
            const crownsMode = document.getElementById('crownsMode');
            const golfMode = document.getElementById('golfMode');
            const scrabbleMode = document.getElementById('scrabbleMode');
            const yahtzeeMode = document.getElementById('yahtzeeMode');
            const phase10Mode = document.getElementById('phase10Mode');
            const genericGridMode = document.getElementById('genericGridMode');
            
            if (standardMode) standardMode.style.display = 'none';
            if (crownsMode) crownsMode.classList.remove('active');
            if (golfMode) golfMode.classList.remove('active');
            if (scrabbleMode) scrabbleMode.classList.remove('active');
            if (yahtzeeMode) yahtzeeMode.classList.remove('active');
            if (phase10Mode) phase10Mode.classList.remove('active');
            if (genericGridMode) genericGridMode.classList.remove('active');
            
            // Show Darts container
            const darts501Container = document.getElementById('darts501Container');
            if (darts501Container) {
                darts501Container.style.display = 'block';
            }
            
            // Show game area
            const gameArea = document.getElementById('gameArea');
            if (gameArea) {
                gameArea.style.display = 'block';
            }
            
            renderGame();
        }

        

        // Game Rendering
        function renderGame() {
            renderDartsPlayers();
            renderKeypad();
        }

        function renderDartsPlayers() {
            // Get the playersContainer inside gameArea (not the one in standardMode)
            const gameArea = document.getElementById('gameArea');
            const container = gameArea ? gameArea.querySelector('#playersContainer') : null;
            
            if (!container) {
                return;
            }
            
            let html = '';
            
            players.forEach((player, index) => {
                const data = dartsScores[player.id];
                
                if (!data) {
                    return;
                }
                
                let dartsHTML = '';
                for (let i = 0; i < 3; i++) {
                    const dart = data.currentTurn[i];
                    let dartText = '';
                    let bgColor = '#f0f0f0';
                    let textColor = '#333';
                    
                    if (dart && dart.value !== undefined) {
                        // Check if dart is counted or not (for Double In rule)
                        if (dart.counted === false) {
                            // Uncounted dart - show in red
                            bgColor = '#ffebee'; // Light red background
                            textColor = '#c62828'; // Red text
                        } else {
                            // Counted dart - use normal colors based on type
                            if (dart.type === 'double') {
                                bgColor = '#4CAF50'; // Green for double
                                textColor = 'white';
                            } else if (dart.type === 'triple') {
                                bgColor = '#FF9800'; // Orange for triple
                                textColor = 'white';
                            }
                        }
                        
                        // Add prefix based on type
                        if (dart.type === 'double') {
                            dartText = 'D' + dart.value;
                        } else if (dart.type === 'triple') {
                            dartText = 'T' + dart.value;
                        } else {
                            dartText = dart.value;
                        }
                    }
                    
                    dartsHTML += `<div style="width: 40px; height: 40px; background: ${bgColor}; border: 2px solid #ddd; display: flex; align-items: center; justify-content: center; font-weight: bold; color: ${textColor}; border-radius: 4px;">${dartText}</div>`;
                }
                
                let turnTotal = 0;
                data.currentTurn.forEach(dart => {
                    if (dart && dart.counted) turnTotal += dart.score;
                });
                
                const isActive = dartsCurrentPlayer === player.id;
                const activeClass = isActive ? ' darts-player-card active' : ' darts-player-card';
                
                html += `
                    <div class="${activeClass}" 
                         data-player-id="${player.id}" 
                         data-player-index="${index}"
                         draggable="true"
                         ondragstart="handleDartsDragStart(event, ${index})"
                         ondragover="handleDartsDragOver(event)"
                         ondragleave="handleDartsDragLeave(event)"
                         ondrop="handleDartsDrop(event, ${index})"
                         ondragend="handleDartsDragEnd(event)"
                         ontouchstart="handleTouchStart(event, ${index})"
                         ontouchmove="handleTouchMove(event)"
                         ontouchend="handleTouchEnd(event, ${index})"
                         onclick="selectDartsPlayer('${player.id}')" 
                         style="display: flex; align-items: center; gap: 15px; background: white; border: 2px solid #4CAF50; padding: 10px 15px; min-height: 50px; margin: 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: move; transition: background 0.2s ease;">
                        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 120px;" onclick="event.stopPropagation()">
                            <div style="display: flex; gap: 10px; align-items: baseline;">
                                <div style="font-size: 18px; font-weight: bold; color: #333;">${data.score}</div>
                                <div style="font-size: 18px; font-weight: bold; color: #333;">${player.name}</div>
                            </div>
                            <div style="display: flex; gap: 10px; font-size: 12px; color: #000;">
                                <div>Turn Total: ${turnTotal}</div>
                                <div>Legs: ${data.legs}</div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-left: auto;" onclick="event.stopPropagation()">${dartsHTML}</div>
                    </div>
                `;
            });
            
            // Clear and style the container
            container.innerHTML = '';
            container.style.cssText = 'display: flex; flex-direction: column; gap: 10px; width: 100%; padding: 0;';
            
            // Set innerHTML
            container.innerHTML = html;
        }

        function renderKeypad() {
            // Use flag to prevent multiple renders - much more reliable than checking DOM
            if (dartsKeypadRendered) return;
            
            const container = document.getElementById('keypadContainer');
            const actionContainer = document.getElementById('actionButtonsContainer');
            
            if (!container || !actionContainer) return;
            
            // Mark as rendered BEFORE doing any work
            dartsKeypadRendered = true;
            
            // Clear both containers to ensure clean state
            container.innerHTML = '';
            actionContainer.innerHTML = '';
            
            // Reorder numbers: 0 first, then 1-20, then 25, then 50, then 100
            const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25, 50, 100];
            numbers.forEach(num => {
                const btn = document.createElement('button');
                btn.className = 'darts-keypad-btn';
                btn.textContent = num;
                btn.onclick = () => dartHit(num);
                container.appendChild(btn);
            });
            
            // Action buttons in separate container - each taking 1/3 width
            const doubleBtn = document.createElement('button');
            doubleBtn.className = 'darts-keypad-btn double';
            doubleBtn.textContent = 'Double';
            doubleBtn.style.flex = '1';
            doubleBtn.onclick = () => setMultiplier('double');
            actionContainer.appendChild(doubleBtn);
            
            const tripleBtn = document.createElement('button');
            tripleBtn.className = 'darts-keypad-btn triple';
            tripleBtn.textContent = 'Triple';
            tripleBtn.style.flex = '1';
            tripleBtn.onclick = () => setMultiplier('triple');
            actionContainer.appendChild(tripleBtn);
            
            const undoBtn = document.createElement('button');
            undoBtn.className = 'darts-keypad-btn undo';
            undoBtn.textContent = 'UNDO';
            undoBtn.style.flex = '1';
            undoBtn.onclick = () => undoDarts();
            actionContainer.appendChild(undoBtn);
        }

        // Game Logic
        function setMultiplier(type) {
            dartsNextMultiplier = type;
        }

        function dartHit(value) {
            const playerData = dartsScores[dartsCurrentPlayer];
            if (!playerData) return;
            
            if (playerData.currentTurn.length >= 3) return;
            
            // Track starting score for this turn (on first dart)
            if (playerData.currentTurn.length === 0) {
                playerData.currentTurnStartScore = playerData.score;
            }
            
            let score = value;
            let type = 'single';
            
            if (dartsNextMultiplier === 'double') {
                score = value * 2;
                type = 'double';
                dartsNextMultiplier = null;
            } else if (dartsNextMultiplier === 'triple') {
                score = value * 3;
                type = 'triple';
                dartsNextMultiplier = null;
            }
            
            console.log('Saving to history. Current player:', dartsCurrentPlayer, 'History length before:', dartsHistory.length);
            dartsHistory.push({
                scores: JSON.parse(JSON.stringify(dartsScores)),
                currentPlayer: dartsCurrentPlayer
            });
            console.log('History length after save:', dartsHistory.length);
            
            // Determine if this dart will be counted
            let isCounted = true;
            if (requireDoubleIn && !playerData.doubledIn) {
                // During double-in phase, count if this is a double OR if a double was already thrown in this turn
                const doubleAlreadyThrown = playerData.currentTurn.some(d => d.type === 'double' && d.value > 0);
                isCounted = (type === 'double' && value > 0) || doubleAlreadyThrown;
            }
            
            playerData.currentTurn.push({ value, score, type, counted: isCounted });
            playerData.darts++;
            
            // Calculate turn total considering double-in rule
            let turnTotal = 0;
            if (requireDoubleIn && !playerData.doubledIn) {
                // During double-in phase - only count double darts
                for (let i = 0; i < playerData.currentTurn.length; i++) {
                    if (playerData.currentTurn[i].counted) {
                        turnTotal += playerData.currentTurn[i].score;
                    }
                }
            } else {
                // After double-in phase, count all darts
                playerData.currentTurn.forEach(dart => {
                    if (dart) turnTotal += dart.score;
                });
            }
            
            // Store the turn total for display in renderPlayers
            playerData.currentTurnTotal = turnTotal;
            
            // Calculate new score based on STARTING score of the turn, not current score
            const newScore = playerData.currentTurnStartScore - turnTotal;
            
            // Check for bust - but handle double-in phase specially
            let isBust = false;
            if (requireDoubleIn && !playerData.doubledIn) {
                // In double-in phase, only bust if all 3 darts thrown with no double found
                if (playerData.currentTurn.length === 3) {
                    const doubleFound = playerData.currentTurn.some(d => d.type === 'double' && d.value > 0);
                    if (!doubleFound) {
                        isBust = true;
                    }
                }
            } else {
                // Normal bust checking (score goes negative or equals 1)
                if (newScore < 0 || newScore === 1) {
                    isBust = true;
                }
            }
            
            if (isBust) {
                endTurn(true);
                return;
            }
            
            // Win
            if (newScore === 0) {
                if (requireDoubleOut) {
                    // Must finish with a double
                    if (type === 'double') {
                        playerData.score = 0;
                        playerData.legs++;
                        renderGame();
                        
                        const winner = players.find(p => p.id === dartsCurrentPlayer);
                        showWinner(winner.name);
                    } else {
                        endTurn(true);
                    }
                } else {
                    // Can finish with any dart
                    playerData.score = 0;
                    playerData.legs++;
                    renderGame();
                    
                    const winner = players.find(p => p.id === dartsCurrentPlayer);
                    showWinner(winner.name);
                }
                return;
            }
            
            playerData.score = newScore;
            
            // Always render to show dart boxes and turn total
            renderGame();
            
            // Check if turn is complete (3 darts)
            if (playerData.currentTurn.length === 3) {
                endTurn(false);
            }
        }

        function selectDartsPlayer(playerId) {
            dartsCurrentPlayer = playerId;
            renderGame();
        }
        
        // Helper function to hide all game modes
        function hideAllGameModes() {
            const standardMode = document.getElementById('standardMode');
            const crownsMode = document.getElementById('crownsMode');
            const golfMode = document.getElementById('golfMode');
            const scrabbleMode = document.getElementById('scrabbleMode');
            const yahtzeeMode = document.getElementById('yahtzeeMode');
            const phase10Mode = document.getElementById('phase10Mode');
            const genericGridMode = document.getElementById('genericGridMode');
            const darts501Container = document.getElementById('darts501Container');
            
            if (standardMode) standardMode.style.display = 'none';
            if (crownsMode) crownsMode.classList.remove('active');
            if (golfMode) golfMode.classList.remove('active');
            if (scrabbleMode) scrabbleMode.classList.remove('active');
            if (yahtzeeMode) yahtzeeMode.classList.remove('active');
            if (phase10Mode) phase10Mode.classList.remove('active');
            if (genericGridMode) genericGridMode.classList.remove('active');
            if (darts501Container) darts501Container.style.display = 'none';
        }

        function selectDartsPlayer(playerId) {
            console.log('Selecting player:', playerId);
            dartsCurrentPlayer = playerId;
            renderGame();
        }
        
        // Drag and drop variables
        let draggedPlayerIndex = null;
        
        function handleDartsDragStart(event, index) {
            draggedPlayerIndex = index;
            event.target.style.opacity = '0.4';
            event.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDartsDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            // Add visual feedback
            const target = event.currentTarget;
            if (target && target.classList.contains('darts-player-card')) {
                target.style.borderColor = '#2196F3';
                target.style.borderWidth = '3px';
            }
            return false;
        }
        
        function handleDartsDragLeave(event) {
            // Remove visual feedback when dragging out
            const target = event.currentTarget;
            if (target && target.classList.contains('darts-player-card')) {
                target.style.borderColor = '#4CAF50';
                target.style.borderWidth = '2px';
            }
        }
        
        function handleDartsDrop(event, dropIndex) {
            event.stopPropagation();
            event.preventDefault();
            
            // Remove visual feedback
            const target = event.currentTarget;
            if (target && target.classList.contains('darts-player-card')) {
                target.style.borderColor = '#4CAF50';
                target.style.borderWidth = '2px';
            }
            
            if (draggedPlayerIndex === null || draggedPlayerIndex === dropIndex) {
                return false;
            }
            
            // Reorder the players array
            const draggedPlayer = players[draggedPlayerIndex];
            players.splice(draggedPlayerIndex, 1);
            players.splice(dropIndex, 0, draggedPlayer);
            
            // Set the top player as the current player
            dartsCurrentPlayer = players[0].id;
            
            // Re-render to show new order
            renderGame();
            
            return false;
        }
        
        function handleDartsDragEnd(event) {
            event.target.style.opacity = '1';
            // Reset all borders
            document.querySelectorAll('.darts-player-card').forEach(card => {
                card.style.borderColor = '#4CAF50';
                card.style.borderWidth = '2px';
            });
            draggedPlayerIndex = null;
        }
        
        // Touch event handlers for mobile devices
        let touchDraggedIndex = null;
        let touchDragElement = null;
        
        function handleTouchStart(event, index) {
            touchDraggedIndex = index;
            touchDragElement = event.currentTarget;
            touchDragElement.style.opacity = '0.4';
        }
        
        function handleTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // Reset all borders
            document.querySelectorAll('.darts-player-card').forEach(card => {
                card.style.borderColor = '#4CAF50';
                card.style.borderWidth = '2px';
            });
            
            // Highlight the element we're over
            if (elementBelow && elementBelow.classList.contains('darts-player-card')) {
                elementBelow.style.borderColor = '#2196F3';
                elementBelow.style.borderWidth = '3px';
            }
        }
        
        function handleTouchEnd(event, dropIndex) {
            if (touchDragElement) {
                touchDragElement.style.opacity = '1';
            }
            
            // Reset all borders
            document.querySelectorAll('.darts-player-card').forEach(card => {
                card.style.borderColor = '#4CAF50';
                card.style.borderWidth = '2px';
            });
            
            if (touchDraggedIndex === null || touchDraggedIndex === dropIndex) {
                touchDraggedIndex = null;
                touchDragElement = null;
                return;
            }
            
            // Reorder the players array
            const draggedPlayer = players[touchDraggedIndex];
            players.splice(touchDraggedIndex, 1);
            players.splice(dropIndex, 0, draggedPlayer);
            
            // Set the top player as the current player
            dartsCurrentPlayer = players[0].id;
            
            // Re-render to show new order
            renderGame();
            
            touchDraggedIndex = null;
            touchDragElement = null;
        }
        
        function endTurn(bust) {
            const playerData = dartsScores[dartsCurrentPlayer];
            
            if (bust) {
                // On bust, restore the score to what it was at the start of this turn
                playerData.score = playerData.currentTurnStartScore;
            }
            
            // Check if this turn had a double (for double-in rule)
            if (requireDoubleIn && !playerData.doubledIn) {
                const doubleFound = playerData.currentTurn.some(d => d.type === 'double' && d.value > 0);
                if (doubleFound) {
                    playerData.doubledIn = true;
                }
            }
            
            const currentIndex = players.findIndex(p => p.id === dartsCurrentPlayer);
            const nextIndex = (currentIndex + 1) % players.length;
            dartsCurrentPlayer = players[nextIndex].id;
            
            // Clear the NEW current player's old turn data to prepare for their new turn
            dartsScores[dartsCurrentPlayer].currentTurn = [];
            dartsScores[dartsCurrentPlayer].darts = 0;
            dartsScores[dartsCurrentPlayer].currentTurnTotal = 0;
            dartsScores[dartsCurrentPlayer].currentTurnStartScore = 0;
            
            renderGame();
        }

        function resetLeg() {
            players.forEach(player => {
                dartsScores[player.id].score = startingScore;
                dartsScores[player.id].currentTurn = [];
                dartsScores[player.id].doubledIn = !requireDoubleIn; // If double in not required, set to true
                dartsScores[player.id].darts = 0;
                dartsScores[player.id].currentTurnTotal = 0;
                dartsScores[player.id].currentTurnStartScore = startingScore;
            });
            renderGame();
        }

        function undoDarts() {
            console.log('Undo called. History length:', dartsHistory.length);
            if (dartsHistory.length === 0) {
                alert('Nothing to undo');
                return;
            }
            const historyState = dartsHistory.pop();
            console.log('Restoring state. Player:', historyState.currentPlayer);
            dartsScores = historyState.scores;
            dartsCurrentPlayer = historyState.currentPlayer;
            console.log('Current player now:', dartsCurrentPlayer);
            renderGame();
        }

        function newLeg() {
            resetLeg();
        }
        
        function newSet() {
            // Reset leg
            resetLeg();
            // Also reset legs counter for all players
            players.forEach(player => {
                if (dartsScores[player.id]) {
                    dartsScores[player.id].legs = 0;
                }
            });
            renderGame();
        }

        function resetGame() {
            if (!confirm('Reset entire game?')) return;
            
            gameStarted = false;
            players = [];
            dartsScores = {};
            dartsKeypadRendered = false; // Reset flag so keypad can be rendered again
            
            const gameArea = document.getElementById('gameArea');
            if (gameArea) gameArea.style.display = 'none';
            document.getElementById('resetBtn').style.display = 'none';
            document.getElementById('keypadContainer').innerHTML = '';
            document.getElementById('actionButtonsContainer').innerHTML = '';
        }

        function showWinner(name) {
            const modal = document.getElementById('winnerModal');
            document.getElementById('winnerText').textContent = 'Winner!';
            document.getElementById('winnerDetails').textContent = `${name} wins the leg!`;
            modal.classList.add('active');
            
            // Announce winner and other player scores
            let announcement = `${name} wins! `;
            
            // Add other players' legs won (not current score)
            const otherPlayers = players.filter(p => p.name !== name);
            if (otherPlayers.length > 0) {
                announcement += "Other players' scores: ";
                otherPlayers.forEach((player, index) => {
                    const playerLegs = dartsScores[player.id]?.legs || 0;
                    const legWord = playerLegs === 1 ? 'leg' : 'legs';
                    announcement += `${player.name}: ${playerLegs} ${legWord}`;
                    if (index < otherPlayers.length - 1) {
                        announcement += ", ";
                    }
                });
            }
            
            speak(announcement);
        }

        function closeWinnerModal() {
            document.getElementById('winnerModal').classList.remove('active');
            resetLeg(); // Reset the leg for the next round
        }

        function updateGameRules() {
            requireDoubleIn = document.getElementById('doubleInCheckbox').checked;
            requireDoubleOut = document.getElementById('doubleOutCheckbox').checked;
        }

        // toggleMenu function already defined as window.toggleMenu above

        function changeGameType() {
            // Cancel any voice operations when manually changing game type
            cancelAllVoiceOperations();
            
            const select = document.getElementById('gameType');
            // Only read from select if it exists and matches currentGameType
            // This prevents overwriting when selectGameType has already set currentGameType
            if (select && select.value && select.value !== currentGameType) {
                console.log('changeGameType: Select value differs from currentGameType');
                console.log('  select.value:', select.value);
                console.log('  currentGameType:', currentGameType);
                console.log('  Using currentGameType (already set by selectGameType)');
            }
            // If no select found, currentGameType should already be set by selectGameType
            console.log('changeGameType called, currentGameType:', currentGameType);
            
            localStorage.setItem('scorekeeper_gametype', currentGameType);
            
            // If no players, always show standard mode with empty state
            if (players.length === 0) {
                console.log('No players - showing standard mode empty state');
                const standardMode = document.getElementById('standardMode');
                const crownsMode = document.getElementById('crownsMode');
                const golfMode = document.getElementById('golfMode');
                const scrabbleMode = document.getElementById('scrabbleMode');
                const yahtzeeMode = document.getElementById('yahtzeeMode');
                const phase10Mode = document.getElementById('phase10Mode');
                const genericGridMode = document.getElementById('genericGridMode');
                const darts501Container = document.getElementById('darts501Container');
                
                // Show standard mode, hide all grid modes
                standardMode.style.display = 'block';
                if (crownsMode) crownsMode.classList.remove('active');
                if (golfMode) golfMode.classList.remove('active');
                if (scrabbleMode) scrabbleMode.classList.remove('active');
                if (yahtzeeMode) yahtzeeMode.classList.remove('active');
                if (phase10Mode) phase10Mode.classList.remove('active');
                if (genericGridMode) genericGridMode.classList.remove('active');
                if (darts501Container) darts501Container.style.display = 'none';
                
                // Update instructions display
                updateStandardModeDisplay();
                
                 // This will show the empty state
                return;
            }
            
            // Players exist - update subtitle based on game type
            const subtitle = document.querySelector('.subtitle');
            switch(currentGameType) {
                case 'golf':
                    subtitle.textContent = 'Lower Score Wins';
                    break;
                case '5crowns':
                    subtitle.textContent = 'Lower Score Wins';
                    break;
                case 'phase10':
                    subtitle.textContent = 'Lower Score Wins';
                    break;
                case 'farkle':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                case 'darts':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                case 'scrabble':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                case 'yahtzee':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                default:
                    subtitle.textContent = 'Track  Compete  Win';
            }
            // Automatically switch to 5 Crowns Grid mode if 5 Crowns is selected
            if (currentGameType === '5crowns') {
                console.log('Switching to 5 Crowns grid mode');
                scoringMode = 'crowns';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show 5 Crowns mode
                const crownsMode = document.getElementById('crownsMode');
                crownsMode.classList.add('active');
                
                console.log('standardMode display:', standardMode.style.display);
                console.log('crownsMode classList:', crownsMode.classList);
                
                // Initialize grid with existing players (preserves any existing data)
                initializeCrownsScores();
                renderCrownsTable();
                
                // Don't render players on main screen - 5 Crowns uses its own grid interface
            } else if (currentGameType === 'golf') {
                console.log('Switching to Golf grid mode');
                scoringMode = 'golf';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Golf mode
                const golfMode = document.getElementById('golfMode');
                golfMode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializeGolfScores();
                renderGolfTable();
                
                // Update the golf course dropdown list
                updateSavedCoursesList();
                
                // Don't render players on main screen - Golf uses its own grid interface
            } else if (currentGameType === 'scrabble') {
                console.log('Switching to Scrabble grid mode');
                scoringMode = 'scrabble';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Scrabble mode
                const scrabbleMode = document.getElementById('scrabbleMode');
                scrabbleMode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializeScrabbleScores();
                renderScrabbleTable();
                
                // Don't render players on main screen - Scrabble uses its own grid interface
            } else if (currentGameType === 'yahtzee') {
                console.log('Switching to Yahtzee grid mode');
                scoringMode = 'yahtzee';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Yahtzee mode
                const yahtzeeMode = document.getElementById('yahtzeeMode');
                yahtzeeMode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializeYahtzeeScores();
                renderYahtzeeTable();
                
                // Don't render players on main screen - Yahtzee uses its own grid interface
            } else if (currentGameType === 'phase10') {
                console.log('Switching to Phase 10 grid mode');
                scoringMode = 'phase10';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Phase 10 mode
                const phase10Mode = document.getElementById('phase10Mode');
                phase10Mode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializePhase10Scores();
                renderPhase10Table();
                
                // Don't render players on main screen - Phase 10 uses its own grid interface
            } else if (currentGameType === 'darts') {
                console.log('Switching to Darts 501 mode');
                
                // If players already exist, start the Darts game directly
                if (players.length > 0) {
                    console.log('Darts: Players exist, starting game directly');
                    
                    // Hide all other modes first
                    hideAllGameModes();
                    
                    // Initialize Darts if not already initialized
                    if (!dartsScores || Object.keys(dartsScores).length === 0) {
                        console.log('Initializing Darts game with existing players');
                        startGameDarts();
                    } else {
                        // Just show the Darts interface
                        const darts501Container = document.getElementById('darts501Container');
                        if (darts501Container) {
                            darts501Container.style.display = 'block';
                            const gameArea = document.getElementById('gameArea');
                            if (gameArea) gameArea.style.display = 'block';
                            renderGame();
                        }
                    }
                } else {
                    // No players yet - show player setup
                    console.log('Darts: No players, showing player setup screen');
                    
                    // Hide all other modes first
                    hideAllGameModes();
                    
                    // Show general player setup
                    const standardMode = document.getElementById('standardMode');
                    const addPlayerSection = document.getElementById('addPlayerSection');
                    if (standardMode) standardMode.style.display = 'block';
                    if (addPlayerSection) addPlayerSection.style.display = 'flex';
                }
            } else {
                // Use generic grid for General and Farkle
                if (currentGameType === 'general' || currentGameType === 'farkle') {
                    console.log('Switching to Generic Grid mode for', currentGameType);
                    scoringMode = 'generic';
                    
                    // Hide all other modes first
                    hideAllGameModes();
                    
                    // Show Generic Grid mode
                    const genericGridMode = document.getElementById('genericGridMode');
                    if (genericGridMode) genericGridMode.classList.add('active');
                    
                    // Hide Scrabble buttons
                    const scrabbleButtonContainer = document.getElementById('scrabbleButtons');
                    if (scrabbleButtonContainer) scrabbleButtonContainer.style.display = 'none';
                    
                    // Initialize grid with existing players (preserves any existing data)
                    initializeGenericGridScores();
                    renderGenericGridTable();
                    
                    // Don't render players on main screen - Generic Grid uses its own grid interface
                } else {
                    // Switch back to standard mode for other games
                    scoringMode = 'standard';
                    document.getElementById('standardMode').style.display = 'block';
                    const darts501Container = document.getElementById('darts501Container');
                    if (darts501Container) darts501Container.style.display = 'none'; // Hide Darts
                    const addPlayerSection = document.getElementById('addPlayerSection');
                    if (addPlayerSection) addPlayerSection.style.display = 'flex'; // Show general player setup
                    document.getElementById('crownsMode').classList.remove('active');
                    if (document.getElementById('golfMode')) {
                        document.getElementById('golfMode').classList.remove('active');
                    }
                    if (document.getElementById('scrabbleMode')) {
                        document.getElementById('scrabbleMode').classList.remove('active');
                    }
                    if (document.getElementById('yahtzeeMode')) {
                        document.getElementById('yahtzeeMode').classList.remove('active');
                    }
                    if (document.getElementById('genericGridMode')) {
                        document.getElementById('genericGridMode').classList.remove('active');
                    }
                    
                    // Hide Scrabble buttons
                    const buttonContainer = document.getElementById('scrabbleButtons');
                    if (buttonContainer) buttonContainer.style.display = 'none';
                    
                    // Hide generic grid buttons
                    const genericButtonContainer = document.getElementById('genericGridButtons');
                    if (genericButtonContainer) genericButtonContainer.style.display = 'none';
                    
                    // Re-render player list to show current scores
                    
                }
            }
        }
        function addPlayer() {
            // Cancel any voice operations when manually adding players
            cancelAllVoiceOperations();
            
            // Check all 4 input fields
            const inputs = [
                document.getElementById('playerNameInput1'),
                document.getElementById('playerNameInput2'),
                document.getElementById('playerNameInput3'),
                document.getElementById('playerNameInput4')
            ];
            
            let addedCount = 0;
            
            inputs.forEach((input, index) => {
                if (input) {
                    const name = input.value.trim();
                    if (name !== '') {
                        const correctedName = correctPronunciation(name);
                        const player = {
                            id: Date.now() + index,
                            name: correctedName,
                            score: 0
                        };
                        
                        players.push(player);
                        addedCount++;
                        input.value = ''; // Clear the field
                    }
                }
            });
            
            if (addedCount > 0) {
                savePlayers();
                
                
                // Focus first empty field
                const firstEmpty = inputs.find(input => input && input.value === '');
                if (firstEmpty) {
                    firstEmpty.focus();
                }
            }
        }
        function addMorePlayerFields() {
            const container = document.getElementById('playerInputsContainer');
            
            // Create a new row with 2 input fields
            const newRow = document.createElement('div');
            newRow.className = 'player-inputs-row';
            
            const input1 = document.createElement('input');
            input1.type = 'text';
            input1.id = 'playerNameInput' + nextPlayerNumber;
            input1.placeholder = 'Player ' + nextPlayerNumber;
            input1.maxLength = 20;
            
            const input2 = document.createElement('input');
            input2.type = 'text';
            input2.id = 'playerNameInput' + (nextPlayerNumber + 1);
            input2.placeholder = 'Player ' + (nextPlayerNumber + 1);
            input2.maxLength = 20;
            
            // Add Enter key support for new inputs
            input1.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addMorePlayerFields();
                }
            });
            input2.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addMorePlayerFields();
                }
            });
            
            newRow.appendChild(input1);
            newRow.appendChild(input2);
            container.appendChild(newRow);
            
            // Update next player number
            nextPlayerNumber += 2;
            
            // Focus on the first new input
            input1.focus();
        }
        function doneAdding() {
            // Cancel any voice operations when done adding players
            cancelAllVoiceOperations();
            
            console.log('doneAdding called, current players:', players.length);
            
            // First, add any names that are in the text fields but haven't been added yet
            // Find all input fields dynamically (including newly added ones)
            const container = document.getElementById('playerInputsContainer');
            const allInputs = container.querySelectorAll('input[type="text"]');
            
            let addedCount = 0;
            let skippedCount = 0;
            allInputs.forEach((input, index) => {
                if (input) {
                    const name = input.value.trim();
                    if (name !== '') {
                        const correctedName = correctPronunciation(name);
                        
                        // Check if player already exists
                        const existingPlayer = players.find(p => p.name.toLowerCase() === correctedName.toLowerCase());
                        
                        if (!existingPlayer) {
                            const player = {
                                id: Date.now() + index + Math.random(),
                                name: correctedName,
                                score: 0
                            };
                            
                            players.push(player);
                            addedCount++;
                            console.log('doneAdding: Added new player:', correctedName);
                        } else {
                            skippedCount++;
                            console.log('doneAdding: Player already exists, skipping:', correctedName);
                        }
                        
                        input.value = ''; // Clear the field
                    }
                }
            });
            
            console.log(`doneAdding: Added ${addedCount}, Skipped ${skippedCount}, Total players: ${players.length}`);
            console.log('Current game type:', currentGameType);
            console.log('Current scoring mode:', scoringMode);
            
            // Clear saved player inputs since we're done adding
            sessionStorage.removeItem('scorekeeper_player_inputs');
            
            // If no players at all, exit early
            if (players.length === 0) {
                speak('No players added yet.');
                showVoiceFeedback('No players added', '');
                setTimeout(hideVoiceFeedback, 2000);
                return;
            }
            
            // Save players
            savePlayers();
            
            // Initialize grid based on game type
            console.log('=== DONE ADDING - INITIALIZING GAME ===');
            console.log('Current game type from variable:', currentGameType);
            console.log('Game type in localStorage:', localStorage.getItem('scorekeeper_gametype'));
            console.log('Dropdown value:', document.getElementById('gameType')?.value);
            console.log('Initializing game for type:', currentGameType);
            if (currentGameType === '5crowns') {
                scoringMode = 'crowns';
                initializeCrownsScores();
                renderCrownsTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'golf') {
                scoringMode = 'golf';
                initializeGolfScores();
                renderGolfTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'scrabble') {
                scoringMode = 'scrabble';
                initializeScrabbleScores();
                renderScrabbleTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'yahtzee') {
                scoringMode = 'yahtzee';
                initializeYahtzeeScores();
                renderYahtzeeTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'phase10') {
                scoringMode = 'phase10';
                initializePhase10Scores();
                renderPhase10Table();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'darts') {
                // Initialize Darts game
                console.log('Initializing Darts game with players:', players.length);
                startGameDarts();
            } else if (currentGameType === 'general' || currentGameType === 'farkle') {
                // For generic games, call changeGameType to initialize
                console.log('Calling changeGameType for generic game');
                changeGameType();
            }
            
            // Hide the add player section
            console.log('Hiding addPlayerSection');
            const addPlayerSection = document.getElementById('addPlayerSection');
            if (addPlayerSection) {
                addPlayerSection.style.display = 'none';
                console.log('addPlayerSection hidden');
            }
            
            // Set flag so section stays hidden when switching tabs
            isDoneAdding = true;
            
            // Add grid-mode class to body to trigger tab bar replacement
            document.body.classList.add('grid-mode');
            
            // Move game-type-row into tab-navigation-container
            const gameTypeRow = document.querySelector('.game-type-row');
            const tabNavContainer = document.querySelector('.tab-navigation-container');
            if (gameTypeRow && tabNavContainer) {
                // Insert game-type-row as first child of tab-navigation-container
                tabNavContainer.insertBefore(gameTypeRow, tabNavContainer.firstChild);
            }
            
            // Clear adding mode state
            isAddingMode = false;
            addedPlayersInSession = [];
            
            // Mark game as in progress and update button
            console.log('Setting game in progress');
            gameInProgress = true;
            updateGameStateButton();
            
            speak(`${players.length} player${players.length > 1 ? 's' : ''} ready! Let's start the game.`);
            showVoiceFeedback(`${players.length} player${players.length > 1 ? 's' : ''} ready!`, '');
            setTimeout(hideVoiceFeedback, 2000);
            
            // Update instructions display (will hide them since players now exist)
            updateStandardModeDisplay();
        }
        
        function updateStandardModeDisplay() {
            const instructions = document.getElementById('standardModeInstructions');
            const standardMode = document.getElementById('standardMode');
            if (instructions && standardMode) {
                // Show instructions only when no players exist and standard mode is visible
                const isStandardModeVisible = standardMode.style.display !== 'none';
                if (players.length === 0 && isStandardModeVisible) {
                    instructions.style.display = 'block';
                } else {
                    instructions.style.display = 'none';
                }
            }
        }
        
        function deletePlayer(id) {
            // Find the player before deleting (for console logging)
            const player = players.find(p => p.id === id);
            if (player) {
                console.log('Deleting player:', player.name, 'ID:', id);
                
                // Remove from players array
                players = players.filter(p => p.id !== id);
                
                // Remove from 5 Crowns scores if in that mode
                if (crownsScores[id]) {
                    delete crownsScores[id];
                    delete currentCrownsRound[id];
                    saveCrownsScores();
                    localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                    console.log('Removed from 5 Crowns scores');
                }
                
                // Remove from Golf scores if in that mode
                if (golfScores[id]) {
                    delete golfScores[id];
                    delete currentGolfHole[id];
                    console.log('Removed from Golf scores');
                }
                
                // Remove from Scrabble scores if in that mode
                if (scrabbleScores[id]) {
                    delete scrabbleScores[id];
                    delete currentScrabbleTurn[id];
                    console.log('Removed from Scrabble scores');
                }
                
                // Save and render
                savePlayers();
                
                
                // Re-render grids if in grid mode
                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                    renderCrownsTable();
                    console.log('Refreshed 5 Crowns grid');
                } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                    renderGolfTable();
                    console.log('Refreshed Golf grid');
                } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    renderScrabbleTable();
                    console.log('Refreshed Scrabble grid');
                }
            }
        }
        // updateScore function removed with old player interface
        // ===== UNDO FUNCTIONALITY =====
        
        function saveStateForUndo(actionDescription) {
            const state = {
                description: actionDescription,
                players: JSON.parse(JSON.stringify(players)),
                crownsScores: JSON.parse(JSON.stringify(crownsScores)),
                currentCrownsRound: JSON.parse(JSON.stringify(currentCrownsRound)),
                golfScores: JSON.parse(JSON.stringify(golfScores)),
                currentGolfHole: JSON.parse(JSON.stringify(currentGolfHole)),
                timestamp: Date.now()
            };
            
            undoStack.push(state);
            
            // Keep stack size manageable
            if (undoStack.length > MAX_UNDO_HISTORY) {
                undoStack.shift();
            }
            
            console.log('Saved undo state:', actionDescription, 'Stack size:', undoStack.length);
        }
        
        function undo() {
            if (undoStack.length === 0) {
                speak('Nothing to undo');
                showVoiceFeedback('Nothing to undo', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            // Pop the last state
            const previousState = undoStack.pop();
            
            // Restore state
            players = JSON.parse(JSON.stringify(previousState.players));
            crownsScores = JSON.parse(JSON.stringify(previousState.crownsScores));
            currentCrownsRound = JSON.parse(JSON.stringify(previousState.currentCrownsRound));
            golfScores = JSON.parse(JSON.stringify(previousState.golfScores));
            currentGolfHole = JSON.parse(JSON.stringify(previousState.currentGolfHole));
            
            // Save and render
            savePlayers();
            saveCrownsScores();
            localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            
            
            // Re-render grids if needed
            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                renderCrownsTable();
            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                renderGolfTable();
            }
            
            speak(`Undid ${previousState.description}`);
            showVoiceFeedback(`Undid: ${previousState.description}`, '');
            setTimeout(hideVoiceFeedback, 2000);
            
            console.log('Undid action:', previousState.description, 'Remaining in stack:', undoStack.length);
        }
        async function resetScores() {
            // Cancel any voice operations when manually resetting scores
            cancelAllVoiceOperations();
            
            if (players.length === 0) return;
            
            const shouldReset = await customConfirm('Reset all scores to 0?', ' Reset Scores');
            if (shouldReset) {
                // Reset standard scores
                players.forEach(p => p.score = 0);
                
                // Reset 5 Crowns scores if in that mode
                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                    players.forEach(player => {
                        CROWNS_ROUNDS.forEach(round => {
                            if (crownsScores[player.id]) {
                                crownsScores[player.id][round] = 0;
                            }
                        });
                        currentCrownsRound[player.id] = 0;
                    });
                    saveCrownsScores();
                    localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                    renderCrownsTable();
                }
                
                // Reset Golf scores if in that mode
                if (scoringMode === 'golf' && currentGameType === 'golf') {
                    players.forEach(player => {
                        GOLF_HOLES.forEach(hole => {
                            if (golfScores[player.id]) {
                                golfScores[player.id][hole] = 0;
                            }
                        });
                        currentGolfHole[player.id] = 0;
                    });
                    renderGolfTable();
                }
                
                // Reset Scrabble scores if in that mode
                if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    players.forEach(player => {
                        SCRABBLE_TURNS.forEach(turn => {
                            if (scrabbleScores[player.id]) {
                                scrabbleScores[player.id][turn] = 0;
                            }
                        });
                        if (scrabbleScores[player.id]) {
                            scrabbleScores[player.id]['unplayed'] = 0;
                            scrabbleScores[player.id]['opponents'] = 0;
                        }
                        currentScrabbleTurn[player.id] = 0;
                    });
                    renderScrabbleTable();
                }
                
                // Reset Yahtzee scores if in that mode
                if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                    players.forEach(player => {
                        if (yahtzeeScores[player.id]) {
                            // Reset all category scores to 0
                            yahtzeeScores[player.id] = {
                                ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                upperTotal: 0, upperBonus: 0,
                                threeKind: 0, fourKind: 0, fullHouse: 0,
                                smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                yahtzeeBonus: 0
                            };
                        }
                        // Clear all used categories so they show as "-" again
                        yahtzeeUsedCategories[player.id] = {};
                    });
                    saveYahtzeeData();
                    renderYahtzeeTable();
                }
                
                // Reset Phase 10 scores if in that mode
                if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                    players.forEach(player => {
                        if (phase10Scores[player.id]) {
                            PHASE10_PHASES.forEach(phase => {
                                phase10Scores[player.id][phase.num] = 0;
                            });
                        }
                        phase10Completed[player.id] = {};
                    });
                    savePhase10Data();
                    renderPhase10Table();
                }
                
                // Reset Generic Grid scores if in that mode
                if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                    players.forEach(player => {
                        GENERIC_TURNS.forEach(turn => {
                            if (genericGridScores[player.id]) {
                                genericGridScores[player.id][turn] = 0;
                            }
                        });
                        currentGenericTurn[player.id] = 0;
                    });
                    saveGenericGridData();
                    renderGenericGridTable();
                }
                
                savePlayers();
                
            }
        }
        window.resetAll = async function() {
            console.log(' Reset All button clicked');
            // Cancel any voice operations when resetting all
            cancelAllVoiceOperations();
            
            console.log(' Calling customConfirm for Reset All...');
            const shouldReset = await customConfirm('Reset everything and start over?', ' Reset All');
            console.log(' customConfirm returned:', shouldReset);
            
            if (shouldReset) {
                console.log(' User confirmed reset, proceeding...');
                // Clear all players and scores
                players = [];
                crownsScores = {};
                currentCrownsRound = {};
                golfScores = {};
                currentGolfHole = {};
                scrabbleScores = {};
                currentScrabbleTurn = {};
                yahtzeeScores = {};
                yahtzeeUsedCategories = {};
                phase10Scores = {};
                phase10Completed = {};
                genericGridScores = {};
                currentGenericTurn = {};
                dartsScores = {};
                dartsCurrentPlayer = null;
                dartsKeypadRendered = false; // Reset keypad flag
                SCRABBLE_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Reset to 12 turns
                scrabbleMaxTurn = 12; // Reset max turn
                GENERIC_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Reset to 12 turns
                genericMaxTurn = 12; // Reset max turn
                gameInProgress = false;
                gameStarted = false; // Reset Darts game started flag
                isAskingGameType = false;
                hasAskedGameType = false;
                isDoneAdding = false; // Reset done adding flag
                
                // Remove grid-mode class from body
                document.body.classList.remove('grid-mode');
                
                // Move game-type-row back to its original position (after tab-navigation-container)
                const gameTypeRow = document.querySelector('.game-type-row');
                const tabNavContainer = document.querySelector('.tab-navigation-container');
                if (gameTypeRow && tabNavContainer && gameTypeRow.parentElement === tabNavContainer) {
                    tabNavContainer.parentElement.insertBefore(gameTypeRow, tabNavContainer.nextSibling);
                }
                nextPlayerNumber = 5; // Reset to 5 for next added fields
                currentGameType = 'general'; // Reset game type to general
                
                // Save cleared state
                savePlayers();
                saveCrownsScores();
                saveYahtzeeData();
                savePhase10Data();
                saveGenericGridData();
                localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                localStorage.removeItem('scorekeeper_asked_gametype'); // Allow game type to be asked again
                localStorage.setItem('scorekeeper_gametype', 'general'); // Reset to general
                
                // Reset game type selector
                const gameTypeSelect = document.getElementById('gameType');
                if (gameTypeSelect) {
                    gameTypeSelect.value = 'general';
                }
                const selectedGameType = document.getElementById('selectedGameType');
                if (selectedGameType) {
                    selectedGameType.textContent = 'Select a Game';
                }
                
                // Clear all input fields and reset to initial 4 fields
                const container = document.getElementById('playerInputsContainer');
                container.innerHTML = `
                    <div class="player-inputs-row">
                        <input type="text" id="playerNameInput1" placeholder="Player 1" maxlength="20">
                        <input type="text" id="playerNameInput2" placeholder="Player 2" maxlength="20">
                    </div>
                    <div class="player-inputs-row">
                        <input type="text" id="playerNameInput3" placeholder="Player 3" maxlength="20">
                        <input type="text" id="playerNameInput4" placeholder="Player 4" maxlength="20">
                    </div>
                `;
                
                // Re-add Enter key listeners to initial fields
                ['playerNameInput1', 'playerNameInput2', 'playerNameInput3', 'playerNameInput4'].forEach(function(id) {
                    const input = document.getElementById(id);
                    if (input) {
                        input.addEventListener('keypress', function(e) {
                            if (e.key === 'Enter') {
                                addMorePlayerFields();
                            }
                        });
                    }
                });
                
                // Show the add player section
                document.getElementById('addPlayerSection').style.display = 'flex';
                
                // Switch back to scorekeeper tab
                currentTab = 'scorekeeper';
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById('scorekeeperTab').classList.add('active');
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-btn')[0].classList.add('active'); // First tab button
                
                // Switch to standard mode since we have no players
                scoringMode = 'generic';
                document.getElementById('standardMode').style.display = 'block';
                document.getElementById('crownsMode').classList.remove('active');
                if (document.getElementById('golfMode')) {
                    document.getElementById('golfMode').classList.remove('active');
                }
                if (document.getElementById('scrabbleMode')) {
                    document.getElementById('scrabbleMode').classList.remove('active');
                }
                if (document.getElementById('yahtzeeMode')) {
                    document.getElementById('yahtzeeMode').classList.remove('active');
                }
                if (document.getElementById('phase10Mode')) {
                    document.getElementById('phase10Mode').classList.remove('active');
                }
                if (document.getElementById('genericGridMode')) {
                    document.getElementById('genericGridMode').classList.remove('active');
                }
                
                // Hide Darts interface
                const gameArea = document.getElementById('gameArea');
                if (gameArea) gameArea.style.display = 'none';
                const darts501Container = document.getElementById('darts501Container');
                if (darts501Container) darts501Container.style.display = 'none';
                
                // Clear Darts keypad and action buttons
                const keypadContainer = document.getElementById('keypadContainer');
                if (keypadContainer) keypadContainer.innerHTML = '';
                const actionButtonsContainer = document.getElementById('actionButtonsContainer');
                if (actionButtonsContainer) actionButtonsContainer.innerHTML = '';
                
                // Clear grid tables
                const crownsTable = document.getElementById('crownsTable');
                if (crownsTable) {
                    crownsTable.innerHTML = '';
                }
                const golfTable = document.getElementById('golfTable');
                if (golfTable) {
                    golfTable.innerHTML = '';
                }
                const scrabbleTable = document.getElementById('scrabbleTable');
                if (scrabbleTable) {
                    scrabbleTable.innerHTML = '';
                }
                const yahtzeeTable = document.getElementById('yahtzeeTable');
                if (yahtzeeTable) {
                    yahtzeeTable.innerHTML = '';
                }
                const phase10Table = document.getElementById('phase10Table');
                if (phase10Table) {
                    phase10Table.innerHTML = '';
                }
                const genericGridTable = document.getElementById('genericGridTable');
                if (genericGridTable) {
                    genericGridTable.innerHTML = '';
                }
                
                // Update game state button to green "Start Game"
                updateGameStateButton();
                
                // Hide Scrabble buttons
                const buttonContainer = document.getElementById('scrabbleButtons');
                if (buttonContainer) buttonContainer.style.display = 'none';
                
                // Hide generic grid buttons
                const genericButtonContainer = document.getElementById('genericGridButtons');
                if (genericButtonContainer) genericButtonContainer.style.display = 'none';
                
                // Render empty state (instructions panel)
                
                
                // Call changeGameType to ensure UI is properly set for 'general' mode
                changeGameType();
                
                console.log(' Reset All completed successfully');
                // Show feedback
                showVoiceFeedback('Reset complete! Add players to start.', '');
                setTimeout(hideVoiceFeedback, 2000);
            } else {
                console.log(' User cancelled Reset All');
            }
        }
        // renderPlayers function removed - old +/- scoring interface no longer used
        // editPlayerName function removed with old player interface
        // editScore function removed with old player interface
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ===== CUSTOM GAME TRACKING FUNCTIONS =====
        
        function openCustomGameTrackingModal() {
            // Close hamburger menu first
            const sideMenu = document.getElementById('sideMenu');
            const menuOverlay = document.getElementById('menuOverlay');
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            
            if (sideMenu) sideMenu.classList.remove('open');
            if (menuOverlay) menuOverlay.classList.remove('show');
            if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            
            // Close wins tracker dropdown properly
            const winsDropdown = document.getElementById('winsTrackerDropdown');
            const winsDropdownList = document.getElementById('winsTrackerDropdownList');
            if (winsDropdown) winsDropdown.classList.remove('open');
            if (winsDropdownList) winsDropdownList.classList.remove('open');
            
            // Reset form
            resetCustomGameForm();
            
            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('customGameDate').value = today;
            
            // Show modal
            document.getElementById('customGameTrackingModal').classList.add('show');
        }
        
        function closeCustomGameTrackingModal() {
            document.getElementById('customGameTrackingModal').classList.remove('show');
            resetCustomGameForm();
        }
        
        function resetCustomGameForm() {
            // Clear all inputs
            document.getElementById('customGameType').value = '';
            document.getElementById('customGameDate').value = '';
            
            // Reset players container to initial 2 players
            const container = document.getElementById('customGamePlayersContainer');
            container.innerHTML = `
                <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <input type="text" class="custom-player-input" placeholder="Player 1" maxlength="20" 
                           style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                    <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                           style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <input type="text" class="custom-player-input" placeholder="Player 2" maxlength="20" 
                           style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                    <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                           style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                </div>
            `;
            
            // Clear winner dropdown
            const winnerSelect = document.getElementById('customGameWinner');
            winnerSelect.innerHTML = '<option value="">Select Winner</option>';
            
            // Add event listeners for updating winner dropdown
            updateCustomGameWinnerOptions();
        }
        
        function addCustomGamePlayer() {
            const container = document.getElementById('customGamePlayersContainer');
            const playerCount = container.children.length;
            
            // Maximum 8 players
            if (playerCount >= 8) {
                customAlert('Maximum 8 players allowed.', ' Player Limit');
                return;
            }
            
            const newPlayerDiv = document.createElement('div');
            newPlayerDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: center;';
            newPlayerDiv.innerHTML = `
                <input type="text" class="custom-player-input" placeholder="Player ${playerCount + 1}" maxlength="20" 
                       style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                       style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                <button class="delete-btn" onclick="removeCustomGamePlayer(this)" style="width: 36px; height: 36px; font-size: 1.1rem;"></button>
            `;
            
            container.appendChild(newPlayerDiv);
            
            // Add event listeners to new inputs
            const nameInput = newPlayerDiv.querySelector('.custom-player-input');
            nameInput.addEventListener('input', updateCustomGameWinnerOptions);
            
            updateCustomGameWinnerOptions();
        }
        
        function removeCustomGamePlayer(button) {
            button.parentElement.remove();
            updateCustomGameWinnerOptions();
        }
        
        function updateCustomGameWinnerOptions() {
            const winnerSelect = document.getElementById('customGameWinner');
            const currentWinner = winnerSelect.value;
            
            // Clear existing options
            winnerSelect.innerHTML = '<option value="">Select Winner</option>';
            
            // Get all player name inputs
            const nameInputs = document.querySelectorAll('.custom-player-input');
            nameInputs.forEach((input, index) => {
                const playerName = input.value.trim();
                if (playerName) {
                    const option = document.createElement('option');
                    option.value = playerName;
                    option.textContent = playerName;
                    if (playerName === currentWinner) {
                        option.selected = true;
                    }
                    winnerSelect.appendChild(option);
                }
            });
        }
        
        async function saveCustomGame() {
            // Validate inputs
            const gameTypeRaw = document.getElementById('customGameType').value.trim();
            const gameDate = document.getElementById('customGameDate').value;
            const winnerRaw = document.getElementById('customGameWinner').value;
            
            // Normalize game type and winner
            const gameType = normalizeGameType(gameTypeRaw);
            const winner = normalizePlayerName(winnerRaw);
            
            if (!gameType) {
                customAlert('Please enter a game type.', ' Missing Information');
                return;
            }
            
            if (!gameDate) {
                customAlert('Please select a date.', ' Missing Information');
                return;
            }
            
            // Get players and scores
            const nameInputs = document.querySelectorAll('.custom-player-input');
            const scoreInputs = document.querySelectorAll('.custom-player-score');
            const players = [];
            
            for (let i = 0; i < nameInputs.length; i++) {
                const nameRaw = nameInputs[i].value.trim();
                const score = scoreInputs[i].value.trim();
                
                if (nameRaw) {
                    const normalizedName = normalizePlayerName(nameRaw);
                    players.push({
                        name: normalizedName,
                        score: score ? parseInt(score) : 0
                    });
                }
            }
            
            if (players.length < 2) {
                customAlert('Please enter at least 2 players.', ' Missing Information');
                return;
            }
            
            if (!winner) {
                customAlert('Please select a winner.', ' Missing Information');
                return;
            }
            
            // Check if winner is in player list
            if (!players.some(p => p.name === winner)) {
                customAlert('Winner must be one of the players.', ' Invalid Winner');
                return;
            }
            
            // Create custom game record
            const customGame = {
                gameType: gameType,
                date: gameDate,
                players: players,
                winner: winner,
                timestamp: Date.now()
            };
            
            // Save to localStorage
            saveCustomGameRecord(customGame);
            
            // Update wins tracking for all players
            players.forEach(player => {
                const isWinner = player.name === winner;
                updatePlayerWins(player.name, gameType.toLowerCase().replace(/\s+/g, ''), isWinner);
            });
            
            // Show success message and close modal
            await customAlert(`${gameType} game saved successfully!\n\nWinner: ${winner}`, ' Game Saved');
            closeCustomGameTrackingModal();
        }
        
        function saveCustomGameRecord(customGame) {
            // Get existing custom games
            const existingGames = JSON.parse(localStorage.getItem('scorekeeper_custom_games') || '[]');
            
            // Add new game
            existingGames.push(customGame);
            
            // Save back to localStorage
            localStorage.setItem('scorekeeper_custom_games', JSON.stringify(existingGames));
        }
        
        function loadCustomGameRecords() {
            return JSON.parse(localStorage.getItem('scorekeeper_custom_games') || '[]');
        }
        
        function openCustomGamesViewer() {
            // Close hamburger menu first
            const sideMenu = document.getElementById('sideMenu');
            const menuOverlay = document.getElementById('menuOverlay');
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            
            if (sideMenu) sideMenu.classList.remove('open');
            if (menuOverlay) menuOverlay.classList.remove('show');
            if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            
            // Close wins tracker dropdown properly
            const winsDropdown = document.getElementById('winsTrackerDropdown');
            const winsDropdownList = document.getElementById('winsTrackerDropdownList');
            if (winsDropdown) winsDropdown.classList.remove('open');
            if (winsDropdownList) winsDropdownList.classList.remove('open');
            
            // Display custom games
            displayCustomGames();
            
            // Show modal
            document.getElementById('customGamesViewerModal').classList.add('show');
        }
        
        function closeCustomGamesViewer() {
            document.getElementById('customGamesViewerModal').classList.remove('show');
        }
        
        function displayCustomGames() {
            const customGames = loadCustomGameRecords();
            const container = document.getElementById('customGamesDisplay');
            
            if (customGames.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-dim);">
                        <div style="font-size: 2rem; margin-bottom: 15px;"></div>
                        <div style="font-weight: 700; margin-bottom: 10px; color: var(--text-primary);">No Custom Games Yet</div>
                        <div style="font-size: 0.9rem; line-height: 1.4;">
                            Track games that don't have dedicated scoring grids.<br>
                            Perfect for Cribbage, Chess, StarCraft, and more!
                        </div>
                    </div>
                `;
                return;
            }
            
            // Get unique game types with game count (using normalized game types)
            const gameTypeMap = new Map();
            customGames.forEach(game => {
                const normalizedGameType = normalizeGameType(game.gameType);
                if (!gameTypeMap.has(normalizedGameType)) {
                    gameTypeMap.set(normalizedGameType, {
                        name: normalizedGameType,
                        count: 0,
                        latestDate: game.timestamp
                    });
                }
                gameTypeMap.get(normalizedGameType).count++;
                // Update latest date if this game is more recent
                if (game.timestamp > gameTypeMap.get(normalizedGameType).latestDate) {
                    gameTypeMap.get(normalizedGameType).latestDate = game.timestamp;
                }
            });
            
            // Convert to array and sort by latest date (most recently played first)
            const gameTypes = Array.from(gameTypeMap.values()).sort((a, b) => b.latestDate - a.latestDate);
            
            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            
            gameTypes.forEach(gameType => {
                const pluralGames = gameType.count === 1 ? 'game' : 'games';
                
                html += `
                    <div onclick="openCustomGameStatistics('${escapeHtml(gameType.name)}')" 
                         style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 18px; border-left: 4px solid var(--neon-blue); cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: space-between; align-items: center;"
                         onmouseover="this.style.background='rgba(255,255,255,0.1)'"
                         onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                        <div>
                            <div style="font-weight: 700; color: #000000; font-size: 1.1rem; margin-bottom: 5px;">${escapeHtml(gameType.name)}</div>
                            <div style="font-size: 0.85rem; color: #666666;">${gameType.count} ${pluralGames} tracked</div>
                        </div>
                        <div style="color: #666666; font-size: 1.2rem;"></div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        async function deleteCustomGame(index) {
            const customGames = loadCustomGameRecords();
            const game = customGames[index];
            
            if (!game) return;
            
            const confirmed = await customConfirm(
                `Delete ${game.gameType} game from ${new Date(game.timestamp).toLocaleDateString()}?\n\nThis will also remove it from win tracking statistics.`,
                ' Delete Custom Game'
            );
            
            if (confirmed) {
                // Remove from custom games array
                customGames.splice(index, 1);
                localStorage.setItem('scorekeeper_custom_games', JSON.stringify(customGames));
                
                // Remove from win tracking stats
                game.players.forEach(player => {
                    const gameTypeKey = game.gameType.toLowerCase().replace(/\s+/g, '');
                    const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
                    
                    if (winsData[gameTypeKey] && winsData[gameTypeKey][player.name]) {
                        const stats = winsData[gameTypeKey][player.name];
                        
                        // Decrease played count
                        if (stats.played > 0) {
                            stats.played--;
                        }
                        
                        // Decrease wins count if this player was the winner
                        if (player.name === game.winner && stats.wins > 0) {
                            stats.wins--;
                        }
                        
                        // Remove player entry if no games left
                        if (stats.played === 0) {
                            delete winsData[gameTypeKey][player.name];
                        }
                        
                        // Remove game type if no players left
                        if (Object.keys(winsData[gameTypeKey]).length === 0) {
                            delete winsData[gameTypeKey];
                        }
                    }
                    
                    localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
                });
                
                // Refresh display
                displayCustomGames();
                
                await customAlert('Custom game deleted successfully.', ' Game Deleted');
            }
        }
        
        function openCustomGameStatistics(gameType) {
            // Close Custom Games viewer
            closeCustomGamesViewer();
            
            // Set modal title
            document.getElementById('customGameStatisticsTitle').textContent = `${gameType} Statistics`;
            
            // Display statistics
            displayCustomGameStatistics(gameType);
            
            // Show modal
            document.getElementById('customGameStatisticsModal').classList.add('show');
        }
        
        function closeCustomGameStatistics() {
            document.getElementById('customGameStatisticsModal').classList.remove('show');
        }
        
        function displayCustomGameStatistics(gameType) {
            const container = document.getElementById('customGameStatisticsDisplay');
            const customGames = loadCustomGameRecords();
            
            // Filter games for this specific game type
            const gameTypeGames = customGames.filter(game => game.gameType === gameType);
            
            if (gameTypeGames.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-dim);">
                        <div style="font-size: 2rem; margin-bottom: 15px;"></div>
                        <div style="font-weight: 700; margin-bottom: 10px; color: var(--text-primary);">No ${gameType} Games Found</div>
                        <div style="font-size: 0.9rem;">No statistics available for this game type.</div>
                    </div>
                `;
                return;
            }
            
            // Calculate player statistics
            const playerStats = new Map();
            
            gameTypeGames.forEach(game => {
                game.players.forEach(player => {
                    if (!playerStats.has(player.name)) {
                        playerStats.set(player.name, { played: 0, wins: 0 });
                    }
                    
                    const stats = playerStats.get(player.name);
                    stats.played++;
                    
                    if (player.name === game.winner) {
                        stats.wins++;
                    }
                });
            });
            
            // Convert to array and sort by win percentage (highest first)
            const sortedPlayers = Array.from(playerStats.entries()).map(([name, stats]) => ({
                name,
                played: stats.played,
                wins: stats.wins,
                percentage: stats.played > 0 ? ((stats.wins / stats.played) * 100).toFixed(1) : '0.0'
            })).sort((a, b) => {
                const aPercent = parseFloat(a.percentage);
                const bPercent = parseFloat(b.percentage);
                return bPercent - aPercent;
            });
            
            // Build HTML
            let html = `
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 15px; color: var(--text-primary); text-align: center;">Statistics</h4>
                    <table class="crowns-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 100px;">Player</th>
                                <th style="width: 60px; padding: 4px 8px;">Played</th>
                                <th style="width: 50px; padding: 4px 8px;">Wins</th>
                                <th style="width: 45px; padding: 4px 2px;">%</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            sortedPlayers.forEach(player => {
                html += `
                    <tr>
                        <td style="text-align: left;">
                            <input type="text" value="${escapeHtml(player.name)}" 
                                   class="wins-tracker-input" 
                                   onchange="updateCustomGamePlayerName('${escapeHtml(gameType)}', '${escapeHtml(player.name)}', this.value)"
                                   style="width: 100%; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                        </td>
                        <td style="padding: 4px 8px;">
                            <input type="number" value="${player.played}" 
                                   class="wins-tracker-input" 
                                   inputmode="numeric"
                                   onchange="updateCustomGameStat('${escapeHtml(gameType)}', '${escapeHtml(player.name)}', 'played', this.value)"
                                   style="width: 44px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                        </td>
                        <td style="padding: 4px 8px;">
                            <input type="number" value="${player.wins}" 
                                   class="wins-tracker-input" 
                                   inputmode="numeric"
                                   onchange="updateCustomGameStat('${escapeHtml(gameType)}', '${escapeHtml(player.name)}', 'wins', this.value)"
                                   style="width: 34px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                        </td>
                        <td style="font-weight: 700; color: var(--neon-blue); padding: 4px 2px; text-align: center;">${player.percentage}%</td>
                        <td style="text-align: center;">
                            <button class="delete-btn" onclick="deleteCustomGamePlayerStats('${escapeHtml(gameType)}', '${escapeHtml(player.name)}')" style="width: 36px; height: 36px; font-size: 1.1rem;"></button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        async function deleteCustomGamePlayerStats(gameType, playerName) {
            const confirmed = await customConfirm(
                `Delete all ${gameType} games for ${playerName}?\n\nThis will permanently remove their statistics and game records.`,
                ' Delete Player Stats'
            );
            
            if (confirmed) {
                // Get all custom games
                const customGames = loadCustomGameRecords();
                
                // Filter out games where this player participated in this game type
                const filteredGames = customGames.filter(game => 
                    !(game.gameType === gameType && game.players.some(p => p.name === playerName))
                );
                
                // Save filtered games back
                localStorage.setItem('scorekeeper_custom_games', JSON.stringify(filteredGames));
                
                // Update wins tracking
                const gameTypeKey = gameType.toLowerCase().replace(/\s+/g, '');
                const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
                
                if (winsData[gameTypeKey] && winsData[gameTypeKey][playerName]) {
                    delete winsData[gameTypeKey][playerName];
                    
                    // Remove game type if no players left
                    if (Object.keys(winsData[gameTypeKey]).length === 0) {
                        delete winsData[gameTypeKey];
                    }
                    
                    localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
                }
                
                // Refresh display
                displayCustomGameStatistics(gameType);
                
                await customAlert(`${playerName}'s ${gameType} statistics deleted successfully.`, ' Player Stats Deleted');
            }
        }
        
        function normalizeGameType(gameType) {
            // Normalize game type: trim, capitalize first letter of each word, remove extra punctuation
            return gameType.trim()
                .toLowerCase()
                .replace(/[^\w\s]/g, '') // Remove punctuation except letters, numbers, spaces
                .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function normalizePlayerName(playerName) {
            // Normalize player name: trim and capitalize first letter of each word
            return playerName.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function updateCustomGamePlayerName(gameType, oldPlayerName, newPlayerName) {
            const normalizedNewName = normalizePlayerName(newPlayerName);
            
            if (!normalizedNewName || normalizedNewName === oldPlayerName) {
                return; // No change needed
            }
            
            // Get all custom games
            const customGames = loadCustomGameRecords();
            let gamesUpdated = 0;
            
            // Update player names in games of this type
            customGames.forEach(game => {
                if (game.gameType === gameType) {
                    // Update in players array
                    game.players.forEach(player => {
                        if (player.name === oldPlayerName) {
                            player.name = normalizedNewName;
                            gamesUpdated++;
                        }
                    });
                    
                    // Update winner if it matches
                    if (game.winner === oldPlayerName) {
                        game.winner = normalizedNewName;
                    }
                }
            });
            
            // Save updated games
            localStorage.setItem('scorekeeper_custom_games', JSON.stringify(customGames));
            
            // Update wins tracking data
            const gameTypeKey = gameType.toLowerCase().replace(/\s+/g, '');
            const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
            
            if (winsData[gameTypeKey] && winsData[gameTypeKey][oldPlayerName]) {
                // Move data from old name to new name
                winsData[gameTypeKey][normalizedNewName] = winsData[gameTypeKey][oldPlayerName];
                delete winsData[gameTypeKey][oldPlayerName];
                localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
            }
            
            // Refresh display
            displayCustomGameStatistics(gameType);
        }
        
        function updateCustomGameStat(gameType, playerName, statType, newValue) {
            const value = parseInt(newValue) || 0;
            
            if (value < 0) return; // Don't allow negative values
            
            const gameTypeKey = gameType.toLowerCase().replace(/\s+/g, '');
            const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
            
            // Ensure structure exists
            if (!winsData[gameTypeKey]) winsData[gameTypeKey] = {};
            if (!winsData[gameTypeKey][playerName]) winsData[gameTypeKey][playerName] = { played: 0, wins: 0 };
            
            // Update the stat
            winsData[gameTypeKey][playerName][statType] = value;
            
            // If wins > played, adjust played to match wins
            if (statType === 'wins' && value > winsData[gameTypeKey][playerName].played) {
                winsData[gameTypeKey][playerName].played = value;
            }
            
            // If played < wins, adjust wins to match played
            if (statType === 'played' && value < winsData[gameTypeKey][playerName].wins) {
                winsData[gameTypeKey][playerName].wins = value;
            }
            
            // Save updated data
            localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
            
            // Refresh display to show updated percentages
            displayCustomGameStatistics(gameType);
        }
        
        function initializeCustomGameTracking() {
            // Add event delegation for custom player inputs
            document.addEventListener('input', function(e) {
                if (e.target.classList && e.target.classList.contains('custom-player-input')) {
                    updateCustomGameWinnerOptions();
                }
            });
        }
        
        // Allow Enter key to add more player fields from any input field
        ['playerNameInput1', 'playerNameInput2', 'playerNameInput3', 'playerNameInput4'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        addMorePlayerFields();
                    }
                });
            }
        });
        // Initialize on startup - wrap in DOMContentLoaded to ensure DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log(' Scorekeeper with Darts loaded successfully');
            initSpeechRecognition();
            loadPlayers();
            loadPlayerInputs(); // Load saved player input values
            loadTheme();
            loadSpeakerState(); // Load speaker mute state
            loadInputMode();
            loadGolfMode();
            loadGolfData();
            loadYahtzeeData();
            loadPhase10Data();
            loadGenericGridData();
            
            // Initialize custom game tracking
            initializeCustomGameTracking();
            loadSavedGolfCourses();
            populateHamburgerScorecardDropdown(); // Load saved scorecards into hamburger menu dropdown
            
            // Add event listeners to save player inputs when they change
            ['playerNameInput1', 'playerNameInput2', 'playerNameInput3', 'playerNameInput4'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', savePlayerInputs);
                    input.addEventListener('blur', savePlayerInputs);
                }
            });
            
            // Add beforeunload check to see if data persists
            window.addEventListener('beforeunload', function(e) {
                const saved = sessionStorage.getItem('scorekeeper_player_inputs');
                console.log('=== BEFORE UNLOAD ===');
                console.log('Player inputs in sessionStorage:', saved);
                console.log('All sessionStorage keys:', Object.keys(sessionStorage));
            });
            
            // Add pulse animation to Start Game button on initial load
            const gameStateBtn = document.getElementById('gameStateBtn');
            if (gameStateBtn && !gameInProgress) {
                gameStateBtn.classList.add('pulse');
            }
            
            // Set grid-mode class if players exist and done adding
            if (isDoneAdding && players.length > 0) {
                document.body.classList.add('grid-mode');
                
                // Move game-type-row into tab-navigation-container
                const gameTypeRow = document.querySelector('.game-type-row');
                const tabNavContainer = document.querySelector('.tab-navigation-container');
                if (gameTypeRow && tabNavContainer) {
                    tabNavContainer.insertBefore(gameTypeRow, tabNavContainer.firstChild);
                }
            }
            
            // If no players and speaker is on, ask for game type
            if (players.length === 0 && !isSpeakerMuted && !hasAskedGameType) {
                // Small delay to ensure everything is initialized
                setTimeout(() => {
                    askForGameType();
                }, 500);
            }
            
            // Setup golf mode toggle event listener
            const golfModeToggle = document.getElementById('golfModeToggle');
            if (golfModeToggle) {
                golfModeToggle.addEventListener('change', function(e) {
                    toggleGolfMode();
                });
            }
            
            // Initialize generic grid data but don't display it on page load
            // (It will show when a game type is selected)
            initializeGenericGridScores();
            
            // Initialize the display for the default 'general' game type
            // This will show the instructions panel
            console.log('Initializing default game type display: general');
            changeGameType();
            
            // Ensure instructions are shown on initial load
            updateStandardModeDisplay();
            // Setup golf course dropdown event listener
            // NOTE: Using inline onclick instead of addEventListener due to event listener issues
            /*
            console.log('About to setup golf course dropdown event listener');
            const golfCourseDropdown = document.getElementById('golfCourseDropdown');
            console.log('golfCourseDropdown element:', golfCourseDropdown);
            if (golfCourseDropdown) {
                console.log('Golf course dropdown found, attaching event listener');
                golfCourseDropdown.addEventListener('click', function(e) {
                    console.log('Golf course dropdown clicked!');
                    e.preventDefault();
                    e.stopPropagation();
                    toggleGolfCourseDropdown();
                });
            } else {
                console.log('Golf course dropdown NOT found during DOMContentLoaded');
            }
            */
            
            // Setup game type dropdown event listener
            // NOTE: Using inline onclick instead of addEventListener
            /*
            const gameTypeDropdown = document.getElementById('gameTypeDropdown');
            if (gameTypeDropdown) {
                gameTypeDropdown.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleGameTypeDropdown();
                });
            }
            
            // Setup game type dropdown list items
            const gameTypeItems = document.querySelectorAll('.dropdown-list-item-game');
            gameTypeItems.forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const gameValue = this.getAttribute('data-value');
                    selectGameType(gameValue);
                });
            });
            */
            
            // Hamburger menu and overlay use inline onclick handlers
            // No additional event listeners needed
            // Setup modal background click handlers for closing
            const finalScoresModal = document.getElementById('finalScoresModal');
            if (finalScoresModal) {
                finalScoresModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeFinalScoresModal();
                    }
                });
            }
            const editCourseModal = document.getElementById('editCourseModal');
            if (editCourseModal) {
                editCourseModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeEditCourseModal();
                    }
                });
            }
        });
        // Close modals with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close custom alert if open
                const alertModal = document.getElementById('customAlertModal');
                if (alertModal && alertModal.classList.contains('show')) {
                    closeCustomAlert();
                    return;
                }
                // Close custom confirm if open
                const confirmModal = document.getElementById('customConfirmModal');
                if (confirmModal && confirmModal.classList.contains('show')) {
                    resolveCustomConfirm(false);
                    return;
                }
                // Close custom prompt if open
                const promptModal = document.getElementById('customPromptModal');
                if (promptModal && promptModal.classList.contains('show')) {
                    resolveCustomPrompt(null);
                    return;
                }
                // Close edit course modal if open
                const editCourseModal = document.getElementById('editCourseModal');
                if (editCourseModal && editCourseModal.classList.contains('show')) {
                    closeEditCourseModal();
                    return;
                }
                // Close final scores modal if open
                const finalModal = document.getElementById('finalScoresModal');
                if (finalModal && finalModal.classList.contains('show')) {
                    closeFinalScoresModal();
                    return;
                }
            }
        });
    </script>
    <!-- Custom Modal for Final Scores -->
    <div id="finalScoresModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title">Final Scores</div>
            <div id="finalScoresWinner" class="final-scores-winner"></div>
            <ol id="finalScoresList" class="final-scores-list"></ol>
            <button class="final-scores-ok-btn" onclick="closeFinalScoresModal()">OK</button>
        </div>
    </div>
    <!-- Custom Alert Modal -->
    <div id="customAlertModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="customAlertTitle">Alert</div>
            <div id="customAlertMessage" class="custom-dialog-message"></div>
            <button class="final-scores-ok-btn" onclick="closeCustomAlert()">OK</button>
        </div>
    </div>
    <!-- Custom Confirm Modal -->
    <div id="customConfirmModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="customConfirmTitle">Confirm</div>
            <div id="customConfirmMessage" class="custom-dialog-message"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveCustomConfirm(false)">Cancel</button>
                <button class="final-scores-ok-btn" onclick="resolveCustomConfirm(true)">OK</button>
            </div>
        </div>
    </div>
    
    <!-- Golf Scorecard Save Modal (with Notes) -->
    <div id="golfScorecardSaveModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="golfScorecardSaveTitle">Game Complete!</div>
            <div id="golfScorecardSaveMessage" class="custom-dialog-message"></div>
            <div id="golfScorecardNotesSection" style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">Notes:</label>
                <textarea id="golfScorecardNotesInput" class="custom-prompt-input" style="min-height: 100px; resize: vertical; font-family: Outfit, sans-serif;" placeholder="Add notes about this round..."></textarea>
            </div>
            
            <!-- Save Options -->
            <div class="save-options-container">
                <div class="save-options-row">
                    <span class="save-options-label">Saved Data:</span>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveWinLoss" class="game-header-checkbox" checked>
                        <label for="saveWinLoss">Track Wins</label>
                    </div>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveScorecard" class="game-header-checkbox">
                        <label for="saveScorecard">Full Scorecard</label>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveGolfScorecardSave('cancel')">Close</button>
                <button class="final-scores-ok-btn" onclick="resolveGolfScorecardSave('save')">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Universal Game Completion Modal (for all games) -->
    <div id="gameCompletionModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="gameCompletionTitle">Game Complete!</div>
            <div id="gameCompletionMessage" class="custom-dialog-message"></div>
            <div id="gameCompletionNotesSection" style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">Notes:</label>
                <textarea id="gameCompletionNotesInput" class="custom-prompt-input" style="min-height: 100px; resize: vertical; font-family: Outfit, sans-serif;" placeholder="Add notes about this game..."></textarea>
            </div>
            
            <!-- Save Options -->
            <div class="save-options-container">
                <div class="save-options-row">
                    <span class="save-options-label">Saved Data:</span>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveWinLossGeneral" class="game-header-checkbox" checked>
                        <label for="saveWinLossGeneral">Track Wins</label>
                    </div>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveScorecardGeneral" class="game-header-checkbox">
                        <label for="saveScorecardGeneral">Full Scorecard</label>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveGameCompletion('cancel')">Close</button>
                <button class="final-scores-ok-btn" onclick="resolveGameCompletion('save')">Save</button>
            </div>
        </div>
    </div>
    <!-- Custom Prompt Modal -->
    <div id="customPromptModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="customPromptTitle">Input</div>
            <div id="customPromptMessage" class="custom-dialog-message"></div>
            <input type="text" id="customPromptInput" class="custom-prompt-input">
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveCustomPrompt(null)">Cancel</button>
                <button class="final-scores-ok-btn" onclick="resolveCustomPrompt(document.getElementById('customPromptInput').value)">OK</button>
            </div>
        </div>
    </div>
    <!-- Edit Golf Course Modal -->
    <div id="editCourseModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Edit Course</div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 700; color: var(--text-primary);">Course Name:</label>
                <input type="text" id="editCourseName" class="custom-prompt-input" style="margin-top: 0;">
            </div>
            
            <div style="margin-bottom: 20px; max-height: calc(85vh - 200px); overflow-y: auto;">
                <div style="font-weight: 700; margin-bottom: 10px; color: var(--text-primary);">Add or Edit Par, Handicap, and Yardage Values<br>Click on the colour label names to edit.</div>
                <div id="editCourseGrid" class="edit-course-grid"></div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeEditCourseModal()">Cancel</button>
                <button class="final-scores-ok-btn" onclick="saveEditedCourse()">Save changes</button>
            </div>
        </div>
    </div>
    
    <!-- Saved Scorecards Modal -->
    <div id="savedScorecardsModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Saved Golf Scorecard</div>
            <div id="scorecardDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Scorecard details will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeSavedScorecardsModal()">Close</button>
                <button class="final-scores-ok-btn" onclick="deleteCurrentScorecard()" id="deleteScorecardBtn">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Wins Tracker Modal -->
    <div id="winsTrackerModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title" id="winsTrackerTitle">Wins Tracker</div>
            <div id="winsTrackerDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Wins tracker stats will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="deleteAllScorecardsBtn" class="final-scores-ok-btn" onclick="window.deleteAllGameScorecards('golf')" style="display: none;">Delete All</button>
                <button class="final-scores-ok-btn" onclick="closeWinsTrackerModal()">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Game Statistics Modal -->
    <div id="customGameStatisticsModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title" id="customGameStatisticsTitle">Game Statistics</div>
            <div id="customGameStatisticsDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Custom game statistics will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeCustomGameStatistics()" style="flex: 1;">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Games Viewer Modal -->
    <div id="customGamesViewerModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Custom Games</div>
            <div id="customGamesDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Custom games list will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeCustomGamesViewer()" style="flex: 1;">Close</button>
                <button class="final-scores-ok-btn" onclick="openCustomGameTrackingModal(); closeCustomGamesViewer();" style="flex: 1;">Add New Game</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Game Tracking Modal -->
    <div id="customGameTrackingModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Custom Game Tracking</div>
            <div style="margin-bottom: 10px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                
                <!-- Game Type Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.9rem;">Game Type:</label>
                    <input type="text" id="customGameType" placeholder="e.g. Chess, Backgammon, Cribbage" maxlength="30" 
                           style="width: 100%; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease;">
                </div>
                
                <!-- Date Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.9rem;">Date:</label>
                    <input type="date" id="customGameDate" 
                           style="width: 100%; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease;">
                </div>
                
                <!-- Players Section -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.9rem;">Players:</label>
                    <div id="customGamePlayersContainer">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                            <input type="text" class="custom-player-input" placeholder="Player 1" maxlength="20" 
                                   style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                            <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                                   style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                            <input type="text" class="custom-player-input" placeholder="Player 2" maxlength="20" 
                                   style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                            <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                                   style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                        </div>
                    </div>
                    <button class="final-scores-ok-btn" onclick="addCustomGamePlayer()" style="padding: 8px 16px; margin-bottom: 15px; font-weight: 700;">Add More Players</button>
                </div>
                
                <!-- Winner Selection -->
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.9rem;">Winner:</label>
                    <select id="customGameWinner" style="width: 100%; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease;">
                        <option value="">Select Winner</option>
                    </select>
                </div>
                
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeCustomGameTrackingModal()" style="flex: 1;">Cancel</button>
                <button class="final-scores-ok-btn" onclick="saveCustomGame()" style="flex: 1;">Save Game</button>
            </div>
        </div>
    </div>
</body>
</html>
