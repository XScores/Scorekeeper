<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScoreKeeper">
    <title>ScoreKeeper</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Mono+One&family=Outfit:wght@300;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --neon-pink: #ff006e;
            --neon-blue: #00f5ff;
            --neon-yellow: #ffbe0b;
            --neon-green: #39ff14;
            --dark-bg: #0a0e27;
            --card-bg: #151b3d;
            --text-primary: #ffffff;
            --text-dim: #8892b0;
            --modal-overlay-bg: rgba(0, 0, 0, 0.85);
        }
        
        /* Stainless Steel Theme - Based on metallic UI kit */
        body[data-theme="stainless"] {
            --neon-pink: #718096;
            --neon-blue: #a0aec0;
            --neon-yellow: #cbd5e0;
            --neon-green: #90a4ae;
            --dark-bg: linear-gradient(180deg, #d0d5db 0%, #9ca3af 50%, #b0b8c0 100%);
            --card-bg: #e2e8f0;
            --text-primary: #2d3748;
            --text-dim: #718096;
            --modal-overlay-bg: rgba(0, 0, 0, 0.6);
        }
        
        body[data-theme="stainless"] {
            background: linear-gradient(180deg, #d0d5db 0%, #9ca3af 50%, #b0b8c0 100%);
        }
        
        body[data-theme="stainless"]::before {
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.15) 0%, transparent 40%),
                linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
        }
        
        /* Stainless Steel - Metallic button effects with radial gradient */
        body[data-theme="stainless"] .tab-btn,
        body[data-theme="stainless"] .voice-btn,
        body[data-theme="stainless"] button {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            color: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.25),
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        body[data-theme="stainless"] .tab-btn.active,
        body[data-theme="stainless"] .voice-btn.listening {
            background: radial-gradient(circle at 30% 30%, #90caf9, #64b5f6);
            color: #1e3a5f;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 1px 2px rgba(255, 255, 255, 0.5),
                0 0 15px rgba(144, 202, 249, 0.4);
        }
        
        body[data-theme="stainless"] .voice-btn.manual-mode-inactive {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }
        body[data-theme="stainless"] .voice-btn:not(.manual-mode-inactive):hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.4);
        }
        body[data-theme="stainless"] button:hover {
            transform: translateY(-2px);
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.4);
        }
        body[data-theme="stainless"] .mic-icon {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-btn:hover .mic-icon {
            color: #1a202c;
        }
        body[data-theme="stainless"] .voice-btn.listening .mic-icon {
            animation: blinkRedStainless 0.8s ease-in-out infinite;
        }
        @keyframes blinkRedStainless {
            0%, 100% { 
                color: #c53030;
                filter: drop-shadow(0 0 6px rgba(197, 48, 48, 0.6));
            }
            50% { 
                color: #1e3a5f;
                filter: drop-shadow(0 0 8px rgba(30, 58, 95, 0.6));
            }
        }
        
        body[data-theme="stainless"] .speaker-icon {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-btn:hover .speaker-icon {
            color: #1a202c;
        }
        
        body[data-theme="stainless"] .tab-btn:not(.active) {
            background: radial-gradient(circle at 30% 30%, #cbd5e0, #a0aec0);
        }
        
        body[data-theme="stainless"] .tab-btn:not(.active):hover {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
        }
        
        body[data-theme="stainless"] .crowns-table th {
            background: radial-gradient(circle at 30% 30%, #cbd5e0, #a0aec0);
            color: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2),
                0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        body[data-theme="stainless"] .crowns-table td {
            background: rgba(226, 232, 240, 0.5);
            color: #2d3748;
            border: 1px solid rgba(160, 174, 192, 0.3);
        }
        
        body[data-theme="stainless"] .crowns-table .round-label {
            background: rgba(0, 0, 0, 0.15) !important;
        }
        
        body[data-theme="stainless"] .card,
        body[data-theme="stainless"] .side-menu,
        body[data-theme="stainless"] .tab-navigation {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        body[data-theme="stainless"] #gameStateBtn {
            background: radial-gradient(circle at 30% 30%, #81c784, #66bb6a) !important;
            color: #1b5e20 !important;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.6),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }
        body[data-theme="stainless"] #gameStateBtn:hover {
            background: radial-gradient(circle at 30% 30%, #a5d6a7, #81c784) !important;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        body[data-theme="stainless"] .start-button-container {
            background: linear-gradient(to top, rgba(160, 174, 192, 0.8) 0%, transparent);
        }
        
        /* Metallic input fields */
        body[data-theme="stainless"] input[type="text"],
        body[data-theme="stainless"] input[type="number"],
        body[data-theme="stainless"] select {
            background: radial-gradient(circle at 50% 0%, #f7fafc, #e2e8f0);
            color: #2d3748;
            border: 1px solid #a0aec0;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        body[data-theme="stainless"] .hamburger-line {
            background: #4a5568;
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        body[data-theme="stainless"] .hamburger-btn {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.25),
                0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Engraved/carved text effect for Stainless Steel */
        body[data-theme="stainless"] h1 {
            background: none;
            -webkit-background-clip: initial;
            -webkit-text-fill-color: initial;
            background-clip: initial;
            color: #4a5568;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.8),     /* White highlight below */
                0 -1px 0 rgba(0, 0, 0, 0.4),          /* Dark shadow above */
                1px 1px 2px rgba(0, 0, 0, 0.2);       /* Subtle depth */
        }
        
        body[data-theme="stainless"] .subtitle {
            color: #718096;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }
        
        /* Fix placeholder text contrast in Stainless Steel */
        body[data-theme="stainless"] input[type="text"]::placeholder {
            color: #4a5568; /* Dark gray - same as carved text */
            opacity: 1;
        }
        
        body {
            font-family: Outfit, sans-serif;
            background: var(--dark-bg);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
            padding-bottom: 90px;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 0, 110, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 245, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 190, 11, 0.1) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
        }
        /* Landscape Mode Optimizations */
        @media screen and (orientation: landscape) and (max-height: 600px) {
            /* Compact header in landscape */
            .header h1 {
                font-size: 1.5rem !important;
                margin: 8px 0 !important;
            }
            
            /* Smaller instructions panel */
            #standardModeInstructions {
                padding: 10px 15px !important;
                font-size: 0.85rem !important;
                margin: 5px 0 !important;
            }
            
            /* Compact game mode containers */
            .crowns-mode, .standard-mode {
                padding: 5px !important;
            }
            
            /* Smaller button heights */
            .start-button-container button {
                padding: 8px 16px !important;
                font-size: 0.95rem !important;
                margin: 0 5px !important;
            }
            
            /* Optimize table layouts for landscape */
            .crowns-table, .golf-table {
                font-size: 0.85rem !important;
            }
            
            .crowns-table th, .crowns-table td {
                padding: 4px 6px !important;
            }
            
            /* Compact player input section */
            .add-player-section {
                margin: 5px 0 !important;
            }
            
            .add-player-section input {
                padding: 6px 8px !important;
                font-size: 0.95rem !important;
            }
            
            /* Navigation optimizations */
            .menu-button {
                width: 35px !important;
                height: 35px !important;
                font-size: 1.2rem !important;
            }
            
            /* Course selector compacting */
            .golf-course-selector {
                margin: 5px 0 !important;
            }
            
            /* Scrabble grid optimizations */
            #scrabbleButtons {
                gap: 5px !important;
            }
            
            #scrabbleButtons > div {
                gap: 5px !important;
            }
            
            #scrabbleButtons button, #scrabbleWordChecker button, #scrabbleGoBtn {
                padding: 4px 8px !important;
                font-size: 0.85rem !important;
            }
            
            /* Override for compact Go button in word checker area */
            #scrabbleWordChecker #scrabbleGoBtn {
                padding: 0 !important;
                font-size: 1.2rem !important;
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                max-width: 40px !important;
                flex: none !important;
                flex-shrink: 0 !important;
                flex-grow: 0 !important;
                flex-basis: 40px !important;
            }
            
            /* Left align timer dropdown list items and position list correctly */
            #scrabbleWordChecker #scrabbleTimerDropdownList .dropdown-list-item-theme {
                text-align: left !important;
                padding: 10px 12px !important;
                justify-content: flex-start !important;
                display: flex !important;
                align-items: center !important;
            }
            
            /* Position dropdown list to align with input field above - now both labels are same width */
            #scrabbleWordChecker #scrabbleTimerDropdownList {
                left: 0 !important; /* Both labels now same width, so no offset needed */
                width: 150px !important; /* Match input field width */
                text-align: left !important;
                z-index: 2000 !important; /* Very high to ensure it appears above everything */
                position: absolute !important; /* Ensure it doesn't affect layout */
                box-sizing: border-box !important;
                top: 100% !important; /* Position directly under the dropdown button */
            }
            
            /* Left align the selected text in timer dropdown */
            #scrabbleTimerDropdown .dropdown-selected {
                text-align: left !important;
                justify-self: flex-start !important;
            }
            
            /* Left align the entire timer dropdown */
            #scrabbleTimerDropdown {
                text-align: left !important;
                justify-content: space-between !important;
            }
            
            #scrabbleWordChecker {
                margin-bottom: 8px !important;
            }
            
            #scrabbleWordInput {
                width: 100px !important;
                padding: 4px 6px !important;
                font-size: 0.85rem !important;
            }
            
            /* Voice feedback positioning */
            .voice-feedback {
                top: 10px !important;
                right: 10px !important;
                max-width: 250px !important;
                padding: 8px 12px !important;
            }
        }
        
        /* Wider landscape tablets (iPad, etc.) */
        @media screen and (orientation: landscape) and (min-width: 768px) {
            /* Two-column layout for wider screens */
            .standard-mode {
                display: flex !important;
                flex-direction: row !important;
                gap: 20px !important;
            }
            
            #standardModeInstructions {
                flex: 1 !important;
                min-width: 300px !important;
            }
            
            .add-player-section {
                flex: 1 !important;
                min-width: 300px !important;
            }
            
            /* Side-by-side game tables */
            .crowns-container, .golf-container {
                max-width: none !important;
                display: flex !important;
                flex-direction: row !important;
                gap: 15px !important;
            }
            
            .crowns-table, .golf-table {
                max-width: 50% !important;
                margin: 0 !important;
            }
            
            /* Start button container with more space on landscape */
            .start-button-container {
                padding: 15px 50px !important;
            }
        }
        
        /* Ultra-wide landscape displays */
        @media screen and (orientation: landscape) and (min-width: 1024px) {
            .container {
                max-width: 1200px !important;
                margin: 0 auto !important;
                padding: 0 20px !important;
            }
            
            /* Three-column layout for instructions, players, and controls */
            .standard-mode {
                display: grid !important;
                grid-template-columns: 1fr 1fr 200px !important;
                gap: 30px !important;
            }
            
            /* Larger game tables with better spacing */
            .crowns-table, .golf-table, .scrabble-table, .yahtzee-table {
                font-size: 1.2rem !important;
            }
            
            .crowns-table th, .crowns-table td {
                padding: 8px 10px !important;
            }
        }
        
        .container {
            max-width: 414px;
            margin: 0 auto;
            padding: 16px;
            position: relative;
            z-index: 1;
        }
        header {
            text-align: left;
            padding: 16px 0 16px 0;
            animation: slideDown 0.6s ease-out;
            position: relative;
            overflow: visible;
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .hamburger-btn {
            position: absolute;
            top: 16px;
            right: 0;
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
            z-index: 10002;
            pointer-events: auto;
        }
        .hamburger-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }
        .hamburger-btn.active {
            border-color: var(--neon-pink);
        }
        /* Custom Modal for Final Scores */
        .final-scores-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay-bg);
            z-index: 10000;
            justify-content: center;
            align-items: flex-start; /* Align to top instead of center */
            padding-top: 20px; /* Add top padding for spacing */
            animation: fadeIn 0.3s ease-out;
        }
        
        .final-scores-modal.show {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .final-scores-content {
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 16px;
            padding: 20px;
            max-width: min(95vw, 414px); /* Constrain to iPhone XS Max width */
            width: calc(100vw - 20px); /* Reduce margins for more space */
            max-height: 90vh; /* Use most of the viewport height */
            height: auto; /* Allow dynamic height based on content */
            overflow-y: auto; /* Enable vertical scrolling if needed */
            box-sizing: border-box;
            margin: 10px; /* Small margin from edges */
            min-width: 280px; /* Minimum width for readability */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.4s ease-out;
        }
        
        /* Stainless theme modal content - metallic steel look */
        body[data-theme="stainless"] .final-scores-content {
            background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e0 100%);
            border: 3px solid #94a3b8;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        
        /* WCAG compliant Instructions panel styling */
        #standardModeInstructions {
            background: rgba(255, 255, 255, 0.95) !important;
            color: #2d3748 !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }
        
        #standardModeInstructions strong {
            color: #1a202c !important;
        }
        
        /* Stainless theme adjustments for Instructions panel */
        body[data-theme="stainless"] #standardModeInstructions {
            background: rgba(248, 250, 252, 0.98) !important;
            color: #1a365d !important;
            border: 1px solid rgba(45, 55, 72, 0.15) !important;
        }
        
        body[data-theme="stainless"] #standardModeInstructions strong {
            color: #0f2132 !important;
        }
        
        /* Custom Game Tracking Modal - Higher z-index to appear above hamburger menu */
        #winsTrackerDropdownList {
            -webkit-overflow-scrolling: touch;
        }
        #winsTrackerDropdownList.open {
            max-height: 450px;
            overflow-y: auto;
        }

        /* Normalize all input/select/date fields in custom game modal for iOS Safari */
        .custom-game-field {
            width: 100%;
            padding: 8px 10px;
            height: 38px;
            min-height: 38px;
            box-sizing: border-box;
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-weight: 400;
            font-size: 0.85rem;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.2);
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            display: block;
            line-height: normal;
        }
        
        /* Custom Game Tracking Modal - Higher z-index to appear above hamburger menu */
        #customGameTrackingModal {
            z-index: 10015 !important;
        }

        /* Custom Games Viewer Modal - Higher z-index to appear above hamburger menu */
        #customGamesViewerModal {
            z-index: 10010 !important;
        }
        
        /* Custom Game Statistics Modal - Higher z-index to appear above hamburger menu */
        #customGameStatisticsModal {
            z-index: 10010 !important;
        }
        
        /* Confirmation modals must appear above custom game modals */
        #customAlertModal,
        #customConfirmModal,
        #customPromptModal {
            z-index: 10020 !important;
        }
        
        /* iPhone-specific optimizations for scorecard viewing */
        @media (max-width: 428px) {
            .final-scores-modal {
                padding-top: 10px; /* Reduce top padding on small screens */
            }
            
            .final-scores-content {
                margin: 5px; /* Smaller margins for maximum space */
                padding: 15px; /* Slightly less padding */
                max-height: 92vh; /* Use even more of the viewport height */
                border-radius: 12px; /* Slightly smaller border radius */
            }
            
            #scorecardDisplay,
            #winsTrackerDisplay {
                max-height: calc(92vh - 110px) !important; /* Maximize content area */
                padding: 2px !important; /* Minimal padding */
            }
        }
            position: relative;
            box-sizing: border-box;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .final-scores-title {
            font-family: 'Rubik Mono One', monospace;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .final-scores-winner {
            font-family: 'Rubik Mono One', monospace;
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 25px;
            color: var(--neon-yellow);
            font-weight: 900;
            padding: 15px;
            background: rgba(255, 190, 11, 0.1);
            border-radius: 10px;
            border: 2px solid var(--neon-yellow);
        }
        
        .final-scores-list {
            list-style: none;
            padding: 0;
            margin: 0 0 25px 0;
        }
        
        .final-scores-list li {
            padding: 12px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: Outfit, sans-serif;
            font-size: 1.2rem;
            color: var(--text-primary);
            border-left: 4px solid var(--neon-blue);
        }
        
        .final-scores-list li:first-child {
            border-left-color: var(--neon-yellow);
            background: rgba(255, 190, 11, 0.05);
        }
        
        .final-scores-ok-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000000;
            border: none;
            border-radius: 12px;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            transition: all 0.3s ease;
        }
        
        .final-scores-ok-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
        }
        
        .final-scores-ok-btn:active {
            transform: translateY(0);
        }
        /* Golf Course Selection Modal */
        .course-list-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .course-list-container::-webkit-scrollbar {
            width: 8px;
        }
        .course-list-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        .course-list-container::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 4px;
        }
        .course-list-container::-webkit-scrollbar-thumb:hover {
            background: var(--neon-pink);
        }
        .course-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: #4a5568; /* High contrast dark grey for light background */
            font-family: Outfit, sans-serif;
            font-size: 1.2rem;
            background: rgba(248, 250, 252, 0.95); /* Light background */
            border-radius: 10px;
            border: 2px dashed #cbd5e0; /* Solid border for better visibility */
        }
        .course-list-empty-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        .course-item {
            padding: 15px;
            margin: 10px 0;
            background: rgba(248, 250, 252, 0.95); /* Light background */
            color: #2d3748; /* High contrast dark text */
            border-radius: 10px;
            border: 2px solid #cbd5e0; /* Visible border */
            transition: all 0.3s ease;
            font-family: Outfit, sans-serif;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .course-item:hover {
            background: rgba(237, 242, 247, 0.98); /* Slightly different light background on hover */
            border-color: #4a90e2; /* Blue border on hover */
        }
        .course-item-main {
            flex: 1;
            cursor: pointer;
            min-width: 0;
        }
        .course-item-main:hover {
            transform: translateX(5px);
        }
        .course-item-name {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 5px;
        }
        .course-item-details {
            font-size: 0.95rem;
            color: var(--text-dim);
        }
        .course-item-details span {
            margin-right: 15px;
        }
        .course-item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .course-action-btn {
            padding: 8px 12px;
            background: rgba(248, 250, 252, 0.95); /* Light background */
            color: #2d3748; /* High contrast dark text */
            border: 2px solid #cbd5e0; /* Visible border */
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }
        .course-action-btn:hover {
            transform: scale(1.1);
            background: rgba(237, 242, 247, 0.98); /* Slightly different light background */
        }
        .course-action-btn.edit-btn:hover {
            background: rgba(59, 130, 246, 0.1); /* Light blue background */
            border-color: #3b82f6; /* Blue border */
            color: #1e40af; /* Dark blue text */
        }
        .course-action-btn.delete-btn:hover {
            background: rgba(239, 68, 68, 0.1); /* Light red background */
            border-color: #ef4444; /* Red border */
            color: #b91c1c; /* Dark red text */
        }
        .course-action-btn-text {
            padding: 8px 16px;
            background: rgba(248, 250, 252, 0.95); /* Light background */
            border: 2px solid #cbd5e0; /* Visible border */
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            color: #2d3748; /* High contrast dark text */
        }
        .course-action-btn-text:hover {
            background: rgba(237, 242, 247, 0.98); /* Slightly different light background */
            border-color: #4a90e2; /* Blue border on hover */
            transform: translateY(-2px);
        }
        body[data-theme="stainless"] .course-list-empty {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(160, 174, 192, 0.4);
            color: #718096;
        }
        body[data-theme="stainless"] .course-item {
            background: rgba(255, 255, 255, 0.1);
            border-color: #cbd5e0;
        }
        body[data-theme="stainless"] .course-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .course-item-name {
            color: #2d3748;
        }
        body[data-theme="stainless"] .course-item-details {
            color: #718096;
        }
        body[data-theme="stainless"] .course-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border-color: #cbd5e0;
        }
        body[data-theme="stainless"] .course-action-btn.edit-btn:hover {
            background: rgba(160, 174, 192, 0.3);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .course-action-btn.delete-btn:hover {
            background: rgba(255, 0, 110, 0.15);
            border-color: #e53e3e;
        }
        body[data-theme="stainless"] .course-action-btn-text {
            background: rgba(255, 255, 255, 0.2);
            border-color: #cbd5e0;
            color: #2d3748;
        }
        body[data-theme="stainless"] .course-action-btn-text:hover {
            background: rgba(160, 174, 192, 0.3);
            border-color: #a0aec0;
        }
        /* Custom Dialog Styles */
        .custom-dialog-message {
            font-family: Outfit, sans-serif;
            font-size: 1.2rem;
            color: #1a365d; /* High contrast dark blue for light backgrounds */
            padding: 20px;
            margin: 10px 0;
            background: rgba(248, 250, 252, 0.95); /* Light background */
            border-radius: 10px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .custom-dialog-message strong {
            font-weight: 800;
            color: #1a202c; /* Even darker for strong emphasis */
        }
        /* Save options for Golf modal */
        .save-options-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .save-options-row {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .save-options-label {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 0.95rem;
            margin: 0;
        }
        
        .save-option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .save-option-item label {
            cursor: pointer;
            user-select: none;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        
        body[data-theme="stainless"] .save-options-container {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .wins-tracker-tab {
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .saved-scorecard-item {
            background: rgba(248, 250, 252, 0.95) !important; /* Light background */
            color: #2d3748 !important; /* High contrast dark text */
            border: 1px solid #cbd5e0 !important; /* Visible border */
        }
        
        .saved-scorecard-item:hover {
            background: rgba(237, 242, 247, 0.98) !important; /* Slightly different on hover */
            border-color: #4a90e2 !important; /* Blue border on hover */
            transform: translateX(5px);
        }
        
        body[data-theme="stainless"] .saved-scorecard-item {
            background: rgba(255, 255, 255, 0.98) !important; /* High opacity white background */
            color: #2d3748 !important; /* High contrast dark text */
            border: 1px solid #a0aec0 !important; /* Visible grey border */
        }
        
        body[data-theme="stainless"] .saved-scorecard-item:hover {
            background: rgba(240, 245, 251, 0.98) !important; /* Light blue background on hover */
            border-color: #64b5f6 !important; /* Blue border on hover */
        }
        
        .custom-prompt-input {
            width: 100%;
            padding: 12px 15px;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
        }
        .custom-prompt-input:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        body[data-theme="stainless"] .custom-dialog-message {
            background: rgba(255, 255, 255, 0.98); /* High opacity white background */
            color: #2d3748; /* High contrast dark text */
        }
        body[data-theme="stainless"] .custom-prompt-input {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .custom-prompt-input:focus {
            border-color: #a0aec0;
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.3);
        }
        /* Edit Course Grid */
        .edit-course-grid {
            display: grid;
            grid-template-columns: 40px repeat(6, 1fr);
            gap: 4px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
        }
        .edit-course-grid-header {
            font-weight: 700;
            color: var(--text-primary);
            padding: 6px 2px;
            text-align: center;
            font-size: 0.85rem;
        }
        .edit-course-grid-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 2px;
        }
        .edit-course-input {
            width: 100%;
            padding: 6px 4px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            text-align: center;
        }
        /* Hide number input spinner arrows */
        .edit-course-input::-webkit-outer-spin-button,
        .edit-course-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .edit-course-input[type=number] {
            -moz-appearance: textfield;
        }
        .edit-course-input:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: 0 0 8px rgba(0, 245, 255, 0.3);
        }
        body[data-theme="stainless"] .edit-course-grid {
            background: rgba(255, 255, 255, 0.1);
        }
        body[data-theme="stainless"] .edit-course-grid-header {
            color: #2d3748;
        }
        body[data-theme="stainless"] .edit-course-input {
            background: rgba(255, 255, 255, 0.3);
            border-color: #cbd5e0;
            color: #2d3748;
        }
        body[data-theme="stainless"] .edit-course-input:focus {
            border-color: #a0aec0;
            box-shadow: 0 0 8px rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .edit-yrd-name-input {
            background: rgba(255, 255, 255, 0.3) !important;
            border-color: #cbd5e0 !important;
            color: #2d3748 !important;
        }
        body[data-theme="stainless"] .edit-yrd-name-input:focus {
            border-color: #a0aec0 !important;
            box-shadow: 0 0 8px rgba(160, 174, 192, 0.3) !important;
        }
        
        /* Stainless Steel Theme */
        body[data-theme="stainless"] .final-scores-content {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            border: 2px solid #a0aec0;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        body[data-theme="stainless"] .final-scores-title {
            background: none;
            -webkit-background-clip: initial;
            -webkit-text-fill-color: initial;
            background-clip: initial;
            color: #4a5568;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.8),     /* White highlight below */
                0 -1px 0 rgba(0, 0, 0, 0.4),          /* Dark shadow above */
                1px 1px 2px rgba(0, 0, 0, 0.2);       /* Subtle depth */
        }
        
        body[data-theme="stainless"] .final-scores-winner {
            color: #2d3748;
            background: linear-gradient(135deg, #f4e4a6, #d4af37);
            border: 2px solid #b8941e;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.6),
                0 4px 8px rgba(212, 175, 55, 0.3);
        }
        
        body[data-theme="stainless"] .final-scores-list li {
            background: rgba(255, 255, 255, 0.2);
            color: #2d3748;
            border-left-color: #718096;
        }
        
        body[data-theme="stainless"] .final-scores-list li:first-child {
            border-left-color: #d4af37;
            background: rgba(244, 228, 166, 0.2);
        }
        
        body[data-theme="stainless"] .final-scores-ok-btn {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            color: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.25),
                0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        body[data-theme="stainless"] .final-scores-ok-btn:hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.9),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .hamburger-line {
            width: 24px;
            height: 3px;
            background: #000000;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        .hamburger-btn.active .hamburger-line:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        .hamburger-btn.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        .hamburger-btn.active .hamburger-line:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.9);
            backdrop-filter: blur(5px);
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .side-menu {
            position: fixed;
            top: 0;
            right: -320px;
            width: 320px;
            max-width: 85%;
            height: 100%;
            background: var(--card-bg);
            border-left: 3px solid var(--neon-blue);
            z-index: 10001;
            padding: 80px 20px 20px 20px;
            overflow-y: auto;
            transition: right 0.3s ease;
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.9);
        }
        .side-menu.active {
            right: 0 !important;
        }
        .menu-section {
            margin-bottom: 30px;
        }
        .menu-section-title {
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
            text-align: left;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        h1 {
            font-family: 'Rubik Mono One', monospace;
            font-size: 1.2rem;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 0, 110, 0.5);
            line-height: 1.3;
            display: block;
        }
        /* iPhone XS Max specific optimizations */
        @media (max-width: 414px) {
            h1 {
                font-size: 1.2rem;
                letter-spacing: 1px;
            }
            .score-number {
                font-size: 1.85rem;
                min-width: 45px;
            }
            .player-name {
                font-size: 1.2rem;
                padding: 6px 10px;
            }
            .control-btn {
                width: 42px;
                height: 42px;
                font-size: 1.2rem;
            }
            .delete-btn {
                width: 42px;
                height: 42px;
            }
            button {
                font-size: 0.95rem;
                padding: 11px 14px;
            }
            .tab-btn {
                font-size: 0.85rem;
                padding: 10px 12px;
            }
            input[type="text"] {
                font-size: 0.95rem;
                padding: 10px 12px;
            }
            .game-type-select {
                font-size: 0.95rem;
                padding: 14px 18px;
                padding-right: 38px;
            }
            .crowns-table th,
            .crowns-table td {
                padding: 5px 6px;
                min-width: 45px;
                font-size: 0.85rem;
            }
            .crowns-table th {
                font-size: 0.85rem;
            }
            .crowns-table .round-label {
                min-width: 30px;
                padding: 5px 3px;
                font-size: 0.85rem;
            }
        }
        @media (max-width: 400px) {
            h1 {
                font-size: 1.2rem;
                letter-spacing: 1px;
            }
            .score-number {
                font-size: 1.75rem;
            }
        }
        .subtitle {
            display: none;
        }
        .game-type-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .settings-row {
            display: none;
        }
        /* Old game-type styles removed - now using custom dropdown */
        .add-player-section {
            margin: 0 0 10px 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        input[type="text"] {
            flex: 1;
            padding: 10px 14px;
            background: var(--card-bg);
            border: 2px solid transparent;
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: Outfit, sans-serif;
            font-weight: 300;
            transition: all 0.3s ease;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.3);
        }
        input[type="text"]::placeholder {
            color: #5f6a7c; /* 30% darker than var(--text-dim) #8892b0 */
        }
        button {
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border: none;
            border-radius: 12px;
            color: black;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            position: relative;
            overflow: hidden;
            min-height: 44px;
        }
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        button:active::before {
            width: 300px;
            height: 300px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
        }
        button:active {
            transform: scale(0.95);
        }
        .btn-secondary {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .players-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 16px 0;
        }
        .player-card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 14px 16px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            animation: scaleIn 0.4s ease-out both;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--neon-pink), var(--neon-blue), var(--neon-yellow));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .player-card:active::before {
            opacity: 1;
        }
        .player-name {
            flex: 1;
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background 0.3s ease;
        }
        .player-name:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .player-name-input {
            flex: 1;
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            padding: 8px 12px;
            font-family: Outfit, sans-serif;
            outline: none;
        }
        /* When player-name-input is inside a table header, override flex */
        th .player-name-input {
            flex: none;
            width: auto;
            max-width: 100px;
            font-size: 0.95rem;
            padding: 4px 8px;
        }
        .player-name-text {
            cursor: pointer;
            display: inline-block;
        }
        .score-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .score-number {
            font-family: 'Rubik Mono One', monospace;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            text-shadow: 0 0 30px rgba(255, 190, 11, 0.5);
            transition: transform 0.2s ease;
            min-width: 50px;
            text-align: right;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
        }
        .score-number:hover {
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0.8;
        }
        .score-input {
            font-family: 'Rubik Mono One', monospace;
            font-size: 2rem;
            background: rgba(255, 190, 11, 0.2);
            border: 2px solid var(--neon-yellow);
            border-radius: 8px;
            padding: 8px;
            min-width: 70px;
            text-align: right;
            color: var(--text-primary);
            outline: none;
        }
        /* Remove spinner buttons for number input on mobile */
        .score-input::-webkit-outer-spin-button,
        .score-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .score-input[type=number] {
            -moz-appearance: textfield;
        }
        .score-number.pulse {
            animation: scorePulse 0.3s ease;
        }
        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .controls {
            display: flex;
            gap: 8px;
        }
        .control-btn {
            width: 44px;
            height: 44px;
            padding: 0;
            font-size: 1.5rem;
            font-weight: 800;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-increment {
            background: linear-gradient(135deg, var(--neon-green), #2ed600);
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
        }
        .btn-decrement {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }
        .delete-btn {
            width: 44px;
            height: 44px;
            padding: 0;
            background: rgba(255, 0, 110, 0.2);
            border: 1px solid var(--neon-pink);
            font-size: 1.2rem;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .delete-btn:hover {
            background: rgba(255, 0, 110, 0.4);
        }
        .start-button-container {
            margin: 10px 0;
            display: flex;
            justify-content: center;
        }
        
        .start-button-container button {
            flex: 1;
            max-width: 100%;
        }
        
        /* Start button styling for all screens now that it's inline */
        .start-button-container {
            margin: 10px 0;
            display: block; /* Change from flex to block */
            width: 100%;
        }
        
        #gameStateBtn {
            display: block !important;
            margin: 0 !important;
            box-sizing: border-box !important;
            width: 100% !important; /* Force full width initially */
            background: linear-gradient(135deg, var(--neon-green), #2ed600) !important;
            color: #000000 !important;
            -webkit-text-fill-color: #000000 !important;
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4) !important;
        }
        #gameStateBtn:hover {
            box-shadow: 0 6px 20px rgba(57, 255, 20, 0.6) !important;
        }
        /* Pulse animation for Start button */
        #gameStateBtn.pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 6px 25px rgba(57, 255, 20, 0.8);
                transform: scale(1.05);
                filter: brightness(1.2);
            }
        }
        .btn-secondary {
            flex: 1.4; /* Wider to prevent text wrapping */
        }
        .tab-navigation {
            display: flex;
            gap: 10px;
            margin: 0 0 20px 0;
            justify-content: center;
        }
        .tab-btn {
            padding: 10px 16px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 12px;
            color: #00f5ff;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: none;
            position: relative;
            overflow: hidden;
            min-height: 44px;
            white-space: nowrap;
        }
        .tab-btn.active {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000000; /* Black text on bright background */
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
            transform: translateY(-2px);
        }
        .tab-btn:active {
            transform: scale(0.95);
        }
        
        /* Scorecard tab content */
        .scorecard-tab-content {
            width: 100%;
        }
        
        /* Wins tracker input fields */
        .wins-tracker-input:hover {
            border-color: var(--neon-blue) !important;
            background: rgba(0, 245, 255, 0.05) !important;
        }
        .wins-tracker-input:focus {
            outline: none;
            border-color: var(--neon-pink) !important;
            background: rgba(255, 0, 110, 0.05) !important;
        }
        
        /* Reduce padding on Scoring tab only for more space */
        .tab-btn:first-child {
            padding: 10px 4px;
        }
        
        .voice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
        }
        .voice-btn:active {
            transform: scale(0.95);
        }
        .tab-navigation-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin: 0 0 0 0;
        }
        .tab-navigation {
            display: flex;
            gap: 5px;
            flex: 1;
            background: rgba(10, 14, 39, 0.6); /* Darker background for contrast */
            border-radius: 12px;
            padding: 4px;
            position: relative;
            top: -3px; /* Move up 3px */
        }
        .tab-btn,
        .voice-btn {
            flex: 0 1 auto;
        }
        
        .tab-btn {
            background: transparent;
            box-shadow: none;
        }

        .tab-btn.tab-btn-scoring { padding-left: 12px; padding-right: 12px; }

        .voice-btn-group {
            display: flex;
            gap: 5px;
            flex: 0 0 auto;
            margin-left: -12px;
        }
        #speakerBtn { margin-left: 4px; }
        
        .tab-btn.active {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        
        .voice-btn {
            flex: 0 0 auto;
            min-width: 50px;
            width: 50px;
        }
        
        .voice-btn.manual-mode-inactive {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.6);
        }
        
        .voice-btn.manual-mode-inactive:hover {
            transform: translateY(0) !important;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.3) !important;
        }
        .voice-btn.manual-mode-inactive:hover .mic-icon {
            transform: scale(1) !important;
        }
        
        .game-type-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: -7px 0 10px 0;
            position: relative;
            z-index: 1002; /* Ensure game type row is above all other dropdowns */
        }
        
        /* When in grid mode (isDoneAdding), move game-type into tab bar space */
        body.grid-mode .tab-navigation-container .tab-navigation {
            display: none;
        }
        
        body.grid-mode .tab-navigation-container {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            align-items: flex-start;
        }
        
        body.grid-mode .game-type-row {
            flex: 0 1 auto;
            min-width: 0;
            max-width: 80%;
            margin: 0;
            background: rgba(10, 14, 39, 0.6);
            border-radius: 12px;
            padding: 6px 8px 6px 10px;
            position: relative;
            top: -3px;
            gap: 6px;
            order: -1;
        }
        
        body.grid-mode .game-type-label {
            font-size: 0.95rem;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        body.grid-mode .custom-dropdown-wrapper-game {
            min-width: 0;
            flex: 1 1 auto;
        }
        
        body.grid-mode .custom-dropdown {
            font-size: 0.95rem;
            padding: 7px 8px;
            padding-right: 26px;
        }
        
        body.grid-mode .dropdown-arrow {
            right: 6px;
            font-size: 0.95rem;
        }
        
        body[data-theme="stainless"].grid-mode .game-type-row {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        .game-type-label {
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }
        
        .custom-dropdown-wrapper-game {
            flex: 1;
            min-width: 180px;
            position: relative;
            z-index: 1001; /* Ensure game type dropdown appears above other dropdowns */
        }
        
        .custom-dropdown-wrapper-darts {
            flex: 0 0 auto;
            width: 90px; /* Increased from 80px */
            min-width: 90px;
            position: relative;
            z-index: 100; /* Lower z-index so game type dropdown appears above */
        }
        
        .custom-dropdown-wrapper-darts .custom-dropdown {
            padding-left: 12px;
            padding-right: 8px; /* Reduce right padding to give more space for text */
        }
        
        .custom-dropdown-wrapper-darts .dropdown-arrow {
            margin-left: 8px; /* Reduce margin to bring arrow closer */
        }
        
        .dropdown-list-item-game {
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dropdown-list-item-game:hover {
            background: rgba(0, 245, 255, 0.1);
            color: var(--neon-blue);
        }
        
        .theme-selector {
            position: relative;
        }
        
        .theme-selector .custom-dropdown {
            width: 100%;
        }
        
        .theme-selector .custom-dropdown-list {
            width: 100%;
        }
        
        .scorecard-selector {
            position: relative;
        }
        
        .scorecard-selector .custom-dropdown {
            width: 100%;
        }
        
        .scorecard-selector .custom-dropdown-list {
            width: 100%;
            /* Removed max-height and overflow-y - let the base .custom-dropdown-list handle open/closed states */
        }
        
        .wins-tracker-selector {
            position: relative;
        }
        
        .wins-tracker-selector .custom-dropdown {
            width: 100%;
        }
        
        .wins-tracker-selector .custom-dropdown-list {
            width: 100%;
            z-index: 1500; /* Higher than other dropdowns to appear on top */
        }
        
        .dropdown-list-item-theme {
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dropdown-list-item-theme:hover {
            background: rgba(0, 245, 255, 0.1);
            color: var(--neon-blue);
        }
        
        .add-player-section {
            margin: 0 0 10px 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .player-inputs-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px; /* Reduced gap for better iPhone fit */
            margin-bottom: 8px;
        }
        .player-inputs-row:last-child {
            margin-bottom: 0;
        }
        .player-buttons-row {
            display: flex;
            gap: 10px;
        }
        .add-player-section input[type="text"] {
            flex: 1;
            padding: 8px 8px; /* Reduced horizontal padding for iPhone */
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: #000000;
            font-size: 0.85rem;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.2);
            text-align: center;
            min-width: 0; /* Allow inputs to shrink below their content size */
        }
        .add-player-section input[type="text"]::placeholder {
            color: #a8b5d1;
            opacity: 1;
            text-align: center;
        }
        .add-player-section input[type="text"]:focus::placeholder {
            opacity: 0;
        }
        .add-player-section input[type="text"]:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.4);
        }
        .add-more-btn,
        .done-adding-btn {
            flex: 1;
            padding: 8px 20px;
            border: 2px solid;
            border-radius: 8px;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: black;
        }
        .add-more-btn {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border-color: var(--neon-blue);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .done-adding-btn {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border-color: var(--neon-blue);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .add-more-btn:hover,
        .done-adding-btn:hover {
            transform: translateY(-2px);
        }
        .add-more-btn:active,
        .done-adding-btn:active {
            transform: translateY(0);
        }
        @media (max-width: 320px) {
            /* Only stack vertically on iPhone SE and smaller screens */
            .player-inputs-row {
                grid-template-columns: 1fr;
            }
            .add-player-section input[type="text"] {
                font-size: 0.85rem;
                padding: 6px 8px;
            }
        }
        .add-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--neon-pink), #d90058);
            border: 2px solid var(--neon-pink);
            border-radius: 8px;
            color: white;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 0, 110, 0.4);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* WALLS - Ultra Minimal for Chrome macOS Stability */
        .walls-container {
            display: block;
            margin: 20px auto;
            max-width: 1200px;
            overflow: hidden;
        }
        .wall-section {
            width: 48%;
            float: left;
            margin: 0 1%;
            background: #2a2d3a;
            padding: 20px;
            border: 2px solid #444;
            min-height: 200px;
            box-sizing: border-box;
        }
        .wall-section.fame {
            border-color: #39ff14;
        }
        .wall-section.shame {
            border-color: #ff006e;
        }
        .wall-title {
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0px;
            white-space: nowrap;
            color: #fff;
        }
        .wall-title.fame {
            color: #d4af37;
        }
        .wall-title.shame {
            color: #ff006e;
        }
        .wall-entry {
            background: rgba(248, 250, 252, 0.95); /* Light background */
            color: #2d3748; /* High contrast dark text */
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid;
        }
        .wall-entry.fame {
            border-left-color: var(--neon-green);
        }
        .wall-entry.shame {
            border-left-color: var(--neon-pink);
        }
        .wall-entry-game {
            font-size: 0.85rem;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            font-weight: 800;
        }
        .wall-entry-player {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .wall-entry-score {
            font-size: 1.2rem;
            font-weight: 800;
            font-family: 'Rubik Mono One', monospace;
        }
        .wall-entry.fame .wall-entry-score {
            color: var(--neon-green);
        }
        .wall-entry.shame .wall-entry-score {
            color: var(--neon-pink);
        }
        .wall-entry-date {
            font-size: 0.85rem;
            color: var(--text-dim);
            font-style: italic;
            margin-top: 3px;
        }
        .wall-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-dim);
            font-size: 0.95rem;
        }
        @media (max-width: 600px) {
            .walls-container {
                flex-direction: column;
            }
        }
        
        /* Darts 501 Styling */
        .game-header {
            background: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: bold;
            font-size: 0.95rem;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .game-header-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-header-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 2px solid var(--text-primary);
            border-radius: 4px;
            background: transparent;
            position: relative;
            margin: 0;
        }
        
        .game-header-checkbox:checked {
            background: var(--neon-blue);
            border-color: var(--neon-blue);
        }
        
        .game-header-checkbox:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .game-header-label {
            cursor: pointer;
            user-select: none;
        }
        
        .darts-player-card {
            background: white;
            margin: 0;
            padding: 8px 12px;
            border-radius: 8px;
            display: flex !important;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            visibility: visible !important;
            opacity: 1 !important;
            width: 100% !important;
            min-height: 60px !important;
        }
        
        #playersContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            margin: 0;
            padding: 0;
            visibility: visible;
            opacity: 1;
        }
        
        .darts-player-card.active {
            background: #90CAF9 !important;
        }
        
        .darts-player-score {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
            min-width: 80px;
            font-family: 'Courier New', monospace;
        }
        
        .darts-player-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            min-width: 80px;
        }
        
        .darts-dart-boxes {
            display: flex;
            gap: 5px;
        }
        
        .darts-dart-box {
            width: 63px;
            height: 45px;
            border: 2px solid #ddd;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.95rem;
            font-weight: bold;
            background: white;
            color: black;
            font-family: 'Courier New', monospace;
            padding: 0 6px;
            box-sizing: border-box;
        }
        
        .darts-dart-box.double {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .darts-dart-box.triple {
            background: #FF9800;
            color: white;
            border-color: #FF9800;
        }
        
        .darts-dart-box.uncounted {
            background: white;
            color: red !important;
            border-color: #ddd;
            opacity: 1;
        }
        
        .darts-dart-box.double.uncounted {
            opacity: 1;
            color: red !important;
        }
        
        .darts-dart-box.triple.uncounted {
            opacity: 1;
            color: red !important;
        }
        
        .darts-stats {
            margin-left: auto;
            text-align: right;
        }
        
        .darts-sets-legs {
            font-size: 1.2rem;
            color: #333;
            font-weight: bold;
            white-space: nowrap;
        }
        
        /* Keypad */
        .darts-keypad {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 15px;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
        }
        
        .darts-keypad-btn {
            padding: 12px;
            font-size: 0.95rem;
            font-weight: bold;
            background: white;
            color: #333;
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 50px;
        }
        
        .darts-keypad-btn:hover {
            background: #e8e8e8;
            transform: scale(1.05);
        }
        
        .darts-keypad-btn:active {
            transform: scale(0.95);
        }
        
        .darts-keypad-btn.double {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .darts-keypad-btn.triple {
            background: #FF9800;
            color: white;
            border-color: #FF9800;
        }
        
        .darts-keypad-btn.undo {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay-bg);
            z-index: 10003;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        
        .modal.active {
            display: flex;
            pointer-events: all;
        }
        
        .modal-content {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 15px;
            max-width: min(95vw, 414px); /* Constrain to iPhone XS Max width */
            width: calc(100vw - 20px); /* Reduce margins for more space */
            max-height: 90vh; /* Use most of the viewport height */
            height: auto; /* Allow dynamic height based on content */
            overflow-y: auto; /* Enable vertical scrolling if needed */
            min-width: 280px; /* Minimum width for readability */
            text-align: center;
            pointer-events: all;
            box-sizing: border-box;
            margin: 10px; /* Small margin from edges */
        }
        
        /* Stainless theme modal content - metallic steel look */
        body[data-theme="stainless"] .modal-content {
            background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e0 100%);
            border: 3px solid #94a3b8;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        
        .modal-content h2 {
            color: var(--neon-blue);
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .darts-player-score {
                font-size: 1.5rem;
                min-width: 60px;
            }
            
            .darts-player-name {
                font-size: 0.95rem;
                min-width: 60px;
            }
            
            .darts-dart-box {
                width: 53px;
                height: 35px;
                font-size: 0.85rem;
                padding: 0 5px;
                box-sizing: border-box;
            }
            
            .darts-sets-legs {
                font-size: 0.85rem;
            }
            
            .darts-keypad {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        /* Player Setup */
        .player-chip {
            display: inline-block;
            background: #4CAF50;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
        }
        
        .remove-player {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .hidden {
            display: none;
        }
        
        #darts501Container {
            padding: 0;
            overflow: visible;
        }
        
        #gameArea {
            display: none;
        }
        
        #gameArea.active {
            display: block;
            overflow: visible;
        }
        
        .crowns-mode {
            display: none;
        }
        .crowns-mode.active {
            display: block;
        }
        .crowns-container {
            overflow-x: auto;
            overflow-y: visible;
            margin: 20px 0;
            padding-bottom: 20px;
            -webkit-overflow-scrolling: touch;
            width: 100%;
        }
        .crowns-table {
            border-collapse: collapse;
            background: var(--card-bg);
            border-radius: 12px;
            overflow: hidden;
            width: auto;
            min-width: 100%;
            display: table;
        }
        .crowns-table th,
        .crowns-table td {
            border: 1px solid rgba(0, 245, 255, 0.2);
            padding: 6px 8px;
            text-align: center;
            min-width: 50px;
        }
        .crowns-table th {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000000; /* Black text for better contrast on light blue */
            font-weight: 800;
            text-transform: uppercase;
            font-size: 1.2rem;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }
        .crowns-table th.player-name-header {
            cursor: pointer;
            transition: background 0.3s ease;
            min-width: 70px;
        }
        .crowns-table th.player-name-header:hover {
            background: rgba(0, 245, 255, 0.2);
        }
        .crowns-table th.crowns-player-header {
            cursor: pointer;
            transition: background 0.3s ease;
            min-width: 80px;
            width: auto;
        }
        .crowns-table th.crowns-player-header:hover {
            background: rgba(0, 245, 255, 0.2);
        }
        .crowns-table td.crowns-score:not(.golf-info-column) {
            min-width: 60px;
            width: auto;
        }
        .crowns-player-name-input {
            width: 90%;
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            padding: 8px 12px;
            font-family: Outfit, sans-serif;
            text-align: center;
        }
        .crowns-player-name-input:focus {
            outline: none;
            border-color: var(--neon-blue);
        }
        .crowns-table .round-label {
            background: rgba(0, 0, 0, 0.5);
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.95rem;
            position: sticky;
            left: 0;
            z-index: 5;
            border-right: 2px solid var(--neon-blue);
            min-width: 35px;
            padding: 6px 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .crowns-table td.round-label.highlighted {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc) !important; /* Neon blue highlight like tabs */
            color: #000000 !important; /* Black text on bright background */
            box-shadow: 0 2px 8px rgba(0, 245, 255, 0.4) !important;
        }
        
        .crowns-table td.crowns-hole-label.highlighted {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc) !important; /* Neon blue highlight like tabs */
            color: #000000 !important; /* Black text on bright background */
            box-shadow: 0 2px 8px rgba(0, 245, 255, 0.4) !important;
        }
        .crowns-table th.round-label {
            z-index: 15;
            color: #000000; /* Black text for better contrast on light blue */
        }
        .crown-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            vertical-align: middle;
        }
        
        .crown-icon svg {
            display: block;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }
        
        body[data-theme="stainless"] .crown-icon svg {
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }
        .crowns-table th.crowns-hole-label {
            color: #000000; /* Black text for better contrast on light blue */
            padding: 6px 6px;
        }
        .crowns-table td.crowns-hole-label {
            padding: 6px 6px;
        }
        
        /* Light green background for Tee column cells (not OUT, IN, TOT) */
        .crowns-table tbody tr:not(.total-row) td.crowns-hole-label.golf-info-column {
            background: rgba(57, 255, 20, 0.2) !important;
        }
        /* Yahtzee-specific styles */
        .yahtzee-available {
            background: rgba(0, 245, 255, 0.15) !important;
            cursor: pointer !important;
        }
        .yahtzee-available:hover {
            background: rgba(0, 245, 255, 0.3) !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }
        .yahtzee-used {
            background: rgba(0, 123, 255, 0.6) !important; /* Brighter blue instead of grey */
            opacity: 1; /* Remove opacity reduction */
            cursor: pointer !important;
        }
        .yahtzee-used:hover {
            background: rgba(0, 123, 255, 0.8) !important; /* Darker blue on hover */
        }
        .section-divider {
            border-top: 2px solid var(--neon-blue);
            border-bottom: 2px solid var(--neon-blue);
        }
        .yrd-column-header {
            cursor: pointer !important;
            position: relative;
        }
        .yrd-column-header:hover {
            background: rgba(0, 245, 255, 0.2) !important;
            color: var(--neon-blue) !important;
        }
        .yrd-column-header::after {
            content: '';
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            margin-left: 4px;
        }
        .yrd-column-header:hover::after {
            opacity: 1;
        }
        .crowns-table td {
            background: rgba(10, 14, 39, 0.6);
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .crowns-table td:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .crowns-table td.editable {
            background: rgba(0, 245, 255, 0.05);
        }
        .crowns-table td.newly-entered {
            background: rgba(57, 255, 20, 0.3);
            animation: highlightScore 0.5s ease-out;
        }
        @keyframes highlightScore {
            0% {
                background: rgba(57, 255, 20, 0.8);
                transform: scale(1.1);
            }
            100% {
                background: rgba(57, 255, 20, 0.3);
                transform: scale(1);
            }
        }
        .crowns-table .total-row {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.3), rgba(255, 68, 68, 0.3));
            border-top: 3px solid var(--neon-pink);
        }
        
        /* Add border under OUT row in golf mode */
        .crowns-table .golf-out-row {
            border-bottom: 3px solid var(--neon-pink);
        }
        .crowns-table .total-row td {
            font-size: 1.2rem;
            font-weight: 800;
            font-family: Outfit, sans-serif;
            text-transform: uppercase;
            color: var(--text-primary);
            background: transparent;
        }
        .crowns-score-input {
            width: 60px;
            padding: 8px;
            background: rgba(0, 245, 255, 0.2);
            border: 2px solid var(--neon-blue);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            font-family: Outfit, sans-serif;
        }
        .crowns-score-input:focus {
            outline: none;
            border-color: var(--neon-pink);
        }
        .crowns-score-input::-webkit-outer-spin-button,
        .crowns-score-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .crowns-mode-toggle {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        .mode-toggle-btn {
            padding: 10px 20px;
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-dim);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .mode-toggle-btn.active {
            background: var(--neon-blue);
            color: var(--dark-bg);
            border-color: var(--neon-blue);
        }
        .empty-state {
            margin-top: 0;
            animation: fadeIn 0.8s ease-out;
        }
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        .empty-state-text {
            font-size: 1.2rem;
            font-weight: 300;
            letter-spacing: 1px;
        }
        .voice-btn {
            padding: 0 14px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            border: none;
            border-radius: 12px;
            color: black;
            font-family: Outfit, sans-serif;
            font-weight: 800;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            position: relative;
            overflow: hidden;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mic-icon {
            width: 28px !important;
            height: 28px !important;
            min-width: 28px;
            min-height: 28px;
            color: #000000;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .voice-btn:hover .mic-icon {
            transform: scale(1.1);
        }
        .voice-btn.listening .mic-icon {
            animation: blinkRed 0.8s ease-in-out infinite;
        }
        @keyframes blinkRed {
            0%, 100% { 
                color: #ff0000;
                filter: drop-shadow(0 0 8px rgba(255, 0, 0, 0.8));
            }
            50% { 
                color: #ffffff;
                filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.8));
            }
        }
        .voice-btn.listening {
            background: linear-gradient(135deg, var(--neon-pink), #d90058);
            animation: pulseButton 1s ease-in-out infinite;
        }
        
        /* Speaker icon styling */
        .speaker-icon {
            width: 28px !important;
            height: 28px !important;
            min-width: 28px;
            min-height: 28px;
            color: #000000;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .voice-btn:hover .speaker-icon {
            transform: scale(1.1);
        }
        #speakerBtn.speaker-muted .speaker-mute-line {
            display: block !important;
        }
        
        /* MICROPHONE STRIKETHROUGH - MATCHES SPEAKER BUTTON STYLE */
        #voiceBtn {
            position: relative !important;
        }
        
        /* Create thin diagonal line to match speaker button - but not when listening */
        #voiceBtn:not(.listening)::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 28px;
            height: 2.5px;
            background: currentColor;
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            z-index: 999;
        }

        
        @keyframes pulseButton {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 0, 110, 0.6), 0 0 40px rgba(255, 0, 110, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 0, 110, 1), 0 0 80px rgba(255, 0, 110, 0.6);
                transform: scale(1.05);
            }
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 2px 10px rgba(0, 245, 255, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 20px rgba(0, 245, 255, 0.6);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 2px 10px rgba(0, 245, 255, 0.3);
            }
        }
        .voice-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #151b3d; /* Dark neon theme background */
            border: 2px solid #00f5ff; /* Neon blue border */
            border-radius: 16px; /* Match Statistics modal */
            padding: 30px 40px;
            z-index: 10000;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 245, 255, 0.3); /* Neon glow */
            display: none;
            min-width: 280px;
            max-width: 414px; /* iPhone XS Max width */
            width: calc(100vw - 40px); /* Responsive width with margins */
            box-sizing: border-box;
        }
        
        /* Stainless theme - match ACTUAL final-scores-content styling (line 1053) */
        body[data-theme="stainless"] #voiceFeedback.voice-feedback,
        body[data-theme="stainless"] .voice-feedback {
            background: radial-gradient(circle at 50% 20%, #e2e8f0, #cbd5e0);
            border: 2px solid #a0aec0;
            border-radius: 16px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .voice-feedback::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-overlay-bg);
            z-index: -1;
        }
        
        /* Stainless theme - remove ::before overlay (conflicts with gradient) */
        body[data-theme="stainless"] .voice-feedback::before {
            display: none !important;
        }
        .voice-feedback * {
            border: none !important;
            text-decoration: none !important;
            box-shadow: none !important;
            outline: none !important;
        }
        .voice-feedback > * {
            border: none !important;
            text-decoration: none !important;
        }
        .voice-feedback.show {
            display: block;
            animation: feedbackAppear 0.3s ease-out;
        }
        @keyframes feedbackAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        .voice-feedback-icon {
            font-size: 3rem;
            margin-bottom: 5px;
            animation: pulseIcon 1.5s ease-in-out infinite;
            border: none;
            outline: none;
            text-decoration: none;
            display: block;
            line-height: 1;
            color: var(--neon-blue); /* Use theme color */
        }
        
        /* Stainless theme keeps dark icon */
        body[data-theme="stainless"] .voice-feedback-icon {
            color: #1a202c;
        }
        @keyframes pulseIcon {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .voice-feedback-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary); /* Use theme text color */
            margin-bottom: 10px;
            margin-top: 5px;
            border: none !important;
            outline: none;
            text-decoration: none !important;
            border-top: none !important;
            border-bottom: none !important;
            padding-top: 0;
            padding-bottom: 0;
            display: block;
            box-shadow: none !important;
            background: transparent;
        }
        
        /* Stainless theme uses darker text */
        body[data-theme="stainless"] .voice-feedback-text {
            color: #2d3748;
        }
        
        .voice-feedback-transcript {
            font-size: 0.95rem;
            color: var(--text-dim); /* Use theme dim text color */
            font-style: italic;
            margin-top: 10px;
            border: none !important;
            outline: none;
            padding: 0;
            text-decoration: none !important;
            border-top: none !important;
            padding-top: 0;
        }
        .voice-help {
            position: relative;
            flex: 1;
            min-width: 0;
        }
        .voice-help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 245, 255, 0.05);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        .voice-help-header:hover {
            border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.2);
        }
        .voice-help-header.open {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-color: var(--neon-blue);
        }
        .voice-help-title {
            flex: 1;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
        }
        .voice-help-toggle {
            margin-left: 10px;
            transition: transform 0.3s ease;
            font-size: 0.85rem;
            color: var(--text-primary);
        }
        .voice-help-header.open .voice-help-toggle {
            transform: rotate(180deg);
        }
        /* Golf Mode Toggle (below golf grid) */
        /* Golf Mode Toggle (inline with buttons) */
        .toggle-switch-container-inline {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }
        @media (max-width: 768px) {
            .golf-course-row {
                justify-content: center;
            }
            
            .toggle-switch-container-inline {
                order: 3; /* Move to next row on mobile */
                width: 100%;
                justify-content: center;
            }
            
            .btn-golf-course {
                flex: 1;
                min-width: 100px;
            }
        }
        /* Golf Course Selector */
        .golf-course-selector {
            padding: 10px;
            margin-bottom: 20px;
            background: rgba(248, 250, 252, 0.95); /* Light background */
            color: #2d3748; /* High contrast dark text */
            border-radius: 12px;
            border: 2px solid #cbd5e0; /* Visible border */
        }
        
        /* Match game-type panel styling in grid mode */
        body.grid-mode .golf-course-selector {
            padding: 6px 10px;
            margin-bottom: 15px;
        }
        
        body.grid-mode .golf-course-label {
            font-size: 0.85rem;
        }
        
        body.grid-mode .golf-course-row {
            gap: 6px;
        }
        .golf-course-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .golf-course-label {
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .golf-course-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
        }
        .golf-course-input:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        /* Custom Dropdown for Golf Course */
        .custom-dropdown-wrapper {
            flex: 1;
            min-width: 200px;
            position: relative;
        }
        .custom-dropdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .custom-dropdown:hover {
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
        }
        .custom-dropdown.open {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-color: var(--neon-pink);
        }
        .dropdown-selected {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .dropdown-arrow {
            margin-left: 10px;
            transition: transform 0.3s ease;
            font-size: 0.85rem;
        }
        .custom-dropdown.open .dropdown-arrow {
            transform: rotate(180deg);
        }
        /* Dropdown list styles kept for potential future use */
        .custom-dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 0;
            overflow: hidden;
            background: rgba(248, 250, 252, 0.98); /* Light background */
            color: #2d3748; /* High contrast dark text */
            border: 2px solid #cbd5e0; /* Visible border */
            border-top: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            z-index: 1000;
            transition: max-height 0.3s ease;
        }
        .custom-dropdown-list.open {
            max-height: 400px;
            overflow-y: auto;
        }
        .dropdown-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(0, 245, 255, 0.1);
        }
        .dropdown-course-name {
            flex: 1;
            cursor: pointer;
        }
        .dropdown-course-actions {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }
        .dropdown-action-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dropdown-action-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--neon-blue);
            transform: scale(1.1);
        }
        .dropdown-list-item:last-child {
            border-bottom: none;
        }
        .dropdown-list-item:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .dropdown-course-name:hover {
            color: var(--neon-blue);
        }
        .dropdown-list-empty {
            padding: 15px;
            color: var(--text-dim);
            text-align: center;
            font-size: 0.95rem;
            font-style: italic;
        }
        .dropdown-add-new-btn {
            padding: 12px 15px;
            color: var(--neon-green);
            background: rgba(57, 255, 20, 0.1);
            border-top: 2px solid rgba(57, 255, 20, 0.3);
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .dropdown-add-new-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            color: #39ff14;
        }
        /* Stainless theme for dropdown */
        body[data-theme="stainless"] .custom-dropdown {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .custom-dropdown:hover {
            border-color: #a0aec0;
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .custom-dropdown.open {
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .custom-dropdown-list {
            background: rgba(255, 255, 255, 0.95);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .dropdown-list-item {
            color: #2d3748;
            border-bottom-color: rgba(160, 174, 192, 0.2);
        }
        body[data-theme="stainless"] .dropdown-list-item:hover {
            background: rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .dropdown-course-name:hover {
            color: #4299e1;
        }
        body[data-theme="stainless"] .dropdown-action-btn {
            background: rgba(255, 255, 255, 0.3);
            border-color: #cbd5e0;
            color: #2d3748;
        }
        body[data-theme="stainless"] .dropdown-action-btn:hover {
            background: rgba(160, 174, 192, 0.4);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .dropdown-list-empty {
            color: #718096;
        }
        body[data-theme="stainless"] .dropdown-add-new-btn {
            color: #2f855a;
            background: rgba(72, 187, 120, 0.1);
            border-top-color: rgba(72, 187, 120, 0.3);
        }
        body[data-theme="stainless"] .dropdown-add-new-btn:hover {
            background: rgba(72, 187, 120, 0.2);
            color: #276749;
        }
        
        /* Steel theme for Voice Commands dropdown */
        body[data-theme="stainless"] .voice-help-header {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-header:hover {
            border-color: #a0aec0;
            box-shadow: 0 0 10px rgba(160, 174, 192, 0.3);
        }
        body[data-theme="stainless"] .voice-help-header.open {
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .voice-help-content {
            background: rgba(255, 255, 255, 0.95);
            border-color: #a0aec0;
        }
        body[data-theme="stainless"] .voice-help li {
            color: #2d3748;
            border-bottom-color: rgba(160, 174, 192, 0.2);
        }
        body[data-theme="stainless"] .voice-help li strong {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-content strong {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-title {
            color: #2d3748;
        }
        body[data-theme="stainless"] .voice-help-toggle {
            color: #2d3748;
        }
        
        .btn-golf-course {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000;
            border: none;
            border-radius: 8px;
            font-family: Outfit, sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-golf-course:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
        }
        .btn-golf-save {
            background: linear-gradient(135deg, var(--neon-green), #2ed600);
        }
        .btn-golf-save:hover {
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
        }
        body[data-theme="stainless"] .golf-course-selector {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(160, 174, 192, 0.4);
        }
        body[data-theme="stainless"] .golf-course-label {
            color: #2d3748;
        }
        body[data-theme="stainless"] .golf-course-input {
            background: rgba(255, 255, 255, 0.3);
            border-color: #718096;
            color: #2d3748;
        }
        body[data-theme="stainless"] .btn-golf-course {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            color: #2d3748;
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.8),
                        inset 0 -1px 2px rgba(0, 0, 0, 0.25);
        }
        /* Golf Score Visual Indicators */
        .golf-over-par {
            border: 3px solid #ff0055;
            border-radius: 4px;
            font-weight: 900;
            color: #ff0055;
        }
        .golf-under-par {
            border: 3px solid var(--neon-blue);
            border-radius: 50%;
            font-weight: 900;
            color: var(--neon-blue);
        }
        /* Darker background for Tee, Par, HCP, YRD columns */
        .golf-info-column {
            background: rgba(0, 0, 0, 0.5) !important;
            font-weight: 800;
            font-size: 0.95rem;
            font-family: Outfit, sans-serif;
            min-width: 35px !important;
            max-width: 45px !important;
            width: 40px !important;
            padding: 4px 2px !important;
            white-space: nowrap;
        }
        body[data-theme="stainless"] .golf-info-column {
            background: rgba(0, 0, 0, 0.15) !important;
        }
        
        /* Light green Tee column for stainless theme */
        body[data-theme="stainless"] .crowns-table tbody tr:not(.total-row) td.crowns-hole-label.golf-info-column {
            background: rgba(129, 199, 132, 0.4) !important;
        }
        /* Front 9 / Back 9 separator */
        .golf-nine-separator {
            height: 8px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
        }
        body[data-theme="stainless"] .golf-nine-separator {
            background: linear-gradient(90deg, transparent, #718096, transparent);
        }
        .voice-help-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 0;
            overflow: hidden;
            background: var(--card-bg);
            color: var(--text-primary);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-top: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            z-index: 1200;
            transition: max-height 0.3s ease;
        }
        .voice-help-content.open {
            max-height: 500px;
            overflow-y: auto;
        }
        
        /* Custom scrollbar styling for voice help */
        .voice-help-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .voice-help-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        .voice-help-content::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 4px;
        }
        
        .voice-help-content::-webkit-scrollbar-thumb:hover {
            background: var(--neon-pink);
        }
        .voice-help ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .voice-help li {
            padding: 10px 15px;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            line-height: 1.6;
            border-bottom: 1px solid rgba(0, 245, 255, 0.1);
        }
        .voice-help li:last-child {
            border-bottom: none;
        }
        .voice-help li strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        .voice-help-content strong {
            color: var(--text-primary);
        }
        /* ===== TIMER MODALS ===== */
        .timer-selector {
            position: relative;
        }
        .timer-selector .custom-dropdown {
            width: 100%;
        }
        .timer-selector .custom-dropdown-list {
            width: 100%;
        }
        .timer-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.75);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .timer-modal-content {
            background: var(--card-bg);
            border: 2px solid var(--neon-blue);
            border-radius: 20px;
            padding: 28px 24px 24px;
            width: 100%;
            max-width: 360px;
            position: relative;
            text-align: center;
            box-shadow: 0 8px 40px rgba(0,245,255,0.25);
        }
        .timer-modal-close {
            position: absolute;
            top: 12px; right: 14px;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.2rem;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .timer-modal-close:hover { opacity: 1; }
        .timer-modal-title {
            font-family: Outfit, sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 18px;
            letter-spacing: 0.5px;
        }
        /* Duration buttons (shared by sand & chess) */
        .sand-timer-durations, .chess-durations {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }
        .sand-duration-btn {
            padding: 6px 12px;
            border-radius: 20px;
            border: 2px solid var(--neon-blue);
            background: transparent;
            color: var(--text-primary);
            font-family: Outfit, sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sand-duration-btn.active,
        .sand-duration-btn:hover {
            background: var(--neon-blue);
            color: #000;
        }
        /* Sand timer hourglass */
        .sand-hourglass-wrap {
            display: flex;
            justify-content: center;
            margin: 4px 0 8px;
        }
        /* Big countdown display */
        .timer-big-display {
            font-family: 'Courier New', monospace;
            font-size: 3rem;
            font-weight: 700;
            color: var(--neon-blue);
            letter-spacing: 2px;
            margin: 4px 0 6px;
        }
        .timer-big-display.timer-urgent { color: #ff6b6b; }
        .timer-status-text {
            font-family: Outfit, sans-serif;
            font-size: 0.85rem;
            color: var(--text-dim, #aaa);
            margin-bottom: 16px;
            min-height: 20px;
        }
        /* Timer control buttons */
        .timer-controls {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        .timer-btn {
            padding: 10px 24px;
            border-radius: 10px;
            border: none;
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timer-btn-primary {
            background: linear-gradient(135deg, var(--neon-green), #2ed600);
            color: #000;
            box-shadow: 0 4px 14px rgba(57,255,20,0.3);
        }
        .timer-btn-primary:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(57,255,20,0.4); }
        .timer-btn-primary.paused {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            box-shadow: 0 4px 14px rgba(255,200,0,0.3);
        }
        .timer-btn-primary.stopped {
            background: linear-gradient(135deg, var(--neon-blue), #00c4cc);
            color: #000;
        }
        .timer-btn-secondary {
            background: rgba(255,255,255,0.08);
            color: var(--text-primary);
            border: 2px solid rgba(255,255,255,0.2);
        }
        .timer-btn-secondary:hover { background: rgba(255,255,255,0.15); }
        /* Digital timer set controls */
        .digital-time-set {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }
        .digital-unit {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .digital-unit-display {
            font-family: 'Courier New', monospace;
            font-size: 2.8rem;
            font-weight: 700;
            color: var(--neon-blue);
            min-width: 80px;
            text-align: center;
            background: rgba(0,245,255,0.07);
            border-radius: 10px;
            padding: 4px 8px;
        }
        .digital-unit-label {
            font-family: Outfit, sans-serif;
            font-size: 0.7rem;
            color: var(--text-dim, #aaa);
            letter-spacing: 1px;
        }
        .digital-adj-btn {
            background: none;
            border: none;
            color: var(--neon-blue);
            font-size: 1.1rem;
            cursor: pointer;
            padding: 2px 14px;
            transition: transform 0.15s;
        }
        .digital-adj-btn:hover { transform: scale(1.3); }
        .digital-colon {
            font-family: 'Courier New', monospace;
            font-size: 2.8rem;
            font-weight: 700;
            color: var(--neon-blue);
            padding-bottom: 20px;
        }
        .digital-running-display { margin-bottom: 0; }
        /* Chess clock */
        .chess-modal-content { max-width: 400px; }
        .chess-clocks {
            display: flex;
            align-items: stretch;
            gap: 0;
            margin: 0 0 12px;
            border-radius: 14px;
            overflow: hidden;
            border: 2px solid var(--neon-blue);
        }
        .chess-player-block {
            flex: 1;
            padding: 20px 12px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            background: rgba(0,245,255,0.04);
            user-select: none;
        }
        .chess-player-block.active-player {
            background: rgba(0,245,255,0.15);
        }
        .chess-player-block.out-of-time {
            background: rgba(255,80,80,0.15);
        }
        .chess-player-block:hover { background: rgba(0,245,255,0.1); }
        .chess-divider {
            width: 2px;
            background: var(--neon-blue);
            flex-shrink: 0;
        }
        .chess-player-label {
            font-family: Outfit, sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-dim, #aaa);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .chess-player-time {
            font-family: 'Courier New', monospace;
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--neon-blue);
            transition: color 0.3s;
        }
        .chess-player-block.active-player .chess-player-time { color: var(--neon-green); }
        .chess-player-block.out-of-time .chess-player-time { color: #ff6b6b; }
        .chess-tap-hint {
            font-family: Outfit, sans-serif;
            font-size: 0.65rem;
            color: var(--text-dim, #aaa);
            opacity: 0.5;
            letter-spacing: 1px;
        }
        /* ===== REDESIGNED SAND TIMER ===== */
        .sand-timer-modal {
            background: rgba(0,0,0,0.92) !important;
        }
        .sand-timer-shell {
            position: relative;
            background: radial-gradient(ellipse at 40% 30%, rgba(0,60,80,0.95) 0%, rgba(0,10,20,0.98) 70%);
            border: 1.5px solid rgba(0,229,255,0.3);
            border-radius: 28px;
            padding: 16px 24px 24px;
            width: 100%;
            max-width: 340px;
            text-align: center;
            box-shadow:
                0 0 40px rgba(0,229,255,0.15),
                0 0 80px rgba(0,229,255,0.08),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .sand-close-btn {
            margin-left: auto;
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            color: rgba(0,229,255,0.5);
            font-size: 1.1rem;
            cursor: pointer;
            transition: color 0.2s;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            border-radius: 0 !important;
        }
        .sand-duration-row .timer-modal-close {
            position: static;
            margin-left: auto;
            opacity: 0.6;
        }
        .sand-duration-row {
            display: flex;
            gap: 5px;
            align-items: center;
            justify-content: flex-start;
            margin-bottom: 10px;
            flex-wrap: nowrap;
        }
        .sand-pill {
            padding: 4px 8px;
            border-radius: 20px;
            border: 1.5px solid rgba(0,229,255,0.35);
            background: rgba(0,229,255,0.05);
            color: rgba(0,229,255,0.7);
            font-family: Outfit, sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 0.2px;
            white-space: nowrap;
        }
        .sand-pill.active,
        .sand-pill:hover {
            background: rgba(0,229,255,0.18);
            border-color: #00e5ff;
            color: #00e5ff;
            box-shadow: 0 0 10px rgba(0,229,255,0.25);
        }
        .sand-hg-wrap {
            display: flex;
            justify-content: center;
            margin: 10px 0 4px;
            filter: drop-shadow(0 0 16px rgba(0,229,255,0.5));
        }
        .sand-digital-display {
            font-family: 'Courier New', monospace;
            font-size: 3.2rem;
            font-weight: 700;
            color: #00e5ff;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(0,229,255,0.8), 0 0 40px rgba(0,229,255,0.4);
            margin: 0 0 4px;
            line-height: 1;
        }
        .sand-digital-display.timer-urgent {
            color: #ff4466;
            text-shadow: 0 0 20px rgba(255,60,80,0.8), 0 0 40px rgba(255,60,80,0.4);
        }
        .sand-status-text {
            font-family: Outfit, sans-serif;
            font-size: 0.8rem;
            color: rgba(0,229,255,0.45);
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 18px;
            min-height: 18px;
        }
        .sand-controls-row {
            display: flex;
            gap: 14px;
            justify-content: center;
        }
        .sand-ctrl-btn {
            padding: 10px 32px;
            border-radius: 8px;
            border: none;
            font-family: Outfit, sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 0.5px;
        }
        .sand-ctrl-start {
            background: transparent;
            border: 1.5px solid #00e5ff;
            color: #00e5ff;
            box-shadow: 0 0 14px rgba(0,229,255,0.2), inset 0 0 14px rgba(0,229,255,0.05);
        }
        .sand-ctrl-start:hover {
            background: rgba(0,229,255,0.12);
            box-shadow: 0 0 22px rgba(0,229,255,0.4);
        }
        .sand-ctrl-start.paused {
            border-color: #ffd700;
            color: #ffd700;
            box-shadow: 0 0 14px rgba(255,210,0,0.25);
        }
        .sand-ctrl-start.stopped {
            border-color: rgba(0,229,255,0.4);
            color: rgba(0,229,255,0.4);
        }
        .sand-ctrl-reset {
            background: transparent;
            border: 1.5px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.45);
        }
        .sand-ctrl-reset:hover {
            border-color: rgba(255,255,255,0.4);
            color: rgba(255,255,255,0.7);
        }
        .menu-open-tab-btn {
            width: 100%;
            padding: 10px 16px;
            background: rgba(0,245,255,0.08);
            border: 1.5px solid rgba(0,245,255,0.3);
            border-radius: 10px;
            color: var(--neon-blue);
            font-family: Outfit, sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        .menu-open-tab-btn:hover {
            background: rgba(0,245,255,0.15);
            border-color: var(--neon-blue);
        }
        body[data-theme="stainless"] .menu-open-tab-btn {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            border: 1px solid rgba(255,255,255,0.6);
            color: #2d3748;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), inset 0 -1px 2px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.25);
        }
        body[data-theme="stainless"] .menu-open-tab-btn:hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
        }
        /* ===== SAND TIMER  STEEL THEME OVERRIDES ===== */
        body[data-theme="stainless"] .sand-timer-modal {
            background: rgba(80, 90, 100, 0.85) !important;
        }
        body[data-theme="stainless"] .sand-timer-shell {
            background: linear-gradient(145deg, #f0f3f7 0%, #dde3eb 40%, #c8d0da 100%);
            border: 1px solid rgba(255,255,255,0.7);
            box-shadow:
                inset 0 2px 0 rgba(255,255,255,0.85),
                inset 0 -2px 4px rgba(0,0,0,0.15),
                0 8px 32px rgba(0,0,0,0.3),
                0 2px 0 rgba(255,255,255,0.4);
        }
        body[data-theme="stainless"] .sand-close-btn {
            color: #718096;
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            transform: none !important;
        }
        body[data-theme="stainless"] .sand-close-btn:hover { color: #2d3748; }
        body[data-theme="stainless"] .sand-pill {
            border-color: rgba(100,116,139,0.4);
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.6), rgba(200,210,220,0.3));
            color: #4a5568;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.7), 0 1px 2px rgba(0,0,0,0.15);
        }
        body[data-theme="stainless"] .sand-pill.active,
        body[data-theme="stainless"] .sand-pill:hover {
            background: radial-gradient(circle at 30% 30%, #90a4ae, #607d8b);
            border-color: #455a64;
            color: #fff;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.2);
        }
        body[data-theme="stainless"] .sand-hg-wrap {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.25));
        }
        body[data-theme="stainless"] .sand-digital-display {
            color: #37474f;
            text-shadow: 0 1px 0 rgba(255,255,255,0.8), 0 -1px 0 rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
        }
        body[data-theme="stainless"] .sand-digital-display.timer-urgent {
            color: #c0392b;
            text-shadow: 0 1px 0 rgba(255,255,255,0.5), 0 -1px 0 rgba(0,0,0,0.2);
        }
        body[data-theme="stainless"] .sand-status-text {
            color: #718096;
            letter-spacing: 1px;
        }
        body[data-theme="stainless"] .sand-ctrl-start {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            border: 1px solid rgba(255,255,255,0.6);
            color: #2d3748;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), inset 0 -1px 2px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.25);
        }
        body[data-theme="stainless"] .sand-ctrl-start:hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.9), 0 4px 8px rgba(0,0,0,0.3);
        }
        body[data-theme="stainless"] .sand-ctrl-start.paused {
            background: radial-gradient(circle at 30% 30%, #ffe082, #ffb300);
            border-color: rgba(255,255,255,0.5);
            color: #4e3000;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.6), 0 2px 4px rgba(0,0,0,0.25);
        }
        body[data-theme="stainless"] .sand-ctrl-reset {
            background: radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0);
            border: 1px solid rgba(255,255,255,0.6);
            color: #4a5568;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), inset 0 -1px 2px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.2);
        }
        body[data-theme="stainless"] .sand-ctrl-reset:hover {
            background: radial-gradient(circle at 30% 30%, #f7fafc, #cbd5e0);
            color: #2d3748;
        }
    </style>
</head>
<body data-theme="stainless">
    <div class="container">
        <header>
            <div class="hamburger-btn" id="hamburgerBtn" onclick="toggleMenu()">
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
            </div>
            <div style="display: flex; align-items: center; gap: 12px; padding-right: 55px;">
                <span style="font-size: 2.5rem; position: relative; top: -4px;"></span>
                <div>
                    <h1 style="margin: 0;">ScoreKeeper</h1>
                    <div class="subtitle" style="margin-top: -5px;">Track  Compete  Win</div>
                </div>
            </div>
        </header>
        <div class="tab-navigation-container">
            <div class="tab-navigation">
                <button class="tab-btn tab-btn-scoring active" onclick="switchTab('scorekeeper')">Scoring</button>
                <button class="tab-btn" onclick="switchTab('highscores')">High Scores</button>
            </div>
            <div class="voice-btn-group">
            <button class="voice-btn" id="speakerBtn" onclick="toggleSpeaker()">
                <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M11 5L6 9H2V15H6L11 19V5Z" fill="currentColor"/>
                    <path d="M15.54 8.46C16.4774 9.39764 17.0039 10.6692 17.0039 11.995C17.0039 13.3208 16.4774 14.5924 15.54 15.53" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18.07 5.93C19.9447 7.80528 20.9979 10.3462 20.9979 13C20.9979 15.6538 19.9447 18.1947 18.07 20.07" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <line class="speaker-mute-line" x1="2" y1="2" x2="22" y2="22" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" style="display: none;"/>
                </svg>
            </button>
            <button class="voice-btn" id="voiceBtn" onclick="startVoiceInput()">
                <svg class="mic-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 15C13.66 15 15 13.66 15 12V6C15 4.34 13.66 3 12 3C10.34 3 9 4.34 9 6V12C9 13.66 10.34 15 12 15Z" fill="currentColor"/>
                    <path d="M17 11C17 14.31 14.31 17 11 17H13C16.31 17 19 14.31 19 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M7 11C7 14.31 9.69 17 13 17H11C7.69 17 5 14.31 5 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M12 17V21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M9 21H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </button>
            </div>
        </div>
        
        <div class="game-type-row">
            <label class="game-type-label">Game Type:</label>
            <div class="custom-dropdown-wrapper-game">
                <div class="custom-dropdown" id="gameTypeDropdown" onclick="toggleGameTypeDropdown()">
                    <span id="selectedGameType" class="dropdown-selected">Select a Game</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="gameTypeDropdownList">
                    <div class="dropdown-list-item-game" data-value="5crowns" onclick="selectGameType('5crowns')">5 Crowns</div>
                    <div class="dropdown-list-item-game" data-value="darts" onclick="selectGameType('darts')">Darts</div>
                    <div class="dropdown-list-item-game" data-value="farkle" onclick="selectGameType('farkle')">Farkle</div>
                    <div class="dropdown-list-item-game" data-value="general" onclick="selectGameType('general')">General</div>
                    <div class="dropdown-list-item-game" data-value="golf" onclick="selectGameType('golf')">Golf</div>
                    <div class="dropdown-list-item-game" data-value="phase10" onclick="selectGameType('phase10')">Phase 10</div>
                    <div class="dropdown-list-item-game" data-value="scrabble" onclick="selectGameType('scrabble')">Scrabble</div>
                    <div class="dropdown-list-item-game" data-value="yahtzee" onclick="selectGameType('yahtzee')">Yahtzee</div>
                    <div class="dropdown-list-item-game" data-value="custom" onclick="openCustomGameTrackingModal()" style="border-top: 2px solid var(--neon-blue); margin-top: 8px; padding-top: 12px;">Custom Game Tracking</div>
                </div>
            </div>
            <!-- Hidden select for backwards compatibility -->
            <select id="gameType" style="display: none;">
                <option value="5crowns">5 Crowns</option>
                <option value="darts">Darts</option>
                <option value="farkle">Farkle</option>
                <option value="general">General</option>
                <option value="golf">Golf</option>
                <option value="phase10">Phase 10</option>
                <option value="scrabble">Scrabble</option>
                <option value="yahtzee">Yahtzee</option>
            </select>
        </div>
        
        <div class="add-player-section" id="addPlayerSection">
            <div id="playerInputsContainer">
                <div class="player-inputs-row">
                    <input type="text" id="playerNameInput1" placeholder="Player 1" maxlength="20">
                    <input type="text" id="playerNameInput2" placeholder="Player 2" maxlength="20">
                </div>
                <div class="player-inputs-row">
                    <input type="text" id="playerNameInput3" placeholder="Player 3" maxlength="20">
                    <input type="text" id="playerNameInput4" placeholder="Player 4" maxlength="20">
                </div>
            </div>
            <div class="player-buttons-row">
                <button class="add-more-btn" onclick="addMorePlayerFields()">Add More Players</button>
                <button class="done-adding-btn" onclick="doneAdding()">Done Adding Player Names</button>
            </div>
        </div>
        <div id="scorekeeperTab" class="tab-content active">
            <div id="standardMode" class="standard-mode">
                <!-- Instructions Panel for Standard Mode -->
                <div id="standardModeInstructions" style="padding: 15px 20px 20px 20px; text-align: left; line-height: 1.5; font-size: 0.95rem; margin: 10px 0; border-radius: 8px;">
                    <strong style="font-family: Outfit, sans-serif; font-size: 0.95rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">Instructions:</strong><br>
                    <div style="text-indent: -20px; padding-left: 20px; margin-top: 8px;"><strong>1.</strong> To use Voice Recognition, go to Settings and enable the microphone for the Safari browser.</div>
                    <div style="text-indent: -20px; padding-left: 20px;"><strong>2.</strong> Click the "Start" button and follow the voice prompts to select a game and add Players.</div>
                    <div style="text-indent: -20px; padding-left: 20px;"><strong>3.</strong> Say "Done Adding" and the game will start.</div>
                    
                    <div style="text-align: center; font-weight: 600; margin: 5px 0;">OR</div>
                    
                    <div style="text-indent: -20px; padding-left: 20px;"><strong>1.</strong> To use manual controls, select a game from the dropdown list.</div>
                    <div style="text-indent: -20px; padding-left: 20px;"><strong>2.</strong> Add Player names.</div>
                    <div style="text-indent: -20px; padding-left: 20px;"><strong>3.</strong> Click the "Done adding Player Names" button, and the game will start.</div>
                </div>
                
                <!-- Start Button directly under instructions -->
                <div class="start-button-container">
                    <button id="gameStateBtn" onclick="toggleGameState()">Start Voice Recognition</button>
                </div>
            </div>
            <div id="crownsMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="crownsTable"></table>
                    
                    <!-- Game management controls -->
                    <div id="crownsButtons" style="display: none; margin-top: 20px;">
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="golfMode" class="crowns-mode">
                <div class="crowns-container">
                    <!-- Golf Course Selector (Always visible when players exist) -->
                    <div class="golf-course-selector" id="golfCourseSelector" style="display: none;">
                        <div class="golf-course-row">
                            <label class="golf-course-label">Golf Course:</label>
                            <div class="custom-dropdown-wrapper">
                                <div class="custom-dropdown" id="golfCourseDropdown" onclick="toggleGolfCourseDropdown();">
                                    <span id="selectedCourseName" class="dropdown-selected">Select a course</span>
                                    <span class="dropdown-arrow"></span>
                                </div>
                                <div class="custom-dropdown-list" id="golfCourseDropdownList">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <table class="crowns-table" id="golfTable"></table>
                    
                    <!-- Game management controls -->
                    <div id="golfButtons" style="display: none; margin-top: 20px;">
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="scrabbleMode" class="crowns-mode">
                <div class="crowns-container">
                    <!-- Word checker above the grid -->
                    <div id="scrabbleWordChecker" style="display: none; margin-bottom: 15px; text-align: center;">
                        <!-- First row: Word Check -->
                        <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 10px;">
                            <label style="font-weight: 600; color: var(--text-primary); width: 81px; text-align: right; font-size: 0.95rem; white-space: nowrap;">Word Check:</label>
                            <input type="text" id="scrabbleWordInput" placeholder="Enter word..." 
                                   onkeypress="if(event.key==='Enter') checkWordFromInput()"
                                   oninput="updateScrabbleCheckButton()"
                                   onpaste="setTimeout(updateScrabbleCheckButton, 10)"
                                   style="padding: 8px 12px; border-radius: 6px; border: 2px solid var(--neon-blue); background: var(--card-bg); color: var(--text-primary); font-family: Outfit, sans-serif; width: 150px; font-size: 0.95rem; font-weight: 700;">
                            <button id="scrabbleCheckButton" onclick="checkWordFromInput()" 
                                    style="width: 40px; height: 40px; border-radius: 6px; border: 2px solid var(--neon-blue); background: var(--neon-blue); color: black; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold;"></button>
                        </div>
                        
                        <!-- Second row: Timer Controls with exact alignment -->
                        <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                            <label style="font-weight: 600; color: var(--text-primary); width: 81px; text-align: right; font-size: 0.95rem; white-space: nowrap;">Timer:</label>
                            <!-- Timer duration selector - aligned exactly under word input field -->
                            <div class="custom-dropdown-wrapper" style="width: 150px; position: relative; z-index: 100;">
                                <!-- Timer dropdown (shown when timer not running) -->
                                <div class="custom-dropdown" id="scrabbleTimerDropdown" onclick="toggleScrabbleTimerDropdown()" style="padding: 8px 12px; border-radius: 6px; border: 2px solid var(--neon-blue); background: var(--card-bg); color: var(--text-primary); font-family: Outfit, sans-serif; font-size: 0.95rem; width: 100%; display: flex; justify-content: space-between; align-items: center; text-align: left;">
                                    <span id="selectedTimerDuration" class="dropdown-selected">2 minutes</span>
                                    <span class="dropdown-arrow"></span>
                                </div>
                                <div class="custom-dropdown-list" id="scrabbleTimerDropdownList" style="text-align: left;">
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(30, '30 seconds')">30 seconds</div>
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(60, '1 minute')">1 minute</div>
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(90, '1.5 minutes')">1.5 minutes</div>
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(120, '2 minutes')">2 minutes</div>
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(180, '3 minutes')">3 minutes</div>
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(240, '4 minutes')">4 minutes</div>
                                    <div class="dropdown-list-item-theme" onclick="event.stopPropagation(); selectTimerDuration(300, '5 minutes')">5 minutes</div>
                                </div>
                                
                                <!-- Timer display (shown when timer is running, overlays dropdown) -->
                                <div id="scrabbleTimerDisplay" style="display: none; position: absolute; top: 0; left: 0; right: 0; background: rgba(200, 200, 200, 0.95); border-radius: 6px; padding: 8px 12px; text-align: center; border: 2px solid var(--neon-blue); z-index: 1100;">
                                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                                        <div class="timer-player" style="font-weight: bold; font-size: 0.85rem; color: black; flex: 1; text-align: left;">No Player</div>
                                        <div class="timer-time" style="font-size: 1.2rem; color: black; flex: 0 0 auto;">2:00</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Go/Stop toggle button - aligned exactly under checkmark button -->
                            <button id="scrabbleGoBtn" onclick="toggleScrabbleTimer()" 
                                    style="width: 40px; height: 40px; border-radius: 6px; border: 2px solid var(--neon-green); background: linear-gradient(135deg, var(--neon-green), #2ed600); color: black; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; padding: 0; min-width: 40px; max-width: 40px; flex: none;"></button>
                        </div>
                    </div>
                    
                    <table class="crowns-table" id="scrabbleTable"></table>
                    
                    <div id="scrabbleButtons" style="display: none; margin-top: 20px;">
                        <!-- Main game controls -->
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button id="addScrabbleRowBtn" class="btn-secondary" onclick="addScrabbleRow()">Add New Scoring Row</button>
                            <button id="scrabbleFinalBtn" class="btn-secondary" onclick="scrabbleFinalAdjustments()">Final Scoring Adjustments</button>
                        </div>
                        <!-- Game management controls -->
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="yahtzeeMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="yahtzeeTable"></table>
                    
                    <div id="yahtzeeButtons" style="display: none; margin-top: 20px;">
                        <!-- Game management controls -->
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="phase10Mode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="phase10Table"></table>
                    
                    <div id="phase10Buttons" style="display: none; margin-top: 20px;">
                        <!-- Game management controls -->
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="genericGridMode" class="crowns-mode">
                <div class="crowns-container">
                    <table class="crowns-table" id="genericGridTable"></table>
                    <div id="genericGridButtons" style="display: none; margin-top: 20px; gap: 10px; display: flex;">
                        <button id="addGenericRowBtn" class="btn-secondary" onclick="addGenericRow()">Add New Scoring Row</button>
                    </div>
                    
                    <div id="genericGridGameButtons" style="display: none; margin-top: 10px;">
                        <!-- Game management controls -->
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Darts 501 Mode -->
            <div id="darts501Container" style="display: none;">
                <!-- Player Setup Section -->
                <!-- Game Area Section -->
                <div id="gameArea" style="padding-top: 10px;">
                    <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap; margin-bottom: 10px;">
                        <div class="custom-dropdown-wrapper-darts">
                            <div class="custom-dropdown" id="gameVariantDropdown" onclick="toggleGameVariantDropdown()">
                                <span id="selectedGameVariant" class="dropdown-selected">501</span>
                                <span class="dropdown-arrow"></span>
                            </div>
                            <div class="custom-dropdown-list" id="gameVariantDropdownList">
                                <div class="dropdown-list-item-game" data-value="501" onclick="selectGameVariant('501')">501</div>
                                <div class="dropdown-list-item-game" data-value="301" onclick="selectGameVariant('301')">301</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="doubleInCheckbox" class="game-header-checkbox" checked onchange="updateGameRules()">
                            <label for="doubleInCheckbox" style="cursor: pointer; user-select: none; color: var(--text-primary);">Double In</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="doubleOutCheckbox" class="game-header-checkbox" checked onchange="updateGameRules()">
                            <label for="doubleOutCheckbox" style="cursor: pointer; user-select: none; color: var(--text-primary);">Double Out</label>
                        </div>
                    </div>
                    <div id="playersContainer"></div>
                    <div id="keypadContainer" class="darts-keypad"></div>
                    <div id="actionButtonsContainer" style="display: flex; gap: 10px; margin-top: 10px;"></div>
                    
                    <!-- Game management controls -->
                    <div id="dartsButtons" style="display: none; margin-top: 10px;">
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn-secondary" onclick="endGame()">End Game</button>
                            <button class="btn-secondary" onclick="resetScores()">Reset Scores</button>
                            <button class="btn-secondary" onclick="resetAll()">Reset All</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="winnerModal" class="modal">
                <div class="modal-content">
                    <h2 id="winnerText">Winner!</h2>
                    <p id="winnerDetails" style="margin: 20px 0; padding: 15px 0; font-size: 1.2rem; line-height: 1.4;"></p>
                    <button class="btn-secondary" onclick="closeWinnerModal()">Continue</button>
                </div>
            </div>
        </div>
        <div id="highScoresTab" class="tab-content">
            <div style="padding: 20px;">
                <hr>
                <div style="display: table; width: 100%;">
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <h3>HIGHEST SCORE</h3>
                    </div>
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <h3>LOWEST SCORE</h3>
                    </div>
                </div>
                <hr>
                <div style="display: table; width: 100%;">
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <div id="wallOfFameContainer"></div>
                    </div>
                    <div style="display: table-cell; width: 50%; padding: 10px;">
                        <div id="wallOfShameContainer"></div>
                    </div>
                </div>
                <hr style="margin-bottom: 30px;">
                <button class="btn-secondary" onclick="window.clearAllWalls()">Clear All Scores</button>
            </div>
        </div>
        <div id="voiceFeedback" class="voice-feedback">
            <div class="voice-feedback-icon"></div>
            <div class="voice-feedback-text">Listening...</div>
            <div class="voice-feedback-transcript" id="voiceTranscript"></div>
        </div>
    </div>
    <div class="menu-overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    
    <div class="side-menu" id="sideMenu">
        
        <div class="menu-section">
            <div class="menu-section-title">Wins Tracker</div>
            <div class="wins-tracker-selector">
                <div class="custom-dropdown" id="winsTrackerDropdown" onclick="toggleWinsTrackerDropdown()">
                    <span id="selectedWinsTracker" class="dropdown-selected">Select a Game</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="winsTrackerDropdownList">
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('5crowns')">5 Crowns</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('darts')">Darts</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('farkle')">Farkle</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('general')">General</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('golf')">Golf</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('phase10')">Phase 10</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('scrabble')">Scrabble</div>
                    <div class="dropdown-list-item-theme" onclick="selectWinsTrackerGame('yahtzee')">Yahtzee</div>
                    <div class="dropdown-list-item-theme" onclick="openCustomGamesViewer()">Custom Games</div>
                </div>
            </div>
        </div>
        
        <div class="menu-section">
            <div class="menu-section-title">Interface Theme</div>
            <div class="theme-selector">
                <div class="custom-dropdown" id="themeDropdown" onclick="toggleThemeDropdown()">
                    <span id="selectedTheme" class="dropdown-selected">Steel</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="themeDropdownList">
                    <div class="dropdown-list-item-theme" onclick="selectTheme('stainless')">Steel</div>
                    <div class="dropdown-list-item-theme" onclick="selectTheme('default')">Neon</div>
                </div>
                <!-- Hidden select for backwards compatibility -->
                <select id="themeSelect" style="display: none;">
                    <option value="stainless">Steel</option>
                    <option value="default">Neon</option>
                </select>
            </div>
        </div>
        
        <div class="menu-section">
            <div class="menu-section-title">Voice Commands</div>
            <div class="voice-help">
                <div class="voice-help-header" onclick="toggleVoiceHelp()">
                    <div class="voice-help-title">Command List</div>
                    <div class="voice-help-toggle" id="voiceHelpToggle"></div>
                </div>
                <div class="voice-help-content" id="voiceHelpContent">
                    <ul>
                        <li><strong> Game Selection:</strong> "Golf"  "5 Crowns"  "Farkle"  "Darts - 501"  "Scrabble"  "General"</li>
                        <li><strong> Add Multiple Players:</strong> "Add players"  Say names  "Done" when finished</li>
                        <li><strong> Add Single Player:</strong> "Add Sarah"  "Add Guy and Emma"</li>
                        <li><strong> Add Points (Name First):</strong> "Emma 5"  "Jonathan 20"  "Guy, 5"</li>
                        <li><strong> Add Points (Number First):</strong> "20 Jonathan"  "5 Emma"  "15 Guy"</li>
                        <li><strong> Add Points (For):</strong> "5 for Emma"  "20 for Jonathan"</li>
                        <li><strong> Add Points (Give):</strong> "Give Sarah 5 points"  "Give Sarah 5"</li>
                        <li><strong> Golf Advanced (Over/Under):</strong> "Jonathan 1 over"  "Emma 2 under"  "Guy plus 1"  "Sarah minus 2"</li>
                        <li><strong> Subtract Points:</strong> "Emma minus 5"  "Take 3 from Sarah"</li>
                        <li><strong> Update Score:</strong> "Change Emma to 10"  "Update Sarah to 5"</li>
                        <li><strong> Undo Last Action:</strong> "Undo"  "Undo that"  "Go back"</li>
                        <li><strong> Fix Wrong Entry:</strong> "Wrong"  "Fix"  "Delete"  "Remove"  "Make correction"</li>
                        <li><strong> Reset:</strong> "Reset all scores"</li>
                        <li><strong> Scrabble Final Scoring:</strong> "Final scoring adjustments"  "Final scoring"</li>
                        <li><strong> Skip Voice Input:</strong> Say "Skip" or "Manual" during tile collection</li>
                    </ul>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(0,245,255,0.1); border-radius: 6px; font-size: 0.85rem;">
                        <strong> Tips:</strong><br>
                         You can interrupt any voice prompt at any time<br>
                         "At" auto-corrects to "Add" for player names<br>
                         Numbers: "too/to"  2, "for/fore"  4, "twenty four"  "twenty for"<br>
                         Undo works for last 20 actions<br>
                         Voice adds players immediately to active game<br>
                         Click grid cells to manually edit scores<br>
                         Golf Advanced: Voice commands only work when Par values are set
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-section-title">Timers</div>
            <div class="timer-selector">
                <div class="custom-dropdown" id="timerDropdown" onclick="toggleTimerDropdown()">
                    <span id="selectedTimer" class="dropdown-selected">Select a Timer</span>
                    <span class="dropdown-arrow"></span>
                </div>
                <div class="custom-dropdown-list" id="timerDropdownList">
                    <div class="dropdown-list-item-theme" onclick="openTimer('sand')">Sand Timer</div>
                    <div class="dropdown-list-item-theme" onclick="openTimer('digital')">Digital Timer</div>
                    <div class="dropdown-list-item-theme" onclick="openTimer('chess')">Chess Clock</div>
                </div>
            </div>
        </div>

    </div>

    <!-- Sand Timer Modal -->
    <div id="sandTimerModal" class="timer-modal sand-timer-modal" style="display:none;">
        <div class="sand-timer-shell">

            <!-- Pills + close button on the same row -->
            <div class="sand-duration-row">
                <button class="sand-pill active" onclick="setSandDuration(60)"  id="sand-btn-60">1 min</button>
                <button class="sand-pill"        onclick="setSandDuration(90)"  id="sand-btn-90">1.5 min</button>
                <button class="sand-pill"        onclick="setSandDuration(120)" id="sand-btn-120">2 min</button>
                <button class="sand-pill"        onclick="setSandDuration(180)" id="sand-btn-180">3 min</button>
                <button class="timer-modal-close" onclick="closeTimer('sand')"></button>
            </div>

            <!-- Hourglass SVG -->
            <div class="sand-hg-wrap">
                <svg id="sandHourglass" viewBox="0 0 200 320" width="200" height="280">
                    <defs>
                        <!-- Neon glow filter -->
                        <filter id="neonGlow" x="-30%" y="-30%" width="160%" height="160%">
                            <feGaussianBlur stdDeviation="4" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="softGlow" x="-20%" y="-20%" width="140%" height="140%">
                            <feGaussianBlur stdDeviation="2.5" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <!-- Clip paths for sand areas -->
                        <clipPath id="topSandClip">
                            <path d="M34,42 L166,42 L108,148 L92,148 Z"/>
                        </clipPath>
                        <clipPath id="bottomSandClip">
                            <path d="M92,172 L108,172 L166,278 L34,278 Z"/>
                        </clipPath>
                    </defs>

                    <!-- Outer glass body glow -->
                    <path d="M30,20 L170,20 L170,42 L108,148 L108,172 L170,278 L170,300 L30,300 L30,278 L92,172 L92,148 L30,42 Z"
                          fill="rgba(0,30,40,0.6)" stroke="#00e5ff" stroke-width="2.5"
                          filter="url(#neonGlow)" stroke-linejoin="round"/>

                    <!-- Inner glass sheen -->
                    <path d="M30,20 L170,20 L170,42 L108,148 L108,172 L170,278 L170,300 L30,300 L30,278 L92,172 L92,148 L30,42 Z"
                          fill="url(#glassSheen)" opacity="0.25"/>

                    <!-- Top cap -->
                    <rect x="24" y="14" width="152" height="28" rx="8"
                          fill="rgba(0,60,80,0.7)" stroke="#00e5ff" stroke-width="2" filter="url(#softGlow)"/>
                    <!-- Bottom cap -->
                    <rect x="24" y="278" width="152" height="28" rx="8"
                          fill="rgba(0,60,80,0.7)" stroke="#00e5ff" stroke-width="2" filter="url(#softGlow)"/>

                    <!-- TOP SAND: pixelated grid -->
                    <g id="topSandPixels" clip-path="url(#topSandClip)"></g>

                    <!-- BOTTOM SAND: pixelated grid -->
                    <g id="bottomSandPixels" clip-path="url(#bottomSandClip)"></g>

                    <!-- Sand stream (needle) -->
                    <rect id="sandStream" x="98" y="146" width="4" height="28" rx="2"
                          fill="#00e5ff" filter="url(#softGlow)" opacity="0"/>
                </svg>
            </div>

            <!-- Digital readout -->
            <div id="sandTimerDisplay" class="sand-digital-display">1:00</div>

            <!-- Controls -->
            <div class="sand-controls-row">
                <button class="sand-ctrl-btn sand-ctrl-start" id="sandStartBtn" onclick="sandTimerAction()">Start</button>
                <button class="sand-ctrl-btn sand-ctrl-reset" onclick="sandTimerReset()">Reset</button>
            </div>
        </div>
    </div>

    <!-- Digital Timer Modal -->
    <div id="digitalTimerModal" class="timer-modal" style="display:none;">
        <div class="timer-modal-content">
            <button class="timer-modal-close" onclick="closeTimer('digital')"></button>
            <div class="timer-modal-title"> Digital Timer</div>
            <div class="digital-time-set" id="digitalSetControls">
                <div class="digital-unit">
                    <button class="digital-adj-btn" onclick="adjustDigital('min',1)"></button>
                    <div id="digitalMinDisplay" class="digital-unit-display">01</div>
                    <div class="digital-unit-label">MIN</div>
                    <button class="digital-adj-btn" onclick="adjustDigital('min',-1)"></button>
                </div>
                <div class="digital-colon">:</div>
                <div class="digital-unit">
                    <button class="digital-adj-btn" onclick="adjustDigital('sec',15)"></button>
                    <div id="digitalSecDisplay" class="digital-unit-display">00</div>
                    <div class="digital-unit-label">SEC</div>
                    <button class="digital-adj-btn" onclick="adjustDigital('sec',-15)"></button>
                </div>
            </div>
            <div id="digitalTimerDisplay" class="timer-big-display digital-running-display" style="display:none;">1:00</div>
            <div id="digitalTimerStatus" class="timer-status-text">Set time above</div>
            <div class="timer-controls">
                <button class="timer-btn timer-btn-primary" id="digitalStartBtn" onclick="digitalTimerAction()">Start</button>
                <button class="timer-btn timer-btn-secondary" onclick="digitalTimerReset()">Reset</button>
            </div>
        </div>
    </div>

    <!-- Chess Clock Modal -->
    <div id="chessTimerModal" class="timer-modal" style="display:none;">
        <div class="timer-modal-content chess-modal-content">
            <button class="timer-modal-close" onclick="closeTimer('chess')"></button>
            <div class="timer-modal-title"> Chess Clock</div>
            <div class="chess-durations">
                <button class="sand-duration-btn active" onclick="setChessDuration(180)" id="chess-btn-180">3 min</button>
                <button class="sand-duration-btn" onclick="setChessDuration(300)" id="chess-btn-300">5 min</button>
                <button class="sand-duration-btn" onclick="setChessDuration(600)" id="chess-btn-600">10 min</button>
                <button class="sand-duration-btn" onclick="setChessDuration(900)" id="chess-btn-900">15 min</button>
            </div>
            <div class="chess-clocks">
                <div class="chess-player-block" id="chessBlock1" onclick="chessPressClock(1)">
                    <div class="chess-player-label">Player 1</div>
                    <div class="chess-player-time" id="chessTime1">3:00</div>
                    <div class="chess-tap-hint">TAP TO SWITCH</div>
                </div>
                <div class="chess-divider"></div>
                <div class="chess-player-block" id="chessBlock2" onclick="chessPressClock(2)">
                    <div class="chess-player-label">Player 2</div>
                    <div class="chess-player-time" id="chessTime2">3:00</div>
                    <div class="chess-tap-hint">TAP TO SWITCH</div>
                </div>
            </div>
            <div id="chessTimerStatus" class="timer-status-text">Tap a player clock to start</div>
            <div class="timer-controls">
                <button class="timer-btn timer-btn-secondary" onclick="chessTimerReset()">Reset</button>
            </div>
        </div>
    </div>

    <script>
        let players = [];
        let recognition;
        let isListening = false;
        let intentionallyStopped = false; // Flag to prevent auto-restart after manual stop
        let isAddingMode = false;
        let addedPlayersInSession = [];
        let currentGameType = 'general';
        let hasAskedGameType = false;
        let isAskingGameType = false;
        let wallOfFame = {}; // Best score per game: {golf: {player, score, date}, scrabble: {...}, ...}
        let wallOfShame = {}; // Worst score per game: {golf: {player, score, date}, scrabble: {...}, ...}
        let isRenderingWalls = false; // Prevent concurrent renders
        let inputMode = 'voice'; // 'voice' or 'manual'
        let isSpeakerMuted = false;
        
        // ===== GLOBAL DELETE FUNCTIONS - Define early for immediate availability =====
        window.deleteGameScorecardFromWins = async function(gameType, index) {
            console.log(' DELETE FUNCTION CALLED:', gameType, index);
            
            // Test if customConfirm exists and is callable
            if (typeof customConfirm !== 'function') {
                console.error(' customConfirm is not a function!', typeof customConfirm);
                alert('customConfirm function not found!');
                return;
            }
            
            console.log(' customConfirm function exists');
            
            try {
                console.log(' Calling customConfirm...');
                
                // Show confirmation modal
                const confirmed = await customConfirm(
                    `Are you sure you want to delete this ${gameType} scorecard?\n\nThis action cannot be undone.`,
                    ' Delete Scorecard'
                );
                
                console.log(' customConfirm resolved with:', confirmed);
                
                if (!confirmed) {
                    console.log(' Delete cancelled by user');
                    return;
                }
                
                console.log(' User confirmed, proceeding with deletion...');
                
                // Perform deletion with proper error handling
                const storageKey = `scorekeeper_${gameType}_scorecards`;
                try {
                    const saved = localStorage.getItem(storageKey);
                    if (!saved) {
                        console.log(' No saved scorecards found');
                        return;
                    }
                    
                    const scorecards = JSON.parse(saved);
                    if (index >= 0 && index < scorecards.length) {
                        // Create new array instead of modifying existing one
                        const updatedScorecards = [...scorecards];
                        updatedScorecards.splice(index, 1);
                        localStorage.setItem(storageKey, JSON.stringify(updatedScorecards));
                        console.log(' Scorecard deleted successfully');
                        
                        // Refresh the display
                        if (window.refreshWinsTrackerScorecardsTab) {
                            window.refreshWinsTrackerScorecardsTab(gameType);
                            console.log(' Display refreshed');
                        } else {
                            console.log(' Refresh function not found');
                        }
                    } else {
                        console.error(' Invalid scorecard index:', index);
                    }
                } catch (parseError) {
                    console.error(' Error parsing stored scorecards:', parseError);
                    // Clear corrupted data
                    localStorage.removeItem(storageKey);
                    if (window.customAlert) {
                        await customAlert('Corrupted scorecard data was cleared. Please try again.', 'Data Error');
                    }
                }
                
            } catch (e) {
                console.error(' Error in delete function:', e);
                alert('Error: ' + e.message);
            }
        };

        window.deleteAllGameScorecards = async function(gameType) {
            console.log(' DELETE ALL FUNCTION CALLED:', gameType);
            try {
                const gameNames = {
                    'general': 'General',
                    'golf': 'Golf',
                    '5crowns': '5 Crowns',
                    'phase10': 'Phase 10',
                    'farkle': 'Farkle',
                    'darts': 'Darts',
                    'scrabble': 'Scrabble',
                    'yahtzee': 'Yahtzee'
                };
                
                const gameName = gameNames[gameType] || gameType;
                
                const confirmed = await customConfirm(
                    `Are you sure you want to delete ALL saved ${gameName} scorecards?\n\nThis action cannot be undone and will not affect your stats.`,
                    ' Delete All Scorecards'
                );
                
                if (!confirmed) {
                    console.log('Delete All cancelled by user');
                    return;
                }
                
                // Clear all scorecards for this game type from localStorage
                const storageKey = `scorekeeper_${gameType}_scorecards`;
                localStorage.removeItem(storageKey);
                console.log(' All scorecards deleted successfully');
                
                // Refresh the display
                if (window.refreshWinsTrackerScorecardsTab) {
                    window.refreshWinsTrackerScorecardsTab(gameType);
                    console.log('Display refreshed');
                } else {
                    console.log('Refresh function not found');
                }
                
            } catch (e) {
                console.error(' Error deleting all scorecards:', e);
                if (window.customAlert) {
                    await customAlert('Error deleting scorecards: ' + e.message, 'Error');
                }
            }
        };
        
        window.deleteGolfScorecardFromWins = async function(index) {
            console.log('Golf delete function called with:', index);
            try {
                const confirmed = await customConfirm(
                    'Are you sure you want to delete this golf scorecard?\n\nThis action cannot be undone.',
                    'Delete Scorecard'
                );
                
                if (!confirmed) return;
                
                const savedScorecards = localStorage.getItem('scorekeeper_golf_scorecards');
                if (!savedScorecards) return;
                
                let scorecards = JSON.parse(savedScorecards);
                if (index >= 0 && index < scorecards.length) {
                    scorecards.splice(index, 1);
                    localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(scorecards));
                    
                    // Refresh the display
                    if (window.refreshWinsTrackerScorecardsTab) {
                        window.refreshWinsTrackerScorecardsTab('golf');
                    } else if (window.displayWinsTracker) {
                        window.displayWinsTracker('golf');
                    }
                }
            } catch (e) {
                console.error('Error deleting golf scorecard:', e);
                await customAlert('Error deleting scorecard: ' + e.message, 'Error');
            }
        };
        
        // ===== END GLOBAL DELETE FUNCTIONS =====
        
        // ===== DARTS 501 VARIABLES =====
        let dartsPlayers = [];
        let dartsScores = {};
        let dartsCurrentPlayer = null;
        let dartsNextMultiplier = null;
        let dartsHistory = [];
        let dartsKeypadRendered = false; // Flag to prevent keypad from rendering multiple times
        let gameStarted = false;
        let dartsStartingScore = 501;
        let requireDoubleIn = true;
        let requireDoubleOut = true;
        let startingScore = 501; // Darts starting score
        
        
        function updateWalls(gameName, playerName, score, isLowerBetter) {
            // Determine if this is a best or worst score
            const currentFame = wallOfFame[gameName];
            const currentShame = wallOfShame[gameName];
            
            // Highest Score: Best score (lower is better for some games, higher for others)
            if (!currentFame) {
                // First entry for this game
                wallOfFame[gameName] = {
                    player: playerName,
                    score: score,
                    date: new Date().toISOString().split('T')[0]
                };
            } else {
                // Check if this is better than current best
                const isBetter = isLowerBetter ? (score < currentFame.score) : (score > currentFame.score);
                if (isBetter) {
                    wallOfFame[gameName] = {
                        player: playerName,
                        score: score,
                        date: new Date().toISOString().split('T')[0]
                    };
                }
            }
            
            // Lowest Score: Worst score (opposite of highest)
            if (!currentShame) {
                // First entry for this game
                wallOfShame[gameName] = {
                    player: playerName,
                    score: score,
                    date: new Date().toISOString().split('T')[0]
                };
            } else {
                // Check if this is worse than current worst
                const isWorse = isLowerBetter ? (score > currentShame.score) : (score < currentShame.score);
                if (isWorse) {
                    wallOfShame[gameName] = {
                        player: playerName,
                        score: score,
                        date: new Date().toISOString().split('T')[0]
                    };
                }
            }
            
            saveWalls();
        }
        
        function saveWalls() {
            try {
                localStorage.setItem('scorekeeper_wall_of_fame', JSON.stringify(wallOfFame));
                localStorage.setItem('scorekeeper_wall_of_shame', JSON.stringify(wallOfShame));
            } catch (e) {
                console.error('Error saving walls:', e);
            }
        }
        
        function loadWalls() {
            try {
                const savedFame = localStorage.getItem('scorekeeper_wall_of_fame');
                const savedShame = localStorage.getItem('scorekeeper_wall_of_shame');
                wallOfFame = savedFame ? JSON.parse(savedFame) : {};
                wallOfShame = savedShame ? JSON.parse(savedShame) : {};
            } catch (e) {
                console.error('Error loading walls:', e);
                wallOfFame = {};
                wallOfShame = {};
            }
        }
        
        function renderWalls() {
            if (isRenderingWalls) return;
            
            isRenderingWalls = true;
            
            const fameContainer = document.getElementById('wallOfFameContainer');
            const shameContainer = document.getElementById('wallOfShameContainer');
            
            if (!fameContainer || !shameContainer) {
                isRenderingWalls = false;
                return;
            }
            
            // Render Highest Score - with dividers between games
            const fameGames = Object.keys(wallOfFame);
            if (fameGames.length === 0) {
                fameContainer.textContent = 'No champions yet!';
            } else {
                fameContainer.innerHTML = fameGames.map((game, index) => {
                    const entry = wallOfFame[game];
                    const divider = index < fameGames.length - 1 ? '<hr style="border: none; border-top: 1px solid #555; margin: 10px 0;">' : '';
                    return `<p><b>${escapeHtml(game)}:</b><br>${escapeHtml(entry.player)}: ${entry.score} pts<br>(${entry.date})</p>${divider}`;
                }).join('');
            }
            
            // Render Lowest Score - with dividers between games
            const shameGames = Object.keys(wallOfShame);
            if (shameGames.length === 0) {
                shameContainer.textContent = 'No disasters yet!';
            } else {
                shameContainer.innerHTML = shameGames.map((game, index) => {
                    const entry = wallOfShame[game];
                    const divider = index < shameGames.length - 1 ? '<hr style="border: none; border-top: 1px solid #555; margin: 10px 0;">' : '';
                    return `<p><b>${escapeHtml(game)}:</b><br>${escapeHtml(entry.player)}: ${entry.score} pts<br>(${entry.date})</p>${divider}`;
                }).join('');
            }
            
            isRenderingWalls = false;
        }
        
        window.clearAllWalls = async function() {
            const confirmed = await customConfirm('Clear all Highest and Lowest Score records?', ' Clear All Scores');
            if (confirmed) {
                wallOfFame = {};
                wallOfShame = {};
                localStorage.removeItem('scorekeeper_wall_of_fame');
                localStorage.removeItem('scorekeeper_wall_of_shame');
                renderWalls();
            }
        }
        
        // Theme management functions
        function changeTheme() {
            // Cancel any voice operations when manually changing theme
            cancelAllVoiceOperations();
            
            const theme = document.getElementById('themeSelect').value;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('scorekeeper_theme', theme);
            console.log('Theme changed to:', theme);
        }
        
        function loadTheme() {
            const savedTheme = localStorage.getItem('scorekeeper_theme') || 'stainless';
            document.body.setAttribute('data-theme', savedTheme);
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.value = savedTheme;
            }
            
            // Update custom dropdown display
            const selectedTheme = document.getElementById('selectedTheme');
            if (selectedTheme) {
                const themeNames = {
                    'stainless': 'Steel',
                    'default': 'Neon'
                };
                selectedTheme.textContent = themeNames[savedTheme] || 'Steel';
            }
            
            console.log('Theme loaded:', savedTheme);
        }
        
        let currentTab = 'scorekeeper';
        let scoringMode = 'standard'; // 'standard', 'crowns', 'golf', or 'scrabble'
        let crownsScores = {}; // Store 5 Crowns scores by player and round
        let currentCrownsRound = {}; // Track current round index for each player
        let highlightedRound = null; // Track which round is highlighted
        let golfScores = {}; // Store Golf scores by player and hole
        let currentGolfHole = {}; // Track current hole index for each player
        let golfMode = 'simple'; // 'simple' or 'advanced'
        let currentGolfCourse = ''; // Current golf course name
        let golfCoursePar = {}; // Par values for each hole
        let golfCourseHCP = {}; // Handicap values for each hole
        let golfCourseYRD = {}; // Yards values for each hole - now stores arrays of 6 values
        let golfCourseYrdColumns = ['Blue', 'White', 'Red']; // Tee box color names (editable)
        let savedGolfCourses = {}; // Saved courses with par and HCP data
        let scrabbleScores = {}; // Store Scrabble scores by player and turn
        let currentScrabbleTurn = {}; // Track current turn index for each player
        let yahtzeeScores = {}; // Store Yahtzee scores by player and category
        let yahtzeeUsedCategories = {}; // Track which categories have been used by each player
        let phase10Scores = {}; // Store Phase 10 scores by player and phase
        let phase10Completed = {}; // Track which phases have been completed by each player
        let genericGridScores = {}; // Store generic grid scores by player and turn
        let currentGenericTurn = {}; // Track current turn index for each player
        let highlightedGenericTurn = null; // Track which turn is highlighted
        let gameInProgress = false; // Track if game has started
        let isVoiceGuidedSetup = false; // Track if we're in voice-guided setup mode
        let isDoneAdding = false; // Track if user clicked "Done Adding"
        let nextPlayerNumber = 5; // Track next player number for new fields
        let undoStack = []; // Stack for undo functionality
        const MAX_UNDO_HISTORY = 20; // Maximum number of undo actions to keep
        const CROWNS_ROUNDS = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const GOLF_HOLES = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'];
        let SCRABBLE_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Start with 12 turns
        let scrabbleMaxTurn = 12; // Track the maximum turn number
        let GENERIC_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Start with 12 turns
        let genericMaxTurn = 12; // Track the maximum turn number
        const YAHTZEE_CATEGORIES = {
            // Upper Section
            'ones': { name: 'Aces', section: 'upper', calc: 'sum' },
            'twos': { name: 'Twos', section: 'upper', calc: 'sum' },
            'threes': { name: 'Threes', section: 'upper', calc: 'sum' },
            'fours': { name: 'Fours', section: 'upper', calc: 'sum' },
            'fives': { name: 'Fives', section: 'upper', calc: 'sum' },
            'sixes': { name: 'Sixes', section: 'upper', calc: 'sum' },
            // Lower Section
            'threeKind': { name: '3 of a Kind', section: 'lower', points: 'sum' },
            'fourKind': { name: '4 of a Kind', section: 'lower', points: 'sum' },
            'fullHouse': { name: 'Full House', section: 'lower', points: 25 },
            'smStraight': { name: 'Sm. Straight', section: 'lower', points: 30 },
            'lgStraight': { name: 'Lg. Straight', section: 'lower', points: 40 },
            'yahtzee': { name: 'YAHTZEE', section: 'lower', points: 50 },
            'chance': { name: 'Chance', section: 'lower', points: 'sum' }
        };
        
        const PHASE10_PHASES = [
            { num: 1, name: '2 sets of 3' },
            { num: 2, name: '1 set of 3 + 1 run of 4' },
            { num: 3, name: '1 set of 4 + 1 run of 4' },
            { num: 4, name: '1 run of 7' },
            { num: 5, name: '1 run of 8' },
            { num: 6, name: '1 run of 9' },
            { num: 7, name: '2 sets of 4' },
            { num: 8, name: '7 cards of 1 color' },
            { num: 9, name: '1 set of 5 + 1 set of 2' },
            { num: 10, name: '1 set of 5 + 1 set of 3' }
        ];
        // Text-to-speech function
        function speak(text, protectScrabbleSpeech = false) {
            // Don't speak if speaker is muted
            if (isSpeakerMuted) {
                console.log('Speaker muted, not speaking:', text);
                return;
            }
            
            if ('speechSynthesis' in window) {
                try {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();
                    
                    // Set protection flag if requested
                    if (protectScrabbleSpeech && scrabbleIsCollectingTiles) {
                        scrabbleSpeaking = true;
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Function to set voice after voices are loaded
                    const setVoice = function() {
                        const voices = window.speechSynthesis.getVoices();
                        
                        // Look for Samantha voice (Mac system voice - female, priority)
                        let selectedVoice = voices.find(function(voice) {
                            return voice.name === 'Samantha';
                        }) || voices.find(function(voice) {
                            return voice.lang.includes('en-GB') && voice.name.toLowerCase().includes('female');
                        }) || voices.find(function(voice) {
                            return voice.lang.includes('en-GB');
                        }) || voices.find(function(voice) {
                            return voice.name.toLowerCase().includes('female') || voice.name.toLowerCase().includes('woman');
                        });
                        
                        if (selectedVoice) {
                            utterance.voice = selectedVoice;
                            console.log('Using voice:', selectedVoice.name, selectedVoice.lang);
                        } else {
                            console.log('Using default system voice');
                        }
                    };
                    
                    // Try to set voice immediately
                    setVoice();
                    
                    // Settings optimized for interruptible speech
                    utterance.rate = 0.85;  // Slower for easier interruption and clarity
                    utterance.pitch = 1.1; // Slightly higher for female voice
                    utterance.volume = 0.8; // Softer volume
                    
                    // Clear protection flag when speech ends
                    utterance.onend = function() {
                        if (protectScrabbleSpeech) {
                            scrabbleSpeaking = false;
                        }
                    };
                    
                    // Also clear on error
                    utterance.onerror = function() {
                        if (protectScrabbleSpeech) {
                            scrabbleSpeaking = false;
                        }
                    };
                    
                    // Speak (after a tiny delay to ensure cancel() took effect)
                    setTimeout(() => {
                        window.speechSynthesis.speak(utterance);
                    }, 50);
                    
                    // Return utterance so caller can attach additional handlers
                    return utterance;
                } catch (err) {
                    console.error('Error in speak function:', err);
                    if (protectScrabbleSpeech) {
                        scrabbleSpeaking = false;
                    }
                    return null;
                }
            }
            return null;
        }
        
        // Toggle speaker mute/unmute
        function toggleSpeaker() {
            isSpeakerMuted = !isSpeakerMuted;
            const speakerBtn = document.getElementById('speakerBtn');
            
            // Save speaker state
            localStorage.setItem('scorekeeper_speaker_muted', isSpeakerMuted ? 'true' : 'false');
            
            if (isSpeakerMuted) {
                speakerBtn.classList.add('speaker-muted');
                speakerBtn.title = 'Voice is muted. Click to unmute.';
                console.log('Speaker muted');
                // Cancel any ongoing speech
                if (window.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
            } else {
                speakerBtn.classList.remove('speaker-muted');
                speakerBtn.title = 'Voice is active. Click to mute.';
                console.log('Speaker unmuted');
                speak('Voice enabled');
            }
        }
        
        function loadSpeakerState() {
            const saved = localStorage.getItem('scorekeeper_speaker_muted');
            if (saved === 'true') {
                isSpeakerMuted = true;
            } else {
                isSpeakerMuted = false;
            }
            
            // Update button state
            const speakerBtn = document.getElementById('speakerBtn');
            if (speakerBtn) {
                if (isSpeakerMuted) {
                    speakerBtn.classList.add('speaker-muted');
                    speakerBtn.title = 'Voice is muted. Click to unmute.';
                } else {
                    speakerBtn.classList.remove('speaker-muted');
                    speakerBtn.title = 'Voice is active. Click to mute.';
                }
            }
            console.log('Loaded speaker state:', isSpeakerMuted ? 'muted' : 'unmuted');
        }
        
        // Show custom final scores modal
        function showFinalScoresModal(winner, finalScores, wonByTiebreaker = false) {
            const modal = document.getElementById('finalScoresModal');
            const winnerDiv = document.getElementById('finalScoresWinner');
            const listOl = document.getElementById('finalScoresList');
            
            // Set winner text with tiebreaker info if applicable
            if (wonByTiebreaker) {
                winnerDiv.textContent = ` Winner: ${winner.player.name} with ${winner.total} points! (Won on tiebreaker - highest score before final adjustments)`;
            } else {
                winnerDiv.textContent = ` Winner: ${winner.player.name} with ${winner.total} points!`;
            }
            
            // Build ranked list
            listOl.innerHTML = '';
            finalScores.forEach((item, idx) => {
                const li = document.createElement('li');
                li.textContent = `${idx + 1}. ${item.player.name}: ${item.total} points`;
                listOl.appendChild(li);
            });
            
            // Show modal
            modal.classList.add('show');
        }
        
        // Close final scores modal
        function closeFinalScoresModal() {
            // Cancel any voice operations when closing modal
            cancelAllVoiceOperations();
            
            const modal = document.getElementById('finalScoresModal');
            modal.classList.remove('show');
        }
        // ===== CUSTOM DIALOG FUNCTIONS =====
        
        // Custom Alert
        let customAlertResolver;
        
        function customAlert(message, title = ' Alert') {
            return new Promise((resolve) => {
                customAlertResolver = resolve;
                const modal = document.getElementById('customAlertModal');
                const titleEl = document.getElementById('customAlertTitle');
                const messageEl = document.getElementById('customAlertMessage');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                modal.classList.add('show');
            });
        }
        
        function closeCustomAlert() {
            const modal = document.getElementById('customAlertModal');
            modal.classList.remove('show');
            if (customAlertResolver) {
                customAlertResolver();
                customAlertResolver = null;
            }
        }
        
        // Custom Confirm
        let customConfirmResolver;
        
        // Override customConfirm to ensure it works with higher z-index
        function customConfirm(message, title = ' Confirm') {
            return new Promise((resolve) => {
                console.log(' customConfirm Promise created');
                customConfirmResolver = resolve;
                
                const modal = document.getElementById('customConfirmModal');
                const titleEl = document.getElementById('customConfirmTitle');
                const messageEl = document.getElementById('customConfirmMessage');
                
                console.log(' Modal elements found:', {
                    modal: !!modal,
                    titleEl: !!titleEl,
                    messageEl: !!messageEl
                });
                
                if (!modal || !titleEl || !messageEl) {
                    console.error(' Required modal elements not found!');
                    resolve(false);
                    return;
                }
                
                // Set content
                titleEl.textContent = title;
                messageEl.innerHTML = message;
                
                // Force very high z-index to appear above everything
                modal.style.zIndex = '99999';
                modal.style.display = 'flex';
                modal.classList.add('show');
                
                console.log(' Modal shown with z-index:', modal.style.zIndex);
                console.log(' Modal display:', modal.style.display);
                console.log(' Modal classes:', modal.classList.toString());
            });
        }
        
        function resolveCustomConfirm(result) {
            console.log(' resolveCustomConfirm called with:', result);
            const modal = document.getElementById('customConfirmModal');
            
            if (modal) {
                // Remove show class and reset styles
                modal.classList.remove('show');
                modal.style.display = 'none';
                modal.style.zIndex = ''; // Reset z-index
                console.log(' Modal hidden');
            }
            
            if (customConfirmResolver) {
                console.log(' Resolving Promise with:', result);
                customConfirmResolver(result);
                customConfirmResolver = null;
            }
        }
        
        // Golf Scorecard Save Modal (with notes)
        let golfScorecardSaveResolver;
        let golfScorecardNotes = '';
        
        function showGolfScorecardSaveModal(message) {
            return new Promise((resolve) => {
                golfScorecardSaveResolver = resolve;
                const modal = document.getElementById('golfScorecardSaveModal');
                const messageEl = document.getElementById('golfScorecardSaveMessage');
                const notesInput = document.getElementById('golfScorecardNotesInput');
                
                messageEl.innerHTML = message;
                notesInput.value = '';
                golfScorecardNotes = '';
                
                modal.classList.add('show');
            });
        }
        
        // toggleGolfNotes function removed - notes are always visible now
        
        function resolveGolfScorecardSave(action) {
            const modal = document.getElementById('golfScorecardSaveModal');
            const notesInput = document.getElementById('golfScorecardNotesInput');
            
            // Get checkbox values
            const saveWinLoss = document.getElementById('saveWinLoss').checked;
            const saveScorecard = document.getElementById('saveScorecard').checked;
            
            // Save notes if any (auto-save)
            golfScorecardNotes = notesInput.value.trim();
            const saveNotes = golfScorecardNotes.length > 0;
            
            modal.classList.remove('show');
            
            if (golfScorecardSaveResolver) {
                golfScorecardSaveResolver({
                    action: action,
                    notes: golfScorecardNotes,
                    saveWinLoss: saveWinLoss,
                    saveNotes: saveNotes,
                    saveScorecard: saveScorecard
                });
                golfScorecardSaveResolver = null;
            }
        }
        
        // Universal Game Completion Modal System
        let gameCompletionResolver = null;
        let gameCompletionNotes = '';
        let currentCompletionGameType = '';
        
        function showGameCompletionModal(gameType, message, winnerData, finalScores) {
            return new Promise((resolve) => {
                gameCompletionResolver = resolve;
                currentCompletionGameType = gameType;
                
                const modal = document.getElementById('gameCompletionModal');
                const messageEl = document.getElementById('gameCompletionMessage');
                const notesInput = document.getElementById('gameCompletionNotesInput');
                const titleEl = document.getElementById('gameCompletionTitle');
                
                // Set title and message
                const gameNames = {
                    'general': 'General',
                    'golf': 'Golf',
                    '5crowns': '5 Crowns',
                    'phase10': 'Phase 10',
                    'farkle': 'Farkle',
                    'darts': 'Darts',
                    'scrabble': 'Scrabble',
                    'yahtzee': 'Yahtzee'
                };
                
                titleEl.textContent = `${gameNames[gameType] || gameType} Complete!`;
                messageEl.innerHTML = message;
                notesInput.value = '';
                notesInput.placeholder = `Add notes about this ${gameNames[gameType] || gameType} game...`;
                gameCompletionNotes = '';
                
                // Load save preferences from localStorage (if set)
                const savedPrefs = localStorage.getItem(`scorekeeper_${gameType}_save_prefs`);
                if (savedPrefs) {
                    try {
                        const prefs = JSON.parse(savedPrefs);
                        document.getElementById('saveWinLossGeneral').checked = prefs.saveWinLoss !== false;
                        document.getElementById('saveScorecardGeneral').checked = prefs.saveScorecard === true;
                    } catch (e) {
                        // Use defaults
                        document.getElementById('saveWinLossGeneral').checked = true;
                        document.getElementById('saveScorecardGeneral').checked = false;
                    }
                } else {
                    // Defaults
                    document.getElementById('saveWinLossGeneral').checked = true;
                    document.getElementById('saveScorecardGeneral').checked = false;
                }
                
                modal.classList.add('show');
                
                // Store winner and scores data for later use
                modal.winnerData = winnerData;
                modal.finalScores = finalScores;
            });
        }
        
        function resolveGameCompletion(action) {
            const modal = document.getElementById('gameCompletionModal');
            const notesInput = document.getElementById('gameCompletionNotesInput');
            
            // Get checkbox values
            const saveWinLoss = document.getElementById('saveWinLossGeneral').checked;
            const saveScorecard = document.getElementById('saveScorecardGeneral').checked;
            
            // Save notes if any
            gameCompletionNotes = notesInput.value.trim();
            const saveNotes = gameCompletionNotes.length > 0;
            
            // Save user preferences for this game type
            const prefs = {
                saveWinLoss: saveWinLoss,
                saveScorecard: saveScorecard
            };
            localStorage.setItem(`scorekeeper_${currentCompletionGameType}_save_prefs`, JSON.stringify(prefs));
            
            modal.classList.remove('show');
            
            if (gameCompletionResolver) {
                gameCompletionResolver({
                    action: action,
                    notes: gameCompletionNotes,
                    saveWinLoss: saveWinLoss,
                    saveNotes: saveNotes,
                    saveScorecard: saveScorecard,
                    gameType: currentCompletionGameType,
                    winnerData: modal.winnerData,
                    finalScores: modal.finalScores
                });
                gameCompletionResolver = null;
            }
        }
        
        async function handleUniversalGameCompletion(gameType, winnerData, finalScores) {
            if (!winnerData || !finalScores || finalScores.length === 0) {
                const message = '<strong>Game Complete!</strong><br><br>No scores available.';
                try {
                    const result = await showGameCompletionModal(gameType, message, winnerData, finalScores);
                } catch (error) {
                    console.error('Error in game completion:', error);
                }
                return;
            }

            // Get score unit based on game type
            const getScoreUnit = (score) => {
                if (gameType === 'darts') {
                    return score === 1 ? 'leg' : 'legs';
                } else {
                    return score === 1 ? 'point' : 'points';
                }
            };

            // Check for ties - find all players with the same score as the winner
            const winnerScore = winnerData.total || winnerData.score || 0;
            const tiedWinners = finalScores.filter(score => (score.total || score.score) === winnerScore);
            
            // Create winner text with Supreme Champion format or tie format
            const winnerText = tiedWinners.length > 1 
                ? `${tiedWinners.map(w => w.name || w.player?.name).join(' and ')} tied with ${winnerScore} ${getScoreUnit(winnerScore)}!`
                : `${winnerData.name || winnerData.player?.name} is the Supreme Champion with ${winnerScore} ${getScoreUnit(winnerScore)}!`;
                
            const scoresHTML = finalScores.map((score, index) => {
                const position = index + 1;
                const name = score.name || score.player?.name || 'Unknown';
                const total = score.total || score.score || 0;
                return `${position}. ${name}: ${total}`;
            }).join('<br>');
            
            const message = `<strong>${winnerText}</strong><br><br>${scoresHTML}`;
            
            try {
                const result = await showGameCompletionModal(gameType, message, winnerData, finalScores);
                
                if (result.action === 'save') {
                    // Handle saving wins/losses
                    if (result.saveWinLoss) {
                        finalScores.forEach((playerScore, index) => {
                            const playerName = playerScore.name || playerScore.player?.name;
                            if (playerName) {
                                // Since finalScores is now sorted best-to-worst for all games,
                                // the winner is always at index 0 (first position)
                                const isWinner = index === 0;
                                updatePlayerWins(playerName, gameType, isWinner);
                            }
                        });
                    }
                    
                    // Handle saving full scorecard (to be implemented per game type)
                    if (result.saveScorecard) {
                        await saveGameScorecard(gameType, finalScores, result.notes, winnerData);
                    }
                } else {
                    await customAlert('Game completed without saving.', 'Game Complete');
                }
            } catch (error) {
                console.error('Error in game completion:', error);
                await customAlert('Error completing game: ' + error.message, 'Error');
            }
        }
        
        // Scorecard storage implementation for all game types
        async function saveGameScorecard(gameType, finalScores, notes, winnerData) {
            console.log(`Saving ${gameType} scorecard:`, {finalScores, notes, winnerData});
            
            const dateStr = new Date().toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: 'numeric' 
            });
            
            let scorecard = {
                date: dateStr,
                gameType: gameType,
                players: players.map(p => p.name),
                notes: notes || '',
                finalScores: finalScores,
                timestamp: new Date().toISOString()
            };
            
            // Add game-specific data based on game type
            switch (gameType) {
                case '5crowns':
                    scorecard.scores = {};
                    scorecard.rounds = [...CROWNS_ROUNDS];
                    players.forEach(player => {
                        scorecard.scores[player.name] = {...crownsScores[player.id]};
                    });
                    break;
                    
                case 'scrabble':
                    scorecard.scores = {};
                    scorecard.turns = [...SCRABBLE_TURNS];
                    players.forEach(player => {
                        scorecard.scores[player.name] = {...scrabbleScores[player.id]};
                    });
                    break;
                    
                case 'darts':
                    scorecard.scores = {};
                    scorecard.gameSettings = {
                        targetScore: dartsStartingScore || 501,
                        requireDoubleIn: requireDoubleIn,
                        requireDoubleOut: requireDoubleOut
                    };
                    players.forEach(player => {
                        scorecard.scores[player.name] = {
                            legs: dartsScores[player.id]?.legs || 0,
                            currentScore: dartsScores[player.id]?.score || dartsStartingScore,
                            history: dartsScores[player.id]?.history || []
                        };
                    });
                    break;
                    
                case 'yahtzee':
                    scorecard.scores = {};
                    scorecard.categories = Object.keys(YAHTZEE_CATEGORIES);
                    players.forEach(player => {
                        scorecard.scores[player.name] = {...yahtzeeScores[player.id]};
                    });
                    break;
                    
                case 'phase10':
                    scorecard.scores = {};
                    scorecard.phases = PHASE10_PHASES.map(p => p.num);
                    players.forEach(player => {
                        scorecard.scores[player.name] = {
                            scores: {...phase10Scores[player.id]},
                            completed: {...phase10Completed[player.id]}
                        };
                    });
                    break;
                    
                case 'farkle':
                case 'general':
                    scorecard.scores = {};
                    if (scoringMode === 'generic') {
                        scorecard.turns = [...GENERIC_TURNS];
                        players.forEach(player => {
                            scorecard.scores[player.name] = {...genericGridScores[player.id]};
                        });
                    } else {
                        // Simple score tracking for other modes
                        players.forEach(player => {
                            scorecard.scores[player.name] = {
                                finalScore: player.score
                            };
                        });
                    }
                    break;
                    
                default:
                    // Generic fallback - just save final scores
                    scorecard.scores = {};
                    players.forEach(player => {
                        scorecard.scores[player.name] = {
                            finalScore: player.score || 0
                        };
                    });
                    break;
            }
            
            // Load existing scorecards for this game type
            const storageKey = `scorekeeper_${gameType}_scorecards`;
            let savedScorecards = [];
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error(`Error loading ${gameType} scorecards:`, e);
                }
            }
            
            // Add new scorecard
            savedScorecards.push(scorecard);
            
            // Keep only last 50 scorecards per game type
            if (savedScorecards.length > 50) {
                savedScorecards = savedScorecards.slice(-50);
            }
            
            // Save to localStorage
            localStorage.setItem(storageKey, JSON.stringify(savedScorecards));
            
            // Game type name mapping
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            const gameName = gameNames[gameType] || gameType;
            const winner = winnerData ? winnerData.name : 'Unknown';
            const winnerScore = winnerData ? winnerData.total : 'Unknown';
            
            await customAlert(
                `Scorecard saved successfully!\n\n${gameName} Game\nDate: ${dateStr}\nWinner: ${winner} (${winnerScore})\n${notes ? `Notes: ${notes.substring(0, 50)}${notes.length > 50 ? '...' : ''}` : ''}`,
                'Scorecard Saved'
            );
            
            console.log(`Saved ${gameType} scorecard:`, scorecard);
        }
        
        // Helper functions for scorecard management across all game types
        window.loadGameScorecards = function(gameType) {
            const storageKey = `scorekeeper_${gameType}_scorecards`;
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error(`Error loading ${gameType} scorecards:`, e);
                    return [];
                }
            }
            return [];
        }
        
        window.deleteGameScorecard = function(gameType, index) {
            const storageKey = `scorekeeper_${gameType}_scorecards`;
            const scorecards = window.loadGameScorecards(gameType);
            
            if (index >= 0 && index < scorecards.length) {
                scorecards.splice(index, 1);
                localStorage.setItem(storageKey, JSON.stringify(scorecards));
                return true;
            }
            return false;
        }
        
        
        function getGameScorecardCount(gameType) {
            const scorecards = loadGameScorecards(gameType);
            return scorecards.length;
        }
        
        // Universal functions for viewing and deleting game scorecards from Wins Tracker
        function viewGameScorecardFromWins(gameType, index) {
            try {
                const scorecards = loadGameScorecards(gameType);
                if (!scorecards || scorecards.length === 0) return;
                
                // Close wins tracker modal
                document.getElementById('winsTrackerModal').classList.remove('show');
                
                // Set current viewed scorecard
                currentScorecardIndex = index;
                currentScorecardGameType = gameType;
                
                // Display the scorecard using a universal display function
                displayGameScorecard(gameType, index);
                
                // Show the saved scorecards modal
                document.getElementById('savedScorecardsModal').classList.add('show');
            } catch (e) {
                console.error('Error viewing scorecard:', e);
                customAlert('Error loading scorecard: ' + e.message, 'Error');
            }
        }
        
        // deleteGameScorecardFromWins function moved to global scope above
        
        window.refreshWinsTrackerScorecardsTab = function(gameType) {
            // Rebuild just the scorecards tab content
            const scorecardsTab = document.getElementById('winsTrackerScorecardsTab');
            if (!scorecardsTab) return;
            
            const savedScorecards = loadGameScorecards(gameType);
            let html = '';
            
            if (savedScorecards.length > 0) {
                html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                savedScorecards.reverse().forEach((scorecard, idx) => {
                    const actualIndex = savedScorecards.length - 1 - idx;
                    const dateStr = scorecard.date;
                    
                    // Handle players
                    let playerNames = '';
                    if (Array.isArray(scorecard.players)) {
                        playerNames = scorecard.players.join(', ');
                    } else if (scorecard.finalScores) {
                        playerNames = scorecard.finalScores.map(s => s.name).join(', ');
                    } else {
                        playerNames = 'Unknown';
                    }
                    
                    // Get game-specific display info
                    let gameInfo = '';
                    if (gameType === 'golf' && scorecard.course) {
                        gameInfo = scorecard.course;
                    } else {
                        // For all non-Golf games, show player names instead of technical details
                        gameInfo = playerNames;
                    }
                    
                    html += `
                        <div class="saved-scorecard-item" 
                             style="display: flex; align-items: center; justify-content: space-between; gap: 10px;
                                    cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; 
                                    transition: all 0.2s ease;">
                            <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;" onclick="viewGameScorecardFromWins('${gameType}', ${actualIndex})">
                                <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                                    <div style="font-weight: 700; color: black; flex: 1; text-align: left;">${escapeHtml(gameInfo)}</div>
                                    <div style="font-weight: 600; color: black; text-align: right;">${dateStr}</div>
                                </div>
                                ${gameType === 'golf' ? `<div style="color: black; font-size: 0.95rem; text-align: left;">${escapeHtml(playerNames)}</div>` : ''}
                            </div>
                            <button class="delete-btn" onclick="event.stopPropagation(); window.deleteGameScorecardFromWins('${gameType}', ${actualIndex})" 
                                    style="width: 36px; height: 36px; font-size: 1.2rem; flex-shrink: 0;"></button>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html = '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No scorecards saved yet.</div>';
            }
            
            scorecardsTab.innerHTML = html;
        }
        
        let currentScorecardGameType = null; // Track which game type scorecard is being viewed
        
        function displayGameScorecard(gameType, index) {
            const scorecards = loadGameScorecards(gameType);
            if (!scorecards || index >= scorecards.length) return;
            
            const scorecard = scorecards[index];
            
            // Update modal title based on game type
            const modalTitle = document.querySelector('#savedScorecardsModal .final-scores-title');
            const gameNames = {
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'scrabble': 'Scrabble',
                'darts': 'Darts',
                'yahtzee': 'Yahtzee',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'general': 'General'
            };
            if (modalTitle) {
                modalTitle.textContent = `${gameNames[gameType] || gameType} Scorecard`;
            }
            
            const scorecardDisplay = document.getElementById('scorecardDisplay');
            
            // Remove redundant scorecard text for non-Golf games, only show for Golf
            let html = `
                ${gameType !== 'golf' && gameType !== 'darts' ? `
                    <div style="margin-bottom: 15px; text-align: center; font-weight: 600; color: var(--text-primary);">
                        Date: ${scorecard.date}
                    </div>
                ` : ''}
            `;
            
            // Add game-specific information and detailed scoring
            if (gameType === 'golf' && scorecard.course) {
                // Show Course and Date on the same row
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-weight: 600;">
                        <div>Course: ${scorecard.course}</div>
                        <div>Date: ${scorecard.date}</div>
                    </div>
                `;
                
                // Show detailed tee-by-tee scoring for Golf formatted exactly like the game grid
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.95rem;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 50px; font-weight: 700; font-size: 0.85rem;">Tee</th>
                    `;
                    
                    // Calculate available width for player columns
                    const playerCount = scorecard.players.length;
                    const parColumnWidth = (scorecard.par && Object.keys(scorecard.par).length > 0) ? 40 : 0;
                    const teeColumnWidth = 50;
                    const availableWidth = `calc((100% - ${teeColumnWidth + parColumnWidth}px) / ${playerCount})`;
                    
                    // Add player columns with equal narrow width
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85rem;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    // Add par column if available with fixed narrow width
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        html += `<th style="text-align: center; background: rgba(255,255,0,0.15); width: 40px; font-weight: 700;">Par</th>`;
                    }
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Front 9 (holes 1-9)
                    for (let hole = 1; hole <= 9; hole++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(0,255,0,0.2); font-weight: 700; min-width: 40px; width: 50px; color: #0a5f0a;">${hole}</td>`;
                        
                        // Player scores for this hole
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        // Par for this hole if available
                        if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                            const par = scorecard.par[hole.toString()] || '';
                            html += `<td style="text-align: center; background: rgba(255,255,0,0.15);">${par}</td>`;
                        }
                        
                        html += `</tr>`;
                    }
                    
                    // Front 9 total row (In) with darker grid lines
                    html += `<tr style="background: rgba(255,150,180,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">In</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let front9Total = 0;
                        for (let hole = 1; hole <= 9; hole++) {
                            front9Total += scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${front9Total || ''}</td>`;
                    });
                    
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        let front9Par = 0;
                        for (let hole = 1; hole <= 9; hole++) {
                            front9Par += parseInt(scorecard.par[hole.toString()] || 0);
                        }
                        html += `<td style="text-align: center; font-weight: 800; background: rgba(255,255,0,0.3); color: #000;">${front9Par || ''}</td>`;
                    }
                    
                    html += `</tr>`;
                    
                    // Back 9 (holes 10-18)
                    for (let hole = 10; hole <= 18; hole++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(0,255,0,0.2); font-weight: 700; min-width: 40px; width: 50px; color: #0a5f0a;">${hole}</td>`;
                        
                        // Player scores for this hole
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        // Par for this hole if available
                        if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                            const par = scorecard.par[hole.toString()] || '';
                            html += `<td style="text-align: center; background: rgba(255,255,0,0.15);">${par}</td>`;
                        }
                        
                        html += `</tr>`;
                    }
                    
                    // Back 9 total row (Out) with darker grid lines
                    html += `<tr style="background: rgba(255,150,180,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Out</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let back9Total = 0;
                        for (let hole = 10; hole <= 18; hole++) {
                            back9Total += scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${back9Total || ''}</td>`;
                    });
                    
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        let back9Par = 0;
                        for (let hole = 10; hole <= 18; hole++) {
                            back9Par += parseInt(scorecard.par[hole.toString()] || 0);
                        }
                        html += `<td style="text-align: center; font-weight: 800; background: rgba(255,255,0,0.3); color: #000;">${back9Par || ''}</td>`;
                    }
                    
                    html += `</tr>`;
                    
                    // Total row (Tot.) with darker grid lines
                    html += `<tr style="background: rgba(255,150,180,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Tot.</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let hole = 1; hole <= 18; hole++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][hole.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    if (scorecard.par && Object.keys(scorecard.par).length > 0) {
                        let totalPar = 0;
                        for (let hole = 1; hole <= 18; hole++) {
                            totalPar += parseInt(scorecard.par[hole.toString()] || 0);
                        }
                        html += `<td style="text-align: center; font-weight: 800; background: rgba(255,255,0,0.3); color: #000;">${totalPar || ''}</td>`;
                    }
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === '5crowns') {
                // Show detailed round-by-round scoring for 5 Crowns in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.95rem;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns with equal width distribution
                    const playerCount = scorecard.players.length;
                    const roundColumnWidth = 40;
                    const availableWidth = `calc((100% - ${roundColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85rem;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // 5 Crowns rounds
                    const crownsRounds = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    
                    crownsRounds.forEach(round => {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${round}</td>`;
                        
                        // Player scores for this round
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][round] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    });
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        crownsRounds.forEach(round => {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][round] || 0) : 0;
                        });
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'scrabble') {
                // Show detailed turn-by-turn scoring for Scrabble in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.95rem;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const turnColumnWidth = 40;
                    const availableWidth = `calc((100% - ${turnColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85rem;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Scrabble turns (1-12 or however many were played)
                    const maxTurns = scorecard.turns ? scorecard.turns.length : 12;
                    for (let turn = 1; turn <= maxTurns; turn++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${turn}</td>`;
                        
                        // Player scores for this turn
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    }
                    
                    // Unplayed Tiles row (matching main table styling)
                    html += `<tr>`;
                    html += `<td style="text-align: center; background: rgba(255,0,110,0.1); font-weight: 700; width: 40px;">Unplayed Tiles</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        const unplayedScore = scorecard.scores[playerName] ? (scorecard.scores[playerName]['unplayed'] || 0) : 0;
                        // Display as negative number (except 0) to match main table
                        const displayScore = unplayedScore === 0 ? 0 : -unplayedScore;
                        html += `<td style="text-align: center; background: rgba(255,0,110,0.1); white-space: nowrap;">${displayScore}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    // Opponents' Tiles row (matching main table styling)
                    html += `<tr>`;
                    html += `<td style="text-align: center; background: rgba(0,245,255,0.1); font-weight: 700; width: 40px;">Opponents' Tiles</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        const opponentsScore = scorecard.scores[playerName] ? (scorecard.scores[playerName]['opponents'] || 0) : 0;
                        html += `<td style="text-align: center; background: rgba(0,245,255,0.1); white-space: nowrap;">${opponentsScore}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    // Total Points row (matching main table styling)
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total Points</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let turn = 1; turn <= maxTurns; turn++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                        }
                        // Apply adjustments: subtract unplayed tiles and add opponents' tiles
                        if (scorecard.scores[playerName]) {
                            totalScore -= (scorecard.scores[playerName]['unplayed'] || 0);  // Subtract unplayed
                            totalScore += (scorecard.scores[playerName]['opponents'] || 0);  // Add opponents
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'farkle') {
                // Show detailed turn-by-turn scoring for Farkle in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.95rem;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const turnColumnWidth = 40;
                    const availableWidth = `calc((100% - ${turnColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85rem;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Get maximum turns from the scorecard data
                    let maxTurns = 0;
                    scorecard.players.forEach(playerName => {
                        if (scorecard.scores[playerName]) {
                            const playerTurns = Object.keys(scorecard.scores[playerName]).filter(key => !isNaN(key)).length;
                            maxTurns = Math.max(maxTurns, playerTurns);
                        }
                    });
                    
                    // Farkle turns
                    for (let turn = 1; turn <= maxTurns; turn++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${turn}</td>`;
                        
                        // Player scores for this turn
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    }
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let turn = 1; turn <= maxTurns; turn++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'general') {
                // Show detailed turn-by-turn scoring for General games in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.95rem;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 40px; font-weight: 700;"></th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const turnColumnWidth = 40;
                    const availableWidth = `calc((100% - ${turnColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85rem;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Get maximum turns from the scorecard data
                    let maxTurns = 0;
                    scorecard.players.forEach(playerName => {
                        if (scorecard.scores[playerName]) {
                            const playerTurns = Object.keys(scorecard.scores[playerName]).filter(key => !isNaN(key)).length;
                            maxTurns = Math.max(maxTurns, playerTurns);
                        }
                    });
                    
                    // General game turns
                    for (let turn = 1; turn <= maxTurns; turn++) {
                        html += `<tr>`;
                        html += `<td style="text-align: center; background: rgba(128,128,128,0.3); font-weight: 700; width: 40px;">${turn}</td>`;
                        
                        // Player scores for this turn
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                            html += `<td style="text-align: center; white-space: nowrap;">${score || ''}</td>`;
                        });
                        
                        html += `</tr>`;
                    }
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">Total</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        for (let turn = 1; turn <= maxTurns; turn++) {
                            totalScore += scorecard.scores[playerName] ? (scorecard.scores[playerName][turn.toString()] || 0) : 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'yahtzee') {
                // Show detailed category-by-category scoring for Yahtzee in grid format
                if (scorecard.scores && Object.keys(scorecard.scores).length > 0) {
                    html += `
                        <div style="margin-bottom: 15px;">
                            <div style="width: 100%; max-width: 100%; overflow: hidden;">
                                <table class="crowns-table" style="width: 100%; table-layout: fixed; border-collapse: collapse; font-size: 0.95rem;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: center; background: rgba(128,128,128,0.3); width: 120px; font-weight: 700;">Category</th>
                    `;
                    
                    // Add player columns
                    const playerCount = scorecard.players.length;
                    const categoryColumnWidth = 120;
                    const availableWidth = `calc((100% - ${categoryColumnWidth}px) / ${playerCount})`;
                    
                    scorecard.players.forEach(playerName => {
                        html += `<th style="text-align: center; width: ${availableWidth}; font-weight: 700; font-size: 0.85rem;">${escapeHtml(playerName)}</th>`;
                    });
                    
                    html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    // Upper Section
                    html += '<tr style="background: rgba(0, 245, 255, 0.2); border-top: 3px solid #666; border-bottom: 3px solid #666;"><td style="text-align: center; font-weight: 800; color: #000;">UPPER SECTION</td>';
                    scorecard.players.forEach(() => {
                        html += '<td style="text-align: center; font-weight: 800; color: #000;"></td>';
                    });
                    html += '</tr>';
                    
                    const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
                    const upperNames = ['Ones', 'Twos', 'Threes', 'Fours', 'Fives', 'Sixes'];
                    
                    upperCategories.forEach((cat, idx) => {
                        html += `<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700; width: 120px;">${upperNames[idx]}</td>`;
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][cat] || 0) : 0;
                            html += `<td style="text-align: center; background: ${score > 0 ? 'rgba(0, 123, 255, 0.6)' : 'rgba(0, 245, 255, 0.15)'};">${score || '-'}</td>`;
                        });
                        html += '</tr>';
                    });
                    
                    // Upper Bonus
                    html += '<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700;">Bonus 35 (if 63)</td>';
                    scorecard.players.forEach(playerName => {
                        const upperBonus = scorecard.scores[playerName] ? (scorecard.scores[playerName]['upperBonus'] || 0) : 0;
                        html += `<td style="text-align: center; font-weight: 700; color: ${upperBonus > 0 ? '#28a745' : 'inherit'};">${upperBonus > 0 ? '+35' : '-'}</td>`;
                    });
                    html += '</tr>';
                    
                    // Lower Section
                    html += '<tr style="background: rgba(0, 245, 255, 0.2); border-top: 3px solid #666; border-bottom: 3px solid #666;"><td style="text-align: center; font-weight: 800; color: #000;">LOWER SECTION</td>';
                    scorecard.players.forEach(() => {
                        html += '<td style="text-align: center; font-weight: 800; color: #000;"></td>';
                    });
                    html += '</tr>';
                    
                    const lowerCategories = [
                        { key: 'threeKind', name: '3 of a Kind' },
                        { key: 'fourKind', name: '4 of a Kind' },
                        { key: 'fullHouse', name: 'Full House' },
                        { key: 'smStraight', name: 'Sm Straight' },
                        { key: 'lgStraight', name: 'Lg Straight' },
                        { key: 'yahtzee', name: 'Yahtzee' },
                        { key: 'chance', name: 'Chance' }
                    ];
                    
                    lowerCategories.forEach(cat => {
                        html += `<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700; width: 120px;">${cat.name}</td>`;
                        scorecard.players.forEach(playerName => {
                            const score = scorecard.scores[playerName] ? (scorecard.scores[playerName][cat.key] || 0) : 0;
                            html += `<td style="text-align: center; background: ${score > 0 ? 'rgba(0, 123, 255, 0.6)' : 'rgba(0, 245, 255, 0.15)'};">${score || '-'}</td>`;
                        });
                        html += '</tr>';
                    });
                    
                    // Yahtzee Bonus
                    html += '<tr><td style="background: rgba(128,128,128,0.3); font-weight: 700;">Yahtzee Bonus</td>';
                    scorecard.players.forEach(playerName => {
                        const bonus = scorecard.scores[playerName] ? (scorecard.scores[playerName]['yahtzeeBonus'] || 0) : 0;
                        html += `<td style="text-align: center; font-weight: 700; color: ${bonus > 0 ? '#28a745' : 'inherit'};">${bonus > 0 ? bonus : '-'}</td>`;
                    });
                    html += '</tr>';
                    
                    // Total row
                    html += `<tr style="background: rgba(255,192,203,0.6); border-top: 3px solid #666; border-bottom: 3px solid #666;">`;
                    html += `<td style="text-align: center; font-weight: 800; color: #000;">GRAND TOTAL</td>`;
                    
                    scorecard.players.forEach(playerName => {
                        let totalScore = 0;
                        if (scorecard.scores[playerName]) {
                            // Upper section
                            upperCategories.forEach(cat => {
                                totalScore += scorecard.scores[playerName][cat] || 0;
                            });
                            // Upper bonus
                            totalScore += scorecard.scores[playerName]['upperBonus'] || 0;
                            // Lower section
                            lowerCategories.forEach(cat => {
                                totalScore += scorecard.scores[playerName][cat.key] || 0;
                            });
                            // Yahtzee bonus
                            totalScore += scorecard.scores[playerName]['yahtzeeBonus'] || 0;
                        }
                        html += `<td style="text-align: center; font-weight: 800; color: #000;">${totalScore || ''}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (gameType === 'darts' && scorecard.gameSettings) {
                // Build the game description based on double in/out settings
                let gameDesc = '';
                const hasDoubleIn = scorecard.gameSettings.requireDoubleIn;
                const hasDoubleOut = scorecard.gameSettings.requireDoubleOut;
                
                if (hasDoubleIn && hasDoubleOut) {
                    gameDesc = 'Double In/Out';
                } else if (hasDoubleIn && !hasDoubleOut) {
                    gameDesc = 'Double In';
                } else if (!hasDoubleIn && hasDoubleOut) {
                    gameDesc = 'Double Out';
                } else {
                    gameDesc = 'Any In/Out';
                }
                
                // Show Game and Date on the same row (like Golf Course and Date)
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-weight: 600;">
                        <div>Game: ${scorecard.gameSettings.targetScore} (${gameDesc})</div>
                        <div>Date: ${scorecard.date}</div>
                    </div>
                `;
            }
            
            // Show final scores (but not for Golf, Farkle, General, or Yahtzee - they show detailed grids instead)
            if (!['golf', 'farkle', 'general', 'yahtzee'].includes(gameType)) {
                // Sort scores from best to worst based on game type
                const isLowerScoreWins = ['5crowns', 'golf', 'phase10'].includes(gameType);
                const sortedScores = [...scorecard.finalScores].sort((a, b) => {
                    return isLowerScoreWins ? a.total - b.total : b.total - a.total;
                });
                
                html += `
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; color: var(--text-primary);">Final Scores</h4>
                        <table class="crowns-table" style="width: 100%;">
                            <thead>
                                <tr>
                                    <th style="text-align: left;">Player</th>
                                    <th style="text-align: right;">Score</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                sortedScores.forEach(score => {
                    html += `
                        <tr>
                            <td style="text-align: left;">${score.name}</td>
                            <td style="text-align: right; font-weight: 600;">${score.total}</td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // Show notes if any
            if (scorecard.notes && scorecard.notes.trim()) {
                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                        <h4 style="margin-bottom: 8px; color: var(--text-primary);">Notes</h4>
                        <div style="color: black;">${escapeHtml(scorecard.notes)}</div>
                    </div>
                `;
            }
            
            // TODO: Add detailed scoring breakdown for each game type in future phases
            
            scorecardDisplay.innerHTML = html;
        }
        
        // Custom Prompt
        let customPromptResolver;
        
        function customPrompt(message, defaultValue = '', title = ' Input') {
            return new Promise((resolve) => {
                customPromptResolver = resolve;
                const modal = document.getElementById('customPromptModal');
                const titleEl = document.getElementById('customPromptTitle');
                const messageEl = document.getElementById('customPromptMessage');
                const inputEl = document.getElementById('customPromptInput');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                inputEl.value = defaultValue;
                modal.classList.add('show');
                
                // Focus and select input
                setTimeout(() => {
                    inputEl.focus();
                    inputEl.select();
                }, 100);
                
                // Handle Enter key
                inputEl.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        resolveCustomPrompt(inputEl.value);
                    }
                };
            });
        }
        
        function resolveCustomPrompt(result) {
            const modal = document.getElementById('customPromptModal');
            modal.classList.remove('show');
            if (customPromptResolver) {
                customPromptResolver(result);
                customPromptResolver = null;
            }
        }
        // Load voices when they become available (needed for Safari/Brave)
        if ('speechSynthesis' in window) {
            // Safari needs this event listener
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = function() {
                    const voices = window.speechSynthesis.getVoices();
                    console.log('Voices loaded:', voices.length, 'voices available');
                };
            }
            
            // Also try to load voices immediately
            setTimeout(function() {
                const voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    console.log('Voices available:', voices.length);
                }
            }, 100);
        }
        // Initialize speech recognition with comprehensive error handling
        function initSpeechRecognition() {
            console.log('=== Initializing Speech Recognition ===');
            try {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.warn('Speech Recognition API not available');
                    return false;
                }
                
                console.log('Speech Recognition API available');
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                // Configure recognition with error handling
                recognition.continuous = true;
                recognition.interimResults = true; // Enable interim results for faster interruption
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;
                
                console.log(' Speech recognition initialized successfully');
                console.log('Recognition object:', recognition);
                
                // Add error recovery for recognition failures
                let consecutiveErrors = 0;
                const maxErrors = 3;
                
                recognition.onstart = function() {
                    console.log('Recognition started - onstart event. intentionallyStopped:', intentionallyStopped);
                    consecutiveErrors = 0; // Reset error counter on successful start
                    
                    // Don't re-enable if we intentionally stopped
                    if (intentionallyStopped) {
                        console.log('Ignoring onstart because we intentionally stopped - NOT calling stop()');
                        return;
                    }
                    
                    isListening = true;
                    updateVoiceButtonState();
                    if (isAddingMode) {
                        showVoiceFeedback('Say names... (say "done" when finished)', '');
                    } else if (isAskingGameType) {
                        showVoiceFeedback('Listening for game type...', 'Interrupt anytime by speaking');
                    } else if (scrabbleIsCollectingTiles) {
                        // Already handled in askForUnplayedTiles
                    } else {
                        showVoiceFeedback('Listening...', 'Speak anytime');
                    }
                };
                    recognition.onresult = function(event) {
                        try {
                            const lastResult = event.results[event.results.length - 1];
                            const transcript = lastResult[0].transcript.toLowerCase().trim();
                            
                            // AGGRESSIVELY cancel speech when any speech detected
                            // EXCEPT during protected Scrabble speech
                            if (window.speechSynthesis && window.speechSynthesis.speaking && !scrabbleSpeaking) {
                                // Cancel multiple times to ensure it stops
                                window.speechSynthesis.cancel();
                                setTimeout(() => {
                                    window.speechSynthesis.cancel();
                                }, 10);
                                console.log(' Speech interrupted by user');
                            }
                            
                            // Only process final results (ignore interim)
                            if (lastResult.isFinal) {
                                console.log('Heard (final):', transcript);
                                processVoiceCommand(transcript);
                            } else {
                                // Interim result - shows user started speaking
                                console.log('User speaking (interim)...');
                            }
                        } catch (err) {
                            console.error('Error processing result:', err);
                        }
                    };
                    recognition.onerror = function(event) {
                        console.error('=== Speech recognition error ===');
                        console.error('Error type:', event.error);
                        console.error('Error message:', event.message);
                        
                        consecutiveErrors++;
                        console.log(`Consecutive errors: ${consecutiveErrors}/${maxErrors}`);
                        
                        // Handle no-speech gracefully - don't stop listening
                        if (event.error === 'no-speech') {
                            console.log('No speech detected - continuing');
                            return;
                        }
                        
                        // Handle aborted gracefully
                        if (event.error === 'aborted') {
                            console.log('Recognition aborted');
                            return;
                        }
                        
                        // Handle not-allowed during automatic restart or immediate start
                        if (event.error === 'not-allowed') {
                            console.log('not-allowed error - microphone permission denied');
                            isListening = false;
                            updateVoiceButtonState();
                            hideVoiceFeedback();
                            
                            // If this was from a forced start (Start Voice Recognition button)
                            if (isVoiceGuidedSetup) {
                                // Exit voice-guided setup and return to manual mode
                                isVoiceGuidedSetup = false;
                                updateGameStateButton();
                                customAlert('Microphone access is required for voice recognition. Please click the microphone icon in your browser\'s address bar and allow access, then try again.', ' Microphone Permission Required');
                            }
                            return;
                        }
                        
                        // Handle other errors
                        hideVoiceFeedback();
                        isListening = false;
                        isAddingMode = false;
                        addedPlayersInSession = [];
                        updateVoiceButtonState();
                        
                        if (event.error === 'permission-denied') {
                            // If this was from a forced start, exit voice-guided setup
                            if (isVoiceGuidedSetup) {
                                isVoiceGuidedSetup = false;
                                updateGameStateButton();
                            }
                            customAlert('Microphone access was denied. To use voice recognition:\n\n1. Click the microphone icon in your browser\'s address bar\n2. Select "Allow" for microphone access\n3. Refresh the page and try again', ' Microphone Access Required');
                        } else if (event.error === 'network') {
                            customAlert('Network error. Please check your internet connection.', ' Network error');
                        } else {
                            console.error('Unhandled error:', event.error);
                        }
                    };
                    recognition.onend = function() {
                        console.log('=== Recognition onend fired ===');
                        console.log('State before onend handling:', { isListening, intentionallyStopped });
                        
                        // If intentionally stopped, don't mess with the button state
                        // It's already been set correctly
                        if (intentionallyStopped) {
                            console.log('Was intentionally stopped - clearing flag');
                            intentionallyStopped = false;
                            console.log('intentionallyStopped cleared, ready for next start');
                            return;
                        }
                        
                        // Only update state if recognition ended unexpectedly
                        if (isListening) {
                            console.log('Recognition ended unexpectedly - turning off voice');
                            isListening = false;
                            updateVoiceButtonState();
                            hideVoiceFeedback();
                        }
                        
                        console.log('State after onend handling:', { isListening, intentionallyStopped });
                    };
                    
            } catch (err) {
                console.error(' Failed to initialize speech recognition:', err);
            }
            console.log('=== Speech Recognition Initialization Complete ===');
            console.log('Recognition object exists:', !!recognition);
            
            // Set initial voice button state
            updateVoiceButtonState();
            
            // Debug the microphone button state
            setTimeout(() => {
                const voiceBtn = document.getElementById('voiceBtn');
                console.log('=== MICROPHONE DEBUG ===');
                console.log('Voice button element:', voiceBtn);
                console.log('Has listening class:', voiceBtn?.classList.contains('listening'));
                console.log('Button classes:', voiceBtn?.className);
                const muteLine = voiceBtn?.querySelector('.mic-mute-line');
                console.log('Mute line element:', muteLine);
                if (muteLine) {
                    console.log('Mute line computed display:', window.getComputedStyle(muteLine).display);
                    console.log('Mute line inline style:', muteLine.style.display);
                }
            }, 500);
        }
        // Handle microphone button clicks
        
        function startVoiceInput() {
            console.log(' startVoiceInput() CALLED');
            
            const voiceBtn = document.getElementById('voiceBtn');
            if (voiceBtn) {
                console.log('Voice button state:', {
                    disabled: voiceBtn.disabled,
                    className: voiceBtn.className,
                    text: voiceBtn.textContent
                });
            }
            
            console.log('=== startVoiceInput called ===');
            console.log('recognition object:', !!recognition);
            console.log('isListening:', isListening);
            console.log('intentionallyStopped:', intentionallyStopped);
            
            if (!recognition) {
                console.error('Recognition object not initialized');
                customAlert('Voice recognition is not supported on this device/browser. Please use Safari on iOS or Chrome on Android.', ' Voice not supported');
                return;
            }
            if (isListening) {
                // STOPPING - always allow stop regardless of mode
                console.log('>>> STOPPING voice recognition...');
                try {
                    // Set states immediately for instant UI feedback
                    intentionallyStopped = true; // Prevent auto-restart
                    isListening = false; // Set immediately
                    console.log('Set intentionallyStopped=true, isListening=false');
                    
                    // Update button state IMMEDIATELY - twice for redundancy
                    updateVoiceButtonState(); // Update button state
                    
                    // Force immediate visual update
                    const voiceBtn = document.getElementById('voiceBtn');
                    if (voiceBtn) {
                        voiceBtn.classList.remove('listening');
                        voiceBtn.innerHTML = `
                            <svg class="mic-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 15C13.66 15 15 13.66 15 12V6C15 4.34 13.66 3 12 3C10.34 3 9 4.34 9 6V12C9 13.66 10.34 15 12 15Z" fill="currentColor"/>
                                <path d="M17 11C17 14.31 14.31 17 11 17H13C16.31 17 19 14.31 19 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M7 11C7 14.31 9.69 17 13 17H11C7.69 17 5 14.31 5 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M12 17V21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M9 21H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                        `;
                        voiceBtn.setAttribute('aria-label', 'Start voice input');
                    }
                    
                    // Hide feedback immediately
                    hideVoiceFeedback();
                    
                    // Now stop recognition
                    recognition.stop();
                    console.log('Recognition stop() called successfully');
                } catch (e) {
                    console.error('Error stopping recognition:', e);
                    intentionallyStopped = true;
                    isListening = false;
                    updateVoiceButtonState();
                    hideVoiceFeedback();
                }
            } else {
                // STARTING - check if in manual mode
                if (inputMode === 'manual') {
                    showVoiceFeedback('Voice Input Disabled', 'Open menu () and switch to Voice mode to enable voice input.');
                    setTimeout(hideVoiceFeedback, 3000);
                    return;
                }
                
                console.log('>>> STARTING voice recognition...');
                intentionallyStopped = false; // Clear the flag when starting
                console.log('Cleared intentionallyStopped flag');
                
                // Check if recognition is already running and prevent race conditions
                try {
                    if (isListening || !recognition) {
                        console.log('Recognition already running or not available');
                        return;
                    }
                    
                    isListening = true; // Set BEFORE starting recognition
                    updateVoiceButtonState(); // Update button state immediately
                    recognition.start();
                    console.log('Recognition start() called, isListening:', isListening);
                } catch (e) {
                    console.error('Error starting recognition:', e);
                    
                    if (e.name === 'InvalidStateError') {
                        console.log('Recognition not ready yet - retrying in 100ms...');
                        // Recognition might still be stopping - retry after a short delay
                        setTimeout(() => {
                            try {
                                isListening = true;
                                updateVoiceButtonState();
                                recognition.start();
                                console.log('Recognition started after retry');
                            } catch (retryError) {
                                console.error('Retry failed:', retryError);
                                isListening = false;
                                intentionallyStopped = false;
                                updateVoiceButtonState();
                                customAlert('Could not start voice recognition. Please try again.', ' Voice error');
                            }
                        }, 100);
                    } else if (e.name === 'NotAllowedError') {
                        isListening = false;
                        intentionallyStopped = false;
                        updateVoiceButtonState();
                        customAlert('Microphone access denied. Please enable microphone permissions in your browser settings and reload the page.', ' Microphone access');
                    } else {
                        isListening = false;
                        intentionallyStopped = false;
                        updateVoiceButtonState();
                        customAlert('Error starting voice recognition: ' + e.message, ' Voice error');
                    }
                }
            }
            console.log('=== startVoiceInput completed ===');
            console.log('Final state:', { isListening, intentionallyStopped });
        }
        function updateVoiceButtonState() {
            const voiceBtn = document.getElementById('voiceBtn');
            const headerVoiceBtn = document.getElementById('headerVoiceBtn');
            
            console.log('updateVoiceButtonState called, isListening:', isListening);
            
            if (isListening) {
                if (voiceBtn) {
                    voiceBtn.classList.add('listening');
                    voiceBtn.setAttribute('aria-label', 'Stop listening');
                    console.log('Button updated to: Listening - STRIKETHROUGH HIDDEN');
                }
                if (headerVoiceBtn) {
                    headerVoiceBtn.classList.add('listening');
                }
            } else {
                if (voiceBtn) {
                    voiceBtn.classList.remove('listening');
                    voiceBtn.setAttribute('aria-label', 'Start voice input');
                    voiceBtn.title = 'Click to start voice input';
                    console.log('Button updated to: Ready - STRIKETHROUGH VISIBLE');
                }
                if (headerVoiceBtn) {
                    headerVoiceBtn.classList.remove('listening');
                }
            }
        }
        function askForGameType(forceAsk = false) {
            if (!recognition) {
                console.log('Speech recognition not available');
                customAlert('Voice recognition is not supported on this device/browser. Please use Safari on iOS or Chrome on Android.', ' Voice not supported');
                return;
            }
            
            console.log('askForGameType called - forceAsk:', forceAsk, 'isSpeakerMuted:', isSpeakerMuted, 'isAskingGameType:', isAskingGameType, 'isListening:', isListening);
            
            // When forcing (from Start Voice Recognition button), always enable both mic and speaker
            if (forceAsk) {
                console.log('Start Voice Recognition clicked - enabling microphone and speaker');
                
                // ALWAYS unmute speaker when starting voice recognition, regardless of current state
                console.log('Force unmuting speaker for voice recognition');
                isSpeakerMuted = false;
                localStorage.setItem('scorekeeper_speaker_muted', 'false');
                const speakerBtn = document.getElementById('speakerBtn');
                if (speakerBtn) {
                    speakerBtn.classList.remove('speaker-muted');
                    speakerBtn.title = 'Voice is active. Click to mute.';
                }
                console.log('Speaker force-unmuted, isSpeakerMuted is now:', isSpeakerMuted);
                
                // Re-enable microphone controls visually
                const voiceBtn = document.getElementById('voiceBtn');
                const headerVoiceBtn = document.getElementById('headerVoiceBtn');
                
                if (voiceBtn) {
                    voiceBtn.classList.remove('disabled');
                    voiceBtn.style.opacity = '1';
                    voiceBtn.setAttribute('aria-label', 'Voice recognition enabled');
                    console.log('Microphone controls enabled');
                }
                
                if (headerVoiceBtn) {
                    headerVoiceBtn.classList.remove('disabled');
                    headerVoiceBtn.style.opacity = '1';
                }
                
                // Ensure recognition can start (clear any previous stopped state)
                intentionallyStopped = false;
                
                // Show brief visual feedback that both mic and speaker are enabled
                showVoiceFeedback(' Voice Recognition Enabled', 'Microphone and speaker activated');
                setTimeout(() => {
                    hideVoiceFeedback();
                }, 1500);
            }
            
            // When not forcing (automatic calls), respect mute state and previous asking
            if (!forceAsk) {
                // Check if speaker is muted - only when not forcing
                if (isSpeakerMuted) {
                    console.log('Speaker is muted, skipping voice prompt');
                    return;
                }
                
                // Prevent multiple calls - only when not forcing
                if (isAskingGameType && isListening) {
                    console.log('Already asking for game type and listening - skipping duplicate call');
                    return;
                }
            }
            
            console.log('Proceeding with askForGameType - Setting isAskingGameType = true');
            isAskingGameType = true;
            hasAskedGameType = true;
            localStorage.setItem('scorekeeper_asked_gametype', 'true');
            
            // Show feedback that we're speaking the prompt
            showVoiceFeedback('Speaking...', 'You can interrupt at any time');
            
            // STOP recognition before speaking to prevent self-listening cutout
            if (isListening) {
                console.log('Stopping recognition before speaking to prevent cutout');
                try {
                    intentionallyStopped = true; // Mark as intentional so it doesn't auto-restart
                    recognition.stop();
                    isListening = false;
                    updateVoiceButtonState();
                } catch (e) {
                    console.error('Error stopping recognition before speech:', e);
                }
            }
            
            // Speak the prompt
            const promptText = 'Welcome Player One! What game are we playing today? Say Golf, 5 Crowns, Phase 10, Farkle, Darts, Scrabble, Yahtzee, or General.';
            
            console.log('About to speak prompt:', promptText);
            console.log('isSpeakerMuted before speak call:', isSpeakerMuted);
            const utterance = speak(promptText);
            console.log('speak() returned:', utterance);
            
            // Start recognition AFTER speaking finishes
            if (utterance) {
                console.log('Setting up utterance handlers');
                utterance.onend = function() {
                    console.log('Game type prompt finished - starting recognition');
                    showVoiceFeedback('Listening...', 'Say your game choice now');
                    // Start recognition after speech ends
                    try {
                        intentionallyStopped = false;
                        isListening = true;
                        recognition.start();
                        updateVoiceButtonState();
                        console.log(' Recognition started after prompt finished');
                    } catch (e) {
                        console.error('Error starting recognition:', e);
                        if (e.name === 'InvalidStateError') {
                            console.log('Recognition already running');
                            isListening = true;
                        }
                    }
                };
                
                utterance.onerror = function(e) {
                    console.log('Speech error, ensuring recognition is running:', e);
                    showVoiceFeedback('Listening...', 'Say your game choice now');
                    if (!isListening) {
                        try {
                            intentionallyStopped = false;
                            isListening = true;
                            recognition.start();
                            updateVoiceButtonState();
                        } catch (e) {
                            console.error('Error starting recognition:', e);
                        }
                    }
                };
            } else {
                // Fallback: start recognition immediately if no utterance
                console.log('No utterance returned, ensuring recognition is running');
                showVoiceFeedback('Listening for game type...', 'Say your game choice now');
                if (!isListening) {
                    try {
                        intentionallyStopped = false;
                        isListening = true;
                        recognition.start();
                        updateVoiceButtonState();
                        console.log(' Recognition started (fallback)');
                    } catch (e) {
                        console.error('Error starting recognition:', e);
                        if (e.name === 'InvalidStateError') {
                            console.log('Recognition already running');
                            isListening = true;
                            updateVoiceButtonState();
                        }
                    }
                }
            }
        }
        function startNewGame() {
            console.log('startNewGame called');
            
            // If already in ANY specific game mode (not general), just restart that game mode
            if (currentGameType !== 'general' && players.length > 0) {
                console.log('Restarting', currentGameType, 'game with existing players');
                gameInProgress = true;
                updateGameStateButton();
                
                // Restart the specific game mode
                if (currentGameType === 'darts') {
                    startGameDarts();
                } else if (currentGameType === '5crowns') {
                    // Reset 5 Crowns scores
                    players.forEach(player => {
                        crownsScores[player.id] = {};
                        CROWNS_ROUNDS.forEach(round => {
                            crownsScores[player.id][round] = 0;
                        });
                    });
                    currentCrownsRound = {};
                    saveCrownsScores();
                    renderCrownsTable();
                } else if (currentGameType === 'golf') {
                    // Reset golf scores
                    players.forEach(player => {
                        golfScores[player.id] = {};
                    });
                    currentGolfHole = {};
                    renderGolfTable();
                } else if (currentGameType === 'farkle' || scoringMode === 'generic') {
                    // Reset generic grid scores for Farkle and other generic grid games
                    genericGridScores = {};
                    currentGenericTurn = {};
                    players.forEach(player => {
                        player.score = 0;
                        genericGridScores[player.id] = {};
                        GENERIC_TURNS.forEach(turn => {
                            genericGridScores[player.id][turn] = 0;
                        });
                    });
                    savePlayers();
                    renderGenericGridTable();
                } else {
                    // For other modes, just reset player scores to 0
                    players.forEach(player => {
                        player.score = 0;
                    });
                    savePlayers();
                    
                }
                return;
            }
            
            // In general mode - DON'T clear players if they exist
            // Just reset their scores and game state
            if (players.length === 0) {
                // No players yet - clear everything
                crownsScores = {};
                currentCrownsRound = {};
                golfScores = {};
                currentGolfHole = {};
                savePlayers();
                saveCrownsScores();
                localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            } else {
                // Players exist - just reset their scores
                players.forEach(player => {
                    player.score = 0;
                });
                savePlayers();
            }
            
            
            renderCrownsTable();
            if (document.getElementById('golfTable')) {
                renderGolfTable();
            }
            
            // Mark as voice-guided setup (not full game start yet)
            isVoiceGuidedSetup = true;
            updateGameStateButton();
            
            // Trigger the game type question (which will enable mic after speaking)
            console.log('About to call askForGameType with forceAsk=true, recognition exists:', !!recognition);
            askForGameType(true); // Force ask even if asked before or muted
        }
        // Helper function to cancel all voice operations when manual input is used
        function cancelAllVoiceOperations() {
            // Cancel speech
            if (window.speechSynthesis && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            
            // Reset voice flags
            isAddingMode = false;
            isAskingGameType = false;
            
            // If we were in voice-guided setup and it's being cancelled, 
            // transition to normal state based on whether we have players
            if (isVoiceGuidedSetup) {
                isVoiceGuidedSetup = false;
                if (players.length > 0 && currentGameType !== 'general') {
                    gameInProgress = true; // If players exist and game type selected, start game
                } else {
                    gameInProgress = false; // Otherwise return to start state
                }
                updateGameStateButton();
            }
            
            scrabbleIsCollectingTiles = false;
            scrabbleProcessingResponse = false;
            scrabbleSpeaking = false;
            
            // Hide voice feedback
            hideVoiceFeedback();
            
            console.log(' Voice operations cancelled by manual input');
        }
        
        function toggleGameState() {
            try {
                console.log('toggleGameState called, gameInProgress:', gameInProgress, 'isVoiceGuidedSetup:', isVoiceGuidedSetup, 'currentGameType:', currentGameType);
                
                // Check if we're in voice-guided setup mode and button says "Stop Voice Input"
                if (isVoiceGuidedSetup) {
                    console.log('Stopping voice input during voice-guided setup');
                    stopVoiceInput();
                    return;
                }
                
                if (!gameInProgress) {
                    // Starting new game
                    console.log('Starting new game...');
                    
                    // MAIN PAGE BEHAVIOR: If we're in general mode with no players - start voice asking for game type
                    if (currentGameType === 'general' && players.length === 0) {
                        console.log('Main page - starting voice welcome to ask for game type');
                        startNewGame(); // This will trigger askForGameType
                        return;
                    }
                    
                    // GAME PAGE BEHAVIOR: If we're in a specific game mode - reset scoring and start the game
                    if (currentGameType !== 'general') {
                        console.log('Game page - resetting scoring grid and starting game');
                        // Reset scores for this specific game type
                        resetScoresForCurrentGame();
                        // Set game as started
                        gameInProgress = true;
                        updateGameStateButton();
                        return;
                    }
                    
                    // FALLBACK: Manual input mode with players but still in general mode
                    if (players.length > 0) {
                        console.log('Manual input mode - players exist, acting like Done Adding');
                        doneAdding();
                        return;
                    }
                    
                    // Check if user has manually entered player names in input fields
                    const container = document.getElementById('playerInputsContainer');
                    if (container) {
                        const allInputs = container.querySelectorAll('input[type="text"]');
                        let hasNames = false;
                        allInputs.forEach(input => {
                            if (input && input.value.trim() !== '') {
                                hasNames = true;
                            }
                        });
                        
                        if (hasNames && currentGameType === 'general') {
                            console.log('Player names entered but no game type - acting like Done Adding');
                            doneAdding();
                            return;
                        }
                    }
                    
                    // Default: start new game with voice
                    startNewGame();
                } else {
                    // Ending current game - let the announcement play
                    console.log('Ending game...');
                    endGame();
                }
            } catch (err) {
                console.error('Error in toggleGameState:', err);
                customAlert('Error: ' + err.message, ' Error');
            }
        }
        
        function stopVoiceInput() {
            console.log('stopVoiceInput called - stopping all voice operations');
            
            // Stop all voice operations
            cancelAllVoiceOperations();
            
            // Mute speaker if not already muted
            if (!isSpeakerMuted) {
                toggleSpeaker(); // This will mute the speaker
            }
            
            // Stop speech recognition if running
            if (recognition && isListening) {
                try {
                    intentionallyStopped = true;
                    recognition.stop();
                    isListening = false;
                    updateVoiceButtonState();
                } catch (e) {
                    console.error('Error stopping recognition:', e);
                }
            }
            
            // Visually disable voice controls
            const voiceBtn = document.getElementById('voiceBtn');
            const headerVoiceBtn = document.getElementById('headerVoiceBtn');
            
            if (voiceBtn) {
                voiceBtn.classList.remove('listening');
                voiceBtn.classList.add('disabled');
                voiceBtn.style.opacity = '0.5';
                voiceBtn.setAttribute('aria-label', 'Voice input disabled');
            }
            
            if (headerVoiceBtn) {
                headerVoiceBtn.classList.remove('listening');
                headerVoiceBtn.classList.add('disabled');
                headerVoiceBtn.style.opacity = '0.5';
            }
            
            // Exit voice-guided setup mode
            isVoiceGuidedSetup = false;
            
            // Reset to main page state
            gameInProgress = false;
            
            // Update button back to "Start Voice Recognition"
            updateGameStateButton();
            
            // Hide any voice feedback
            hideVoiceFeedback();
            
            console.log('Voice input stopped - microphone and speaker muted, returned to manual mode');
        }
        
        function resetScoresForCurrentGame() {
            console.log('Resetting scores for game type:', currentGameType);
            
            // Reset standard scores
            players.forEach(p => p.score = 0);
            
            // Reset game-specific scores
            if (currentGameType === '5crowns') {
                players.forEach(player => {
                    CROWNS_ROUNDS.forEach(round => {
                        if (crownsScores[player.id]) {
                            crownsScores[player.id][round] = 0;
                        }
                    });
                    currentCrownsRound[player.id] = 0;
                });
                saveCrownsScores();
                renderCrownsTable();
            } else if (currentGameType === 'golf') {
                players.forEach(player => {
                    GOLF_HOLES.forEach(hole => {
                        if (golfScores[player.id]) {
                            golfScores[player.id][hole] = 0;
                        }
                    });
                    currentGolfHole[player.id] = 0;
                });
                saveGolfData();
                renderGolfTable();
            } else if (currentGameType === 'scrabble') {
                players.forEach(player => {
                    SCRABBLE_TURNS.forEach(turn => {
                        if (scrabbleScores[player.id]) {
                            scrabbleScores[player.id][turn] = 0;
                        }
                    });
                });
                saveScrabbleData();
                renderScrabbleTable();
            } else if (currentGameType === 'yahtzee') {
                players.forEach(player => {
                    YAHTZEE_CATEGORIES.forEach(cat => {
                        if (yahtzeeScores[player.id]) {
                            yahtzeeScores[player.id][cat] = null;
                        }
                    });
                });
                saveYahtzeeData();
                renderYahtzeeTable();
            } else if (currentGameType === 'phase10') {
                players.forEach(player => {
                    for (let phase = 1; phase <= 10; phase++) {
                        if (phase10Scores[player.id]) {
                            phase10Scores[player.id][`phase${phase}`] = 0;
                        }
                    }
                });
                savePhase10Data();
                renderPhase10Table();
            } else if (currentGameType === 'farkle' || currentGameType === 'general') {
                players.forEach(player => {
                    for (let turn = 1; turn <= 20; turn++) {
                        if (genericGridScores[player.id]) {
                            genericGridScores[player.id][`turn${turn}`] = 0;
                        }
                    }
                });
                saveGenericGridData();
                renderGenericGridTable();
            } else if (currentGameType === 'darts') {
                // Darts doesn't have persistent scores to reset
                console.log('Darts game reset - no persistent scores to clear');
            }
            
            // Save players
            savePlayers();
            
            console.log('Game scores reset for:', currentGameType);
        }
        function updateGameStateButton() {
            const btn = document.getElementById('gameStateBtn');
            if (!btn) {
                console.error('gameStateBtn not found!');
                return;
            }
            
            console.log('Updating button, gameInProgress:', gameInProgress, 'isVoiceGuidedSetup:', isVoiceGuidedSetup);
            
            if (isVoiceGuidedSetup) {
                // During voice-guided setup, show "Stop Voice Input"
                btn.textContent = 'Stop Voice Input';
                btn.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a24)'; // Red gradient for stop
                btn.style.color = 'white';
                btn.style.boxShadow = '0 4px 15px rgba(238, 90, 36, 0.4)';
                btn.classList.remove('pulse'); // Remove pulsing for stop state
                btn.style.display = 'block';
                console.log('Button set to: Stop Voice Input (red) - Voice guided setup');
            } else if (gameInProgress) {
                // Hide the button when game is in progress - use individual game End Game buttons instead
                btn.style.display = 'none';
                console.log('Button hidden - game in progress, use game-specific buttons');
            } else {
                btn.textContent = 'Start Voice Recognition';
                btn.style.background = 'linear-gradient(135deg, var(--neon-green), #2ed600)';
                btn.style.color = 'black';
                btn.style.boxShadow = '0 4px 15px rgba(57, 255, 20, 0.4)';
                btn.style.display = 'block';
                // Don't re-add pulse class when game ends - only pulse on initial load
                console.log('Button set to: Start Voice Recognition (green)');
            }
        }
        async function endGame() {
            if (players.length === 0) {
                await customAlert('No players to record scores for!', ' No players');
                return;
            }
            
            // Check if any scores have been entered (prevent ending a game that hasn't started)
            let hasAnyScores = false;
            
            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                hasAnyScores = players.some(player => 
                    CROWNS_ROUNDS.some(round => (crownsScores[player.id]?.[round] || 0) !== 0)
                );
            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                hasAnyScores = players.some(player => 
                    GOLF_HOLES.some(hole => (golfScores[player.id]?.[hole] || 0) !== 0)
                );
            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                hasAnyScores = players.some(player => 
                    SCRABBLE_TURNS.some(turn => (scrabbleScores[player.id]?.[turn] || 0) !== 0)
                );
            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                hasAnyScores = players.some(player => 
                    Object.values(yahtzeeScores[player.id] || {}).some(score => score !== 0)
                );
            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                hasAnyScores = players.some(player => 
                    Object.values(phase10Scores[player.id] || {}).some(score => score !== 0)
                );
            } else if (currentGameType === 'darts') {
                // For darts, check if any legs have been won
                hasAnyScores = players.some(player => (dartsScores[player.id]?.legs || 0) > 0);
            } else {
                // For generic/standard games, check if anyone has a non-zero score
                hasAnyScores = players.some(player => player.score !== 0);
            }
            
            if (!hasAnyScores) {
                await customAlert('No scores have been entered yet. Play at least one round before ending the game!', ' No scores');
                return;
            }
            
            // Calculate final scores
            let playerScores = players.map(player => {
                let finalScore;
                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                    // Sum up all rounds for 5 Crowns
                    finalScore = CROWNS_ROUNDS.reduce((sum, round) => 
                        sum + (crownsScores[player.id][round] || 0), 0);
                } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                    // Calculate golf score based on mode
                    if (golfMode === 'advanced') {
                        // In advanced mode: Par + relative score for each hole
                        finalScore = 0;
                        GOLF_HOLES.forEach(hole => {
                            const par = golfCoursePar[hole] || 0;
                            const relativeScore = golfScores[player.id]?.[hole] || 0;
                            finalScore += par + relativeScore;
                        });
                    } else {
                        // In simple mode: Just sum the scores
                        finalScore = GOLF_HOLES.reduce((sum, hole) => 
                            sum + (golfScores[player.id]?.[hole] || 0), 0);
                    }
                } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    // Calculate Scrabble total: turns - unplayed + opponents
                    let total = 0;
                    SCRABBLE_TURNS.forEach(turn => {
                        total += scrabbleScores[player.id]?.[turn] || 0;
                    });
                    total -= scrabbleScores[player.id]?.['unplayed'] || 0;
                    total += scrabbleScores[player.id]?.['opponents'] || 0;
                    finalScore = total;
                } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                    // Calculate Yahtzee grand total: upper + lower sections + bonuses
                    const upperScore = (yahtzeeScores[player.id]?.ones || 0) + 
                                     (yahtzeeScores[player.id]?.twos || 0) + 
                                     (yahtzeeScores[player.id]?.threes || 0) + 
                                     (yahtzeeScores[player.id]?.fours || 0) + 
                                     (yahtzeeScores[player.id]?.fives || 0) + 
                                     (yahtzeeScores[player.id]?.sixes || 0) +
                                     (yahtzeeScores[player.id]?.upperBonus || 0);
                    const lowerScore = (yahtzeeScores[player.id]?.threeKind || 0) + 
                                     (yahtzeeScores[player.id]?.fourKind || 0) + 
                                     (yahtzeeScores[player.id]?.fullHouse || 0) + 
                                     (yahtzeeScores[player.id]?.smStraight || 0) + 
                                     (yahtzeeScores[player.id]?.lgStraight || 0) + 
                                     (yahtzeeScores[player.id]?.yahtzee || 0) + 
                                     (yahtzeeScores[player.id]?.chance || 0) + 
                                     (yahtzeeScores[player.id]?.yahtzeeBonus || 0);
                    finalScore = upperScore + lowerScore;
                } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                    // Calculate Phase 10 total: sum all phase scores
                    finalScore = 0;
                    if (phase10Scores[player.id]) {
                        Object.values(phase10Scores[player.id]).forEach(phaseScore => {
                            finalScore += phaseScore || 0;
                        });
                    }
                } else if (currentGameType === 'darts') {
                    // For darts, use LEGS WON (higher is better) instead of current score
                    // This prevents reading the reset score after a leg completes
                    finalScore = dartsScores[player.id]?.legs || 0;
                } else {
                    // For all other modes including generic, use the player's current score
                    finalScore = player.score;
                }
                return { player, finalScore };
            });
            console.log('Final scores:', playerScores);
            
            // Sort by score from best to worst based on game type
            const isLowerScoreWins = ['5crowns', 'golf', 'phase10'].includes(currentGameType);
            playerScores.sort((a, b) => {
                return isLowerScoreWins ? a.finalScore - b.finalScore : b.finalScore - a.finalScore;
            });
            
            const gameNames = {
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee',
                'general': 'General'
            };
            const gameName = gameNames[currentGameType] || 'General';
            const currentDate = new Date().toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: 'numeric' 
            });
            // Determine winner(s) and loser(s) based on game type
            let winners = [];
            let losers = [];
            
            // Since playerScores is now sorted best-to-worst, winners are always at the beginning
            const bestScore = playerScores[0].finalScore;
            const worstScore = playerScores[playerScores.length - 1].finalScore;
            
            // Find all players with best score (winners - tied)
            winners = playerScores.filter(p => p.finalScore === bestScore);
            
            // Find all players with worst score (losers - tied) 
            losers = playerScores.filter(p => p.finalScore === worstScore);
            console.log('Winners:', winners.map(w => ({name: w.player.name, score: w.finalScore})));
            console.log('Losers:', losers.map(l => ({name: l.player.name, score: l.finalScore})));
            
            // Determine if lower score is better for this game type
            const lowerIsBetter = ['golf', '5crowns', 'phase10'].includes(currentGameType);
            
            // Update walls with all players' scores
            playerScores.forEach(ps => {
                updateWalls(gameName, ps.player.name, ps.finalScore, lowerIsBetter);
            });
            
            // Win tracking now handled by universal completion system based on user choice
            // (No automatic tracking here to prevent double-tracking)
            
            // Create announcement text with proper singular/plural
            const getScoreUnit = (score) => {
                if (currentGameType === 'darts') {
                    return score === 1 ? 'leg' : 'legs';
                } else {
                    return score === 1 ? 'point' : 'points';
                }
            };
            
            let winnerText = winners.length > 1 
                ? `${winners.map(w => w.player.name).join(' and ')} tied with ${winners[0].finalScore} ${getScoreUnit(winners[0].finalScore)}!`
                : `${winners[0].player.name} is the Supreme Champion with ${winners[0].finalScore} ${getScoreUnit(winners[0].finalScore)}!`;
            
            // Create scores list for all players
            let scoresListText = playerScores.map(ps => 
                `${ps.player.name}: ${ps.finalScore} ${getScoreUnit(ps.finalScore)}`
            ).join('\n');
            
            // Speak the complete announcement: winner first, then all other players
            let voiceAnnouncement = `Game over! ${winnerText}`;
            
            // Sort playerScores for voice announcement - ALWAYS best to worst
            // playerScores is already sorted with winners first (best scores)
            const sortedForVoice = [...playerScores]; // Keep best-to-worst order
            
            // Add other players' scores (excluding the winner) from best to worst
            const otherPlayers = sortedForVoice.filter(ps => {
                // Filter out winner(s)
                return !winners.some(w => w.player.id === ps.player.id);
            });
            
            if (otherPlayers.length > 0) {
                // Build list of other players' scores from best to worst
                const scoreUnit = currentGameType === 'darts' ? 'legs' : 'points';
                const otherScores = otherPlayers.map(ps => 
                    `${ps.player.name}: ${ps.finalScore} ${ps.finalScore === 1 ? scoreUnit.slice(0, -1) : scoreUnit}`
                ).join(', ');
                voiceAnnouncement += `. Other scores from best to worst: ${otherScores}`;
            }
            
            speak(voiceAnnouncement);
            
            // Use universal game completion system for all non-Golf games
            if (currentGameType === 'scrabble') {
                // Format scores for Scrabble (needs .total instead of .finalScore)
                const formattedScores = playerScores.map(ps => ({
                    name: ps.player.name,
                    total: ps.finalScore,
                    player: ps.player
                }));
                
                // For Scrabble, winner has highest score (now at index 0 due to best-to-worst sorting)
                const winner = playerScores[0];
                const winnerData = {
                    name: winner.player.name,
                    player: winner.player,
                    total: winner.finalScore
                };
                
                await handleUniversalGameCompletion(currentGameType, winnerData, formattedScores);
            } else if (currentGameType === 'golf') {
                // For Golf games, combine winner announcement with save option
                // Format scores as HTML list
                const scoresHTML = playerScores.map(ps => 
                    `${ps.player.name}: ${ps.finalScore} points`
                ).join('<br>');
                
                const message = `<strong>${winnerText}</strong><br><br>${scoresHTML}`;
                const result = await showGolfScorecardSaveModal(message);
                
                if (result.action === 'save') {
                    // Track wins if checkbox checked (only for golf since other games track automatically)
                    if (result.saveWinLoss) {
                        trackGameResults(currentGameType, playerScores, winners);
                    }
                    
                    // Save full scorecard if checkbox checked
                    if (result.saveScorecard) {
                        saveGolfScorecard(playerScores, currentDate, result.notes);
                    } else if (result.notes && result.notes.length > 0) {
                        // If only notes (no scorecard), still show confirmation
                        await customAlert('Notes saved!', ' Saved');
                    }
                }
            } else {
                // Use universal game completion system for all non-Golf games
                const formattedScores = playerScores.map(ps => ({
                    name: ps.player.name,
                    total: ps.finalScore,
                    player: ps.player
                }));
                
                // Get winner data
                const winnerData = winners.length > 0 ? {
                    name: winners[0].player.name,
                    player: winners[0].player,
                    total: winners[0].finalScore
                } : null;
                
                await handleUniversalGameCompletion(currentGameType, winnerData, formattedScores);
            }
            
            // Reset game state
            gameInProgress = false;
            updateGameStateButton();
            
            // For darts, reset for next game but keep players
            if (currentGameType === 'darts') {
                gameStarted = false;
                
                // Reset the keypad flag so it can be rendered again
                dartsKeypadRendered = false;
                
                // Keep players in the array so they can be used for next game
                // Just reset their darts scores
                dartsScores = {};
            }
        }
        async function saveGolfScorecard(playerScores, dateStr, notes = '') {
            // Create scorecard data
            const scorecard = {
                date: dateStr,
                course: currentGolfCourse || 'Unknown Course',
                mode: golfMode,
                players: players.map(p => p.name),
                scores: {},
                par: golfMode === 'advanced' ? {...golfCoursePar} : null,
                hcp: golfMode === 'advanced' ? {...golfCourseHCP} : null,
                notes: notes, // Save notes with scorecard
                finalScores: playerScores.map(ps => ({
                    name: ps.player.name,
                    total: ps.finalScore
                }))
            };
            
            // Copy all player scores
            players.forEach(player => {
                scorecard.scores[player.name] = {...golfScores[player.id]};
            });
            
            // Load existing scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                }
            }
            
            // Add new scorecard
            savedScorecards.push(scorecard);
            
            // Keep only last 50 scorecards
            if (savedScorecards.length > 50) {
                savedScorecards = savedScorecards.slice(-50);
            }
            
            // Save
            localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(savedScorecards));
            
            await customAlert(`Scorecard saved successfully to the Options Menu!\n\nCourse: ${scorecard.course}\nDate: ${dateStr}\nWinner: ${scorecard.finalScores[0].name} (${scorecard.finalScores[0].total})`, ' Scorecard saved');
            console.log('Saved scorecard:', scorecard);
            
            // Refresh the hamburger menu dropdown
            populateHamburgerScorecardDropdown();
        }
        
        let currentScorecardIndex = null; // Track which scorecard is being viewed
        
        function populateHamburgerScorecardDropdown() {
            const dropdownList = document.getElementById('scorecardDropdownList');
            const selectedDisplay = document.getElementById('selectedScorecard');
            const dropdown = document.getElementById('scorecardDropdown');
            
            if (!dropdownList || !selectedDisplay) return;
            
            // Ensure dropdown is closed
            if (dropdown) dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            
            // Load saved scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                }
            }
            
            // Populate dropdown list
            dropdownList.innerHTML = '';
            if (savedScorecards.length === 0) {
                dropdownList.innerHTML = '<div class="dropdown-list-item-theme" style="color: var(--text-dim); cursor: default;">No saved scorecards</div>';
            } else {
                // Sort by date (newest first)
                savedScorecards.reverse();
                savedScorecards.forEach((sc, index) => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-list-item-theme';
                    item.textContent = `${sc.date} - ${sc.course} - ${sc.finalScores[0].name}`;
                    item.onclick = () => selectScorecard(index, sc);
                    dropdownList.appendChild(item);
                });
            }
            
            // Reset selection
            selectedDisplay.textContent = 'Select a Scorecard';
        }
        
        function toggleScorecardDropdown() {
            const dropdown = document.getElementById('scorecardDropdown');
            const dropdownList = document.getElementById('scorecardDropdownList');
            
            // Close other dropdowns
            document.querySelectorAll('.custom-dropdown').forEach(dd => {
                if (dd.id !== 'scorecardDropdown') {
                    dd.classList.remove('open');
                }
            });
            document.querySelectorAll('.custom-dropdown-list').forEach(ddl => {
                if (ddl.id !== 'scorecardDropdownList') {
                    ddl.classList.remove('open');
                }
            });
            
            // Toggle this dropdown
            dropdown.classList.toggle('open');
            dropdownList.classList.toggle('open');
        }
        
        function selectScorecard(index, scorecard) {
            const dropdown = document.getElementById('scorecardDropdown');
            const dropdownList = document.getElementById('scorecardDropdownList');
            const selectedDisplay = document.getElementById('selectedScorecard');
            
            // Close dropdown
            dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            
            // Update display
            selectedDisplay.textContent = `${scorecard.date} - ${scorecard.course}`;
            
            // Set current index
            currentScorecardIndex = index;
            
            // Close hamburger menu
            toggleMenu();
            
            // Display the scorecard in modal
            displayScorecard(index);
            
            // Show modal
            const modal = document.getElementById('savedScorecardsModal');
            modal.classList.add('show');
            
            // Reset dropdown display after a moment
            setTimeout(() => {
                selectedDisplay.textContent = 'Select a Scorecard';
            }, 300);
        }
        
        function displayScorecard(index) {
            const display = document.getElementById('scorecardDisplay');
            
            // Load scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                    return;
                }
            }
            
            savedScorecards.reverse(); // Match the order in dropdown
            const scorecard = savedScorecards[index];
            
            if (!scorecard) {
                display.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-dim);">Scorecard not found.</div>';
                return;
            }
            
            // Display scorecard details with tabs
            let html = `
                <div style="background: var(--card-bg); padding: 20px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                        <div style="font-size: 1.2rem; font-weight: 800; color: var(--text-primary);">
                            ${scorecard.course}
                        </div>
                        <div style="color: var(--text-dim); font-weight: 600;">
                            ${scorecard.date}
                        </div>
                    </div>
                    
                    <!-- Tab Navigation -->
                    <div class="tab-navigation" style="margin-bottom: 20px;">
                        <button class="tab-btn active" onclick="switchScorecardTab('final', ${index})">Final Scores</button>
                        <button class="tab-btn" onclick="switchScorecardTab('full', ${index})">Full Scorecard</button>
                    </div>
                    
                    <!-- Final Scores Tab Content -->
                    <div id="scorecardTabFinal" class="scorecard-tab-content" style="display: block;">
                        <table class="crowns-table" style="width: 100%; margin-bottom: 20px;">
                            <thead>
                                <tr>
                                    <th>Place</th>
                                    <th>Player</th>
                                    <th>Score</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            // Sort finalScores from best to worst based on game type
            const isLowerScoreWins = ['5crowns', 'golf', 'phase10'].includes(gameType);
            const sortedFinalScores = [...scorecard.finalScores].sort((a, b) => {
                return isLowerScoreWins ? a.total - b.total : b.total - a.total;
            });
            
            sortedFinalScores.forEach((ps, idx) => {
                html += `
                    <tr>
                        <td style="text-align: center;">${idx + 1}</td>
                        <td>${escapeHtml(ps.name)}</td>
                        <td style="text-align: center;">${ps.total}</td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
            `;
            
            // Add notes section in Final Scores tab only
            const notesValue = scorecard.notes || '';
            if (notesValue) {
                html += `
                    <div style="margin-top: 15px; padding: 15px; background: rgba(0, 245, 255, 0.1); border-left: 3px solid var(--neon-blue); border-radius: 6px;">
                        <div style="font-weight: 700; margin-bottom: 8px; color: var(--text-primary);">Notes:</div>
                        <div style="color: var(--text-primary); white-space: pre-wrap;">${escapeHtml(notesValue)}</div>
                    </div>
                `;
            }
            
            html += `
                    </div>
                    
                    <!-- Full Scorecard Tab Content -->
                    <div id="scorecardTabFull" class="scorecard-tab-content" style="display: none;">
            `;
            
            // Build the full scorecard grid
            html += renderFullScorecardGrid(scorecard);
            
            html += `
                    </div>
            `;
            
            html += `
                </div>
            `;
            
            display.innerHTML = html;
        }
        
        function switchScorecardTab(tabName, index) {
            // Update tab buttons
            const tabs = document.querySelectorAll('#scorecardDisplay .tab-btn');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Add active class to clicked button
            if (window.event && window.event.target) {
                window.event.target.classList.add('active');
            }
            
            // Show/hide tab content
            const finalTab = document.getElementById('scorecardTabFinal');
            const fullTab = document.getElementById('scorecardTabFull');
            
            if (tabName === 'final') {
                if (finalTab) finalTab.style.display = 'block';
                if (fullTab) fullTab.style.display = 'none';
            } else if (tabName === 'full') {
                if (finalTab) finalTab.style.display = 'none';
                if (fullTab) fullTab.style.display = 'block';
            }
        }
        
        function renderFullScorecardGrid(scorecard) {
            let html = '<div class="crowns-container">';
            
            // Create golf scorecard table
            html += '<table class="crowns-table golf-table" style="width: 100%;">';
            
            // Header row with player names
            html += '<thead><tr><th class="crowns-hole-label golf-info-column">Tee</th>';
            
            // Add PAR and HCP columns if in advanced mode
            if (scorecard.mode === 'advanced' && scorecard.par) {
                html += '<th class="crowns-hole-label golf-info-column">Par</th>';
                html += '<th class="crowns-hole-label golf-info-column">HCP</th>';
            }
            
            // Player columns
            scorecard.players.forEach(playerName => {
                html += `<th class="crowns-player-header">${escapeHtml(playerName)}</th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // Hole rows
            const holes = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'OUT', '10', '11', '12', '13', '14', '15', '16', '17', '18', 'IN', 'TOT'];
            
            holes.forEach(hole => {
                // Determine if this is a total row
                const isTotalRow = hole === 'OUT' || hole === 'IN' || hole === 'TOT';
                const rowClass = isTotalRow ? 'total-row' : '';
                // Add special class for OUT row to get border
                const outRowClass = hole === 'OUT' ? ' golf-out-row' : '';
                
                html += `<tr class="${rowClass}${outRowClass}">`;
                html += `<td class="crowns-hole-label golf-info-column">${hole}</td>`;
                
                // PAR and HCP columns (if advanced mode)
                if (scorecard.mode === 'advanced' && scorecard.par) {
                    if (isTotalRow) {
                        html += '<td class="crowns-score golf-info-column"></td>';
                        html += '<td class="crowns-score golf-info-column"></td>';
                    } else {
                        const par = scorecard.par[hole] || '';
                        const hcp = scorecard.hcp[hole] || '';
                        html += `<td class="crowns-score golf-info-column">${par}</td>`;
                        html += `<td class="crowns-score golf-info-column">${hcp}</td>`;
                    }
                }
                
                // Player score columns
                scorecard.players.forEach(playerName => {
                    const playerScores = scorecard.scores[playerName] || {};
                    let score = playerScores[hole] || '';
                    
                    // Calculate OUT, IN, TOT if not present
                    if (hole === 'OUT' && !score) {
                        score = ['1','2','3','4','5','6','7','8','9'].reduce((sum, h) => sum + (parseInt(playerScores[h]) || 0), 0);
                        if (score === 0) score = '';
                    } else if (hole === 'IN' && !score) {
                        score = ['10','11','12','13','14','15','16','17','18'].reduce((sum, h) => sum + (parseInt(playerScores[h]) || 0), 0);
                        if (score === 0) score = '';
                    } else if (hole === 'TOT' && !score) {
                        score = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18'].reduce((sum, h) => sum + (parseInt(playerScores[h]) || 0), 0);
                        if (score === 0) score = '';
                    }
                    
                    // Add proper class for score cells
                    const cellClass = isTotalRow ? '' : 'crowns-score';
                    html += `<td class="${cellClass}">${score}</td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '</div>';
            
            return html;
        }
        
        
        // ===== WINS TRACKER FUNCTIONS =====
        
        function trackGameResults(gameType, playerScores, winners) {
            console.log('=== trackGameResults DEBUG ===');
            console.log('gameType:', gameType);
            console.log('playerScores:', JSON.stringify(playerScores));
            console.log('winners:', JSON.stringify(winners));
            
            // Load existing wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                }
            }
            
            // Initialize game type if not exists
            if (!winsData[gameType]) {
                winsData[gameType] = {};
            }
            
            console.log('Processing', playerScores.length, 'players');
            
            // Track each player
            playerScores.forEach(ps => {
                const playerName = ps.player.name;
                console.log('Processing player:', playerName, 'Score:', ps.finalScore);
                
                // Find existing player with same name (case-insensitive)
                let existingPlayerName = null;
                for (const name in winsData[gameType]) {
                    if (name.toLowerCase() === playerName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
                
                // Use existing name if found, otherwise use new name
                const normalizedName = existingPlayerName || playerName;
                console.log('Using normalized name:', normalizedName);
                
                // Initialize player if not exists
                if (!winsData[gameType][normalizedName]) {
                    winsData[gameType][normalizedName] = {
                        played: 0,
                        wins: 0
                    };
                    console.log('Initialized new player:', normalizedName);
                }
                
                // Increment games played
                winsData[gameType][normalizedName].played++;
                console.log(normalizedName, 'played incremented to:', winsData[gameType][normalizedName].played);
                
                // Check if this player won
                const isWinner = winners.some(w => w.player.id === ps.player.id);
                console.log(normalizedName, 'is winner?', isWinner);
                if (isWinner) {
                    winsData[gameType][normalizedName].wins++;
                    console.log(normalizedName, 'wins incremented to:', winsData[gameType][normalizedName].wins);
                }
            });
            
            console.log('Final winsData before save:', JSON.stringify(winsData));
            
            // Save updated data
            localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
        }
        
        function toggleWinsTrackerDropdown() {
            const dropdown = document.getElementById('winsTrackerDropdown');
            const dropdownList = document.getElementById('winsTrackerDropdownList');
            const sideMenu = document.getElementById('sideMenu');
            
            // Close other dropdowns
            document.querySelectorAll('.custom-dropdown').forEach(dd => {
                if (dd.id !== 'winsTrackerDropdown') {
                    dd.classList.remove('open');
                }
            });
            document.querySelectorAll('.custom-dropdown-list').forEach(ddl => {
                if (ddl.id !== 'winsTrackerDropdownList') {
                    ddl.classList.remove('open');
                }
            });
            
            // Toggle this dropdown
            dropdown.classList.toggle('open');
            dropdownList.classList.toggle('open');

            // Allow dropdown to escape iOS overflow clipping
            if (dropdownList.classList.contains('open')) {
                sideMenu.style.overflowY = 'visible';
            } else {
                sideMenu.style.overflowY = 'auto';
            }
        }
        
        function selectWinsTrackerGame(gameType) {
            const dropdown = document.getElementById('winsTrackerDropdown');
            const dropdownList = document.getElementById('winsTrackerDropdownList');
            const selectedDisplay = document.getElementById('selectedWinsTracker');
            
            // Close dropdown and restore side menu scroll
            dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            const sideMenu = document.getElementById('sideMenu');
            if (sideMenu) sideMenu.style.overflowY = 'auto';
            
            // Game names mapping
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            // Update display
            selectedDisplay.textContent = gameNames[gameType];
            
            // Close hamburger menu
            toggleMenu();
            
            // Display wins tracker for this game
            displayWinsTracker(gameType);
            
            // Reset dropdown display after a moment
            setTimeout(() => {
                selectedDisplay.textContent = 'Select a Game';
            }, 300);
        }
        
        function showWinsTrackerMenu() {
            const modal = document.getElementById('winsTrackerModal');
            const title = document.getElementById('winsTrackerTitle');
            const display = document.getElementById('winsTrackerDisplay');
            
            title.innerHTML = 'Game Statistics';
            
            const gameTypes = [
                { id: 'golf', name: 'Golf' },
                { id: '5crowns', name: '5 Crowns' },
                { id: 'scrabble', name: 'Scrabble' },
                { id: 'darts', name: 'Darts' },
                { id: 'yahtzee', name: 'Yahtzee' },
                { id: 'phase10', name: 'Phase 10' },
                { id: 'farkle', name: 'Farkle' },
                { id: 'general', name: 'General' }
            ];
            
            let html = '<div style="padding: 20px; text-align: center;">';
            html += '<div style="margin-bottom: 20px; color: var(--text-dim);">Select a game to view statistics and scorecards:</div>';
            html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 300px; margin: 0 auto;">';
            
            gameTypes.forEach(game => {
                html += `
                    <button 
                        class="final-scores-ok-btn" 
                        onclick="displayWinsTracker('${game.id}')"
                        style="margin: 0; padding: 15px 10px; font-size: 0.95rem;"
                    >
                        ${game.name}
                    </button>
                `;
            });
            
            html += '</div></div>';
            
            display.innerHTML = html;
            modal.classList.add('show');
        }
        
        function displayWinsTracker(gameType) {
            console.log('=== displayWinsTracker called ===');
            console.log('gameType:', gameType);
            
            const modal = document.getElementById('winsTrackerModal');
            const title = document.getElementById('winsTrackerTitle');
            const display = document.getElementById('winsTrackerDisplay');
            
            // Game names mapping
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            title.innerHTML = `${gameNames[gameType]} Statistics`;
            
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                }
            }
            
            console.log('winsData:', winsData);
            
            const gameData = winsData[gameType] || {};
            const players = Object.keys(gameData);
            
            console.log('gameData:', gameData);
            console.log('players:', players);
            
            // Add tabs for all game types
            let html = '';
            console.log(`Creating ${gameType} tabs`);
            html += `
                <div class="tab-navigation" style="margin-bottom: 20px;">
                    <button class="tab-btn active" onclick="switchWinsTrackerTab('${gameType}', 'stats')">Statistics</button>
                    <button class="tab-btn" onclick="switchWinsTrackerTab('${gameType}', 'scorecards')">Scorecards</button>
                </div>
                <div id="winsTrackerStatsTab" class="wins-tracker-tab" style="display: block;">
            `;
            
            if (players.length === 0) {
                console.log('No players found, using empty state');
                html += '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No games recorded yet.</div>';
                html += '</div><div id="winsTrackerScorecardsTab" class="wins-tracker-tab" style="display: none;">';
                
                // Always load scorecards even if no win/loss stats
                const savedScorecards = loadGameScorecards(gameType);
                if (savedScorecards.length > 0) {
                    html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    savedScorecards.reverse().forEach((scorecard, idx) => {
                        const actualIndex = savedScorecards.length - 1 - idx;
                        const date = scorecard.date;
                        const dateStr = date; // Already formatted in our storage
                        
                        // Handle players - could be array of names or objects
                        let playerNames = '';
                        if (Array.isArray(scorecard.players)) {
                            playerNames = scorecard.players.join(', ');
                        } else if (scorecard.finalScores) {
                            playerNames = scorecard.finalScores.map(s => s.name).join(', ');
                        } else {
                            playerNames = 'Unknown';
                        }
                        
                        // Get game-specific display info
                        let gameInfo = '';
                        if (gameType === 'golf' && scorecard.course) {
                            gameInfo = scorecard.course;
                        } else if (gameType === 'darts' && scorecard.gameSettings) {
                            gameInfo = playerNames; // Show player names instead of game settings
                        } else if (gameType === '5crowns') {
                            gameInfo = playerNames; // Show player names instead of round count
                        } else if (gameType === 'scrabble') {
                            gameInfo = playerNames; // Show player names instead of turn count
                        } else if (gameType === 'yahtzee') {
                            gameInfo = playerNames; // Show player names instead of 'Full Game'
                        } else if (gameType === 'phase10') {
                            gameInfo = playerNames; // Show player names instead of phase count
                        } else {
                            gameInfo = playerNames; // Show player names instead of 'Complete Game'
                        }
                        
                        html += `
                            <div class="saved-scorecard-item" 
                                 style="display: flex; align-items: center; justify-content: space-between; gap: 10px;
                                        cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; 
                                        transition: all 0.2s ease;">
                                <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;" onclick="viewGameScorecardFromWins('${gameType}', ${actualIndex})">
                                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                                        <div style="font-weight: 700; color: black; flex: 1; text-align: left;">${escapeHtml(gameInfo)}</div>
                                        <div style="font-weight: 600; color: black; text-align: right;">${dateStr}</div>
                                    </div>
                                    ${gameType === 'golf' ? `<div style="color: black; font-size: 0.95rem; text-align: left;">${escapeHtml(playerNames)}</div>` : ''}
                                </div>
                                <button class="delete-btn" onclick="event.stopPropagation(); window.deleteGameScorecardFromWins('${gameType}', ${actualIndex})" 
                                        style="width: 36px; height: 36px; font-size: 1.2rem; flex-shrink: 0;"></button>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    html += '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No scorecards saved yet.</div>';
                }
                
                html += '</div>'; // Close scorecardsTab
                display.innerHTML = html;
            } else {
                console.log('Players found:', players.length, 'players');
                // Sort players by win percentage (descending)
                players.sort((a, b) => {
                    const aPercent = gameData[a].played > 0 ? (gameData[a].wins / gameData[a].played) * 100 : 0;
                    const bPercent = gameData[b].played > 0 ? (gameData[b].wins / gameData[b].played) * 100 : 0;
                    return bPercent - aPercent;
                });
                
                console.log('About to build stats table');
                html += `
                    <table class="crowns-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 100px;">Player</th>
                                <th style="width: 60px; padding: 4px 8px;">Played</th>
                                <th style="width: 50px; padding: 4px 8px;">Wins</th>
                                <th style="width: 45px; padding: 4px 2px;">%</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                players.forEach(playerName => {
                    const stats = gameData[playerName];
                    const percentage = stats.played > 0 ? ((stats.wins / stats.played) * 100).toFixed(1) : '0.0';
                    
                    html += `
                        <tr>
                            <td style="text-align: left;">
                                <input type="text" value="${escapeHtml(playerName)}" 
                                       class="wins-tracker-input" 
                                       onchange="updateWinsTrackerPlayerName('${gameType}', '${escapeHtml(playerName)}', this.value)"
                                       style="width: 100%; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                            </td>
                            <td style="padding: 4px 8px;">
                                <input type="number" value="${stats.played}" 
                                       class="wins-tracker-input" 
                                       inputmode="numeric"
                                       onchange="updateWinsTrackerStat('${gameType}', '${escapeHtml(playerName)}', 'played', this.value)"
                                       style="width: 44px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                            </td>
                            <td style="padding: 4px 8px;">
                                <input type="number" value="${stats.wins}" 
                                       class="wins-tracker-input" 
                                       inputmode="numeric"
                                       onchange="updateWinsTrackerStat('${gameType}', '${escapeHtml(playerName)}', 'wins', this.value)"
                                       style="width: 34px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                            </td>
                            <td style="font-weight: 700; color: var(--neon-blue); padding: 4px 2px; text-align: center;">${percentage}%</td>
                            <td style="text-align: center;">
                                <button class="delete-btn" onclick="deleteWinsTrackerEntry('${gameType}', '${escapeHtml(playerName)}')" style="width: 36px; height: 36px; font-size: 1.2rem;"></button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
                
                // Close stats tab and add scorecards tab for all game types
                console.log(`Adding ${gameType} scorecards tab for players exist case`);
                html += '</div><div id="winsTrackerScorecardsTab" class="wins-tracker-tab" style="display: none;">';
                
                // Load scorecards for this game type
                const savedScorecards = loadGameScorecards(gameType);
                console.log(`${gameType} saved scorecards:`, savedScorecards.length, 'scorecards');
                if (savedScorecards.length > 0) {
                    html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    savedScorecards.reverse().forEach((scorecard, idx) => {
                        const actualIndex = savedScorecards.length - 1 - idx;
                        const dateStr = scorecard.date; // Already formatted in our storage
                        
                        // Handle players - could be array of names or objects
                        let playerNames = '';
                        if (Array.isArray(scorecard.players)) {
                            playerNames = scorecard.players.join(', ');
                        } else if (scorecard.finalScores) {
                            playerNames = scorecard.finalScores.map(s => s.name).join(', ');
                        } else {
                            playerNames = 'Unknown';
                        }
                        
                        // Get game-specific display info
                        let gameInfo = '';
                        if (gameType === 'golf' && scorecard.course) {
                            gameInfo = scorecard.course;
                        } else if (gameType === 'darts' && scorecard.gameSettings) {
                            gameInfo = playerNames; // Show player names instead of game settings
                        } else if (gameType === '5crowns') {
                            gameInfo = playerNames; // Show player names instead of round count
                        } else if (gameType === 'scrabble') {
                            gameInfo = playerNames; // Show player names instead of turn count
                        } else if (gameType === 'yahtzee') {
                            gameInfo = playerNames; // Show player names instead of 'Full Game'
                        } else if (gameType === 'phase10') {
                            gameInfo = playerNames; // Show player names instead of phase count
                        } else {
                            gameInfo = playerNames; // Show player names instead of 'Complete Game'
                        }
                        
                        html += `
                            <div class="saved-scorecard-item" 
                                 style="display: flex; align-items: center; justify-content: space-between; gap: 10px;
                                        cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; 
                                        transition: all 0.2s ease;">
                                <div style="display: flex; flex-direction: column; gap: 5px; flex: 1;" onclick="viewGameScorecardFromWins('${gameType}', ${actualIndex})">
                                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                                        <div style="font-weight: 700; color: black; flex: 1; text-align: left;">${escapeHtml(gameInfo)}</div>
                                        <div style="font-weight: 600; color: black; text-align: right;">${dateStr}</div>
                                    </div>
                                    ${gameType === 'golf' ? `<div style="color: black; font-size: 0.95rem; text-align: left;">${escapeHtml(playerNames)}</div>` : ''}
                                </div>
                                <button class="delete-btn" onclick="event.stopPropagation(); window.deleteGameScorecardFromWins('${gameType}', ${actualIndex})" 
                                        style="width: 36px; height: 36px; font-size: 1.2rem; flex-shrink: 0;"></button>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    html += '<div style="padding: 20px; text-align: center; color: var(--text-dim);">No scorecards saved yet.</div>';
                }
                html += '</div>';
                
                console.log('Final HTML structure length:', html.length);
                console.log('Final HTML preview (first 500 chars):', html.substring(0, 500));
                console.log('Final HTML preview (last 500 chars):', html.substring(html.length - 500));
                console.log('Setting display.innerHTML for players exist case');
                display.innerHTML = html;
            }
            
            console.log('=== displayWinsTracker complete ===');
            // Show modal
            modal.classList.add('show');
        }
        
        function updateWinsTrackerPlayerName(gameType, oldName, newName) {
            newName = newName.trim();
            if (!newName || newName === oldName) return;
            
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    return;
                }
            }
            
            if (winsData[gameType] && winsData[gameType][oldName]) {
                // Check if there's already a player with the new name (case-insensitive)
                let existingPlayerName = null;
                for (const name in winsData[gameType]) {
                    if (name !== oldName && name.toLowerCase() === newName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
                
                if (existingPlayerName) {
                    // Merge the data into existing player
                    winsData[gameType][existingPlayerName].played += winsData[gameType][oldName].played;
                    winsData[gameType][existingPlayerName].wins += winsData[gameType][oldName].wins;
                    delete winsData[gameType][oldName];
                } else {
                    // Just rename the player
                    winsData[gameType][newName] = winsData[gameType][oldName];
                    delete winsData[gameType][oldName];
                }
                
                // Save
                localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
                
                // Refresh display
                displayWinsTracker(gameType);
            }
        }
        
        function updateWinsTrackerStat(gameType, playerName, stat, value) {
            value = parseInt(value) || 0;
            if (value < 0) value = 0;
            
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    return;
                }
            }
            
            // Find existing player with same name (case-insensitive)
            let existingPlayerName = null;
            if (winsData[gameType]) {
                for (const name in winsData[gameType]) {
                    if (name.toLowerCase() === playerName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
            }
            
            if (existingPlayerName) {
                // Update stat
                winsData[gameType][existingPlayerName][stat] = value;
                
                // Make sure wins doesn't exceed played
                if (stat === 'played' && winsData[gameType][existingPlayerName].wins > value) {
                    winsData[gameType][existingPlayerName].wins = value;
                }
                if (stat === 'wins' && value > winsData[gameType][existingPlayerName].played) {
                    winsData[gameType][existingPlayerName].played = value;
                }
                
                // Save
                localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
                
                // Refresh display
                displayWinsTracker(gameType);
            }
        }
        

        function switchWinsTrackerTab(gameType, tab) {
            const tabBtns = document.querySelectorAll('#winsTrackerDisplay .tab-btn');
            tabBtns.forEach(btn => {
                btn.classList.remove('active');
                // Add active class to the correct button
                if ((tab === 'stats' && btn.textContent.trim() === 'Statistics') ||
                    (tab === 'scorecards' && btn.textContent.trim() === 'Scorecards')) {
                    btn.classList.add('active');
                }
            });
            
            const statsTab = document.getElementById('winsTrackerStatsTab');
            const scorecardsTab = document.getElementById('winsTrackerScorecardsTab');
            
            if (tab === 'stats') {
                statsTab.style.display = 'block';
                scorecardsTab.style.display = 'none';
            } else {
                statsTab.style.display = 'none';
                scorecardsTab.style.display = 'block';
            }
            
            // Show/hide Delete All button - show for all game types' scorecards tabs
            const deleteAllBtn = document.getElementById('deleteAllScorecardsBtn');
            if (deleteAllBtn) {
                if (tab === 'scorecards') {
                    deleteAllBtn.style.display = 'inline-block';
                    // Update the onclick to handle the current game type
                    deleteAllBtn.setAttribute('onclick', `window.deleteAllGameScorecards('${gameType}')`);
                } else {
                    deleteAllBtn.style.display = 'none';
                }
            }
        }
        
        function viewGolfScorecardFromWins(index) {
            const savedScorecards = localStorage.getItem('scorekeeper_golf_scorecards');
            if (!savedScorecards) return;
            
            try {
                const scorecards = JSON.parse(savedScorecards);
                if (!scorecards || scorecards.length === 0) return;
                
                // Close wins tracker modal
                document.getElementById('winsTrackerModal').classList.remove('show');
                
                // Set current viewed scorecard
                currentScorecardIndex = index;
                
                // Display the scorecard using the existing display function
                displayScorecard(index);
                
                // Show the saved scorecards modal
                document.getElementById('savedScorecardsModal').classList.add('show');
            } catch (e) {
                console.error('Error viewing scorecard:', e);
                customAlert('Error loading scorecard: ' + e.message, ' Error');
            }
        }
        
        // deleteGolfScorecardFromWins function moved to global scope above
        
        // deleteAllGameScorecards function moved to global scope above
        
        // Keep the old Golf function name for backward compatibility
        async function deleteAllGolfScorecards() {
            await window.deleteAllGameScorecards('golf');
        }
        
        
        function closeWinsTrackerModal() {
            const modal = document.getElementById('winsTrackerModal');
            modal.classList.remove('show');
        }
        
        
        function updatePlayerWins(playerName, gameType, isWinner = true) {
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    winsData = {};
                }
            }
            
            // Initialize game type if needed
            if (!winsData[gameType]) {
                winsData[gameType] = {};
            }
            
            // Find existing player (case-insensitive)
            let existingPlayerName = null;
            for (const name in winsData[gameType]) {
                if (name.toLowerCase() === playerName.toLowerCase()) {
                    existingPlayerName = name;
                    break;
                }
            }
            
            if (existingPlayerName) {
                // Update existing player
                winsData[gameType][existingPlayerName].played++;
                if (isWinner) {
                    winsData[gameType][existingPlayerName].wins++;
                }
            } else {
                // Add new player
                winsData[gameType][playerName] = {
                    played: 1,
                    wins: isWinner ? 1 : 0
                };
            }
            
            // Save
            localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
            console.log('Updated wins for', playerName, 'in', gameType, '- Winner:', isWinner);
        }
        
        function deleteWinsTrackerEntry(gameType, playerName) {
            // Load wins data
            let winsData = {};
            const saved = localStorage.getItem('scorekeeper_wins_tracker');
            if (saved) {
                try {
                    winsData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading wins tracker:', e);
                    return;
                }
            }
            
            // Find existing player with same name (case-insensitive)
            let existingPlayerName = null;
            if (winsData[gameType]) {
                for (const name in winsData[gameType]) {
                    if (name.toLowerCase() === playerName.toLowerCase()) {
                        existingPlayerName = name;
                        break;
                    }
                }
            }
            
            // Delete the player entry
            if (existingPlayerName) {
                delete winsData[gameType][existingPlayerName];
                
                // Save back to localStorage
                localStorage.setItem('scorekeeper_wins_tracker', JSON.stringify(winsData));
                
                // Refresh display
                displayWinsTracker(gameType);
            }
        }
        
        // Auto-save notes with debounce to avoid saving on every keystroke
        let autoSaveNotesTimeout;
        function autoSaveScorecardNotes() {
            clearTimeout(autoSaveNotesTimeout);
            autoSaveNotesTimeout = setTimeout(() => {
                saveEditedNotes(true); // true = silent save (no alert)
            }, 1000); // Save 1 second after user stops typing
        }
        
        async function saveEditedNotes(silent = false) {
            if (currentScorecardIndex === null) return;
            
            const notesTextarea = document.getElementById('viewScorecardNotes');
            if (!notesTextarea) return;
            
            const newNotes = notesTextarea.value.trim();
            
            // Load scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                    return;
                }
            }
            
            // Update notes in the scorecard
            savedScorecards.reverse(); // Match the order in dropdown
            if (savedScorecards[currentScorecardIndex]) {
                savedScorecards[currentScorecardIndex].notes = newNotes;
            }
            savedScorecards.reverse(); // Reverse back to original order
            
            // Save updated list
            localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(savedScorecards));
            
            // Show confirmation only if not silent
            if (!silent) {
                await customAlert('Notes saved successfully!', ' Saved');
                // Refresh the display
                displayScorecard(currentScorecardIndex);
            }
        }
        
        function closeSavedScorecardsModal() {
            const modal = document.getElementById('savedScorecardsModal');
            modal.classList.remove('show');
            currentScorecardIndex = null;
        }
        
        async function deleteCurrentScorecard() {
            if (currentScorecardIndex === null) return;
            
            const confirmed = await customConfirm('Are you sure you want to delete this scorecard? This action cannot be undone.', ' Delete Scorecard');
            if (!confirmed) return;
            
            // Load scorecards
            let savedScorecards = [];
            const saved = localStorage.getItem('scorekeeper_golf_scorecards');
            if (saved) {
                try {
                    savedScorecards = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading scorecards:', e);
                    return;
                }
            }
            
            savedScorecards.reverse(); // Match the order in dropdown
            savedScorecards.splice(currentScorecardIndex, 1);
            savedScorecards.reverse(); // Reverse back to original order
            
            // Save updated list
            localStorage.setItem('scorekeeper_golf_scorecards', JSON.stringify(savedScorecards));
            
            // Refresh hamburger dropdown
            populateHamburgerScorecardDropdown();
            
            // Close modal
            closeSavedScorecardsModal();
            
            await customAlert('Scorecard deleted successfully.', ' Deleted');
        }
        
        function toggleVoiceHelp() {
            const content = document.getElementById('voiceHelpContent');
            const toggle = document.getElementById('voiceHelpToggle');
            const header = document.querySelector('.voice-help-header');
            
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                toggle.classList.remove('open');
                if (header) header.classList.remove('open');
            } else {
                content.classList.add('open');
                toggle.classList.add('open');
                if (header) header.classList.add('open');
            }
        }
        window.toggleMenu = function() {
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            const hamburger = document.getElementById('hamburgerBtn');
            
            if (!menu || !overlay || !hamburger) {
                console.error('toggleMenu: Missing required elements');
                return;
            }
            
            const isActive = menu.classList.contains('active');
            
            if (isActive) {
                menu.classList.remove('active');
                overlay.classList.remove('active');
                hamburger.classList.remove('active');
                // Restore overflow and close any open dropdowns
                menu.style.overflowY = 'auto';
                document.querySelectorAll('.custom-dropdown-list').forEach(ddl => ddl.classList.remove('open'));
                document.querySelectorAll('.custom-dropdown').forEach(dd => dd.classList.remove('open'));
            } else {
                menu.classList.add('active');
                overlay.classList.add('active');
                hamburger.classList.add('active');
            }
        };
        
        // Verify toggleMenu is accessible
        console.log(' toggleMenu function defined:', typeof window.toggleMenu);
        function toggleInputMode() {
            const toggle = document.getElementById('inputModeToggle');
            const voiceLabel = document.getElementById('voiceLabel');
            const manualLabel = document.getElementById('manualLabel');
            const voiceBtn = document.getElementById('voiceBtn');
            
            if (toggle.checked) {
                // Manual mode
                inputMode = 'manual';
                voiceLabel.classList.remove('active');
                manualLabel.classList.add('active');
                
                // Cancel any ongoing voice operations
                cancelAllVoiceOperations();
                
                // Mark voice button as inactive (but don't disable so click can show message)
                if (voiceBtn) {
                    voiceBtn.classList.add('manual-mode-inactive');
                    voiceBtn.title = 'Voice input is disabled in Manual mode. Switch to Voice mode in the menu ().';
                }
                
                // Save preference
                localStorage.setItem('scorekeeper_input_mode', 'manual');
                
                console.log(' Switched to Manual Input mode');
            } else {
                // Voice mode
                inputMode = 'voice';
                voiceLabel.classList.add('active');
                manualLabel.classList.remove('active');
                
                // Enable voice button
                if (voiceBtn) {
                    voiceBtn.classList.remove('manual-mode-inactive');
                    voiceBtn.title = 'Click to start voice input';
                }
                
                // Save preference
                localStorage.setItem('scorekeeper_input_mode', 'voice');
                
                console.log(' Switched to Voice Input mode');
            }
        }
        
        // Load input mode preference on page load
        function loadInputMode() {
            const savedMode = localStorage.getItem('scorekeeper_input_mode') || 'voice';
            const toggle = document.getElementById('inputModeToggle');
            
            if (!toggle) {
                console.warn('inputModeToggle element not found');
                return;
            }
            
            if (savedMode === 'manual') {
                toggle.checked = true;
                toggleInputMode();
            } else {
                toggle.checked = false;
                inputMode = 'voice';
            }
        }
        function detectGameType(transcript) {
            const lower = transcript.toLowerCase();
            
            if (lower.includes('golf')) return 'golf';
            if (lower.includes('5 crown') || lower.includes('five crown')) return '5crowns';
            if (lower.includes('phase 10') || lower.includes('phase ten') || lower.includes('face 10') || lower.includes('face ten')) return 'phase10';
            if (lower.includes('farkle') || lower.includes('farkel')) return 'farkle';
            if (lower.includes('dart')) return 'darts';
            if (lower.includes('scrabble')) return 'scrabble';
            if (lower.includes('yahtzee') || lower.includes('yatzy')) return 'yahtzee';
            if (lower.includes('general')) return 'general';
            
            // If no match found, default to 'general' for any other game name
            // This allows users to say any game name and we'll use the general format
            return 'general';
        }
        function convertWordToNumber(word) {
            const numbers = {
                'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
                'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,
                'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14,
                'fifteen': 15, 'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19,
                'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,
                'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90,
                'hundred': 100
            };
            
            const lower = word.toLowerCase().trim();
            
            // Check if it's already a number
            if (!isNaN(lower)) {
                return parseInt(lower);
            }
            
            // Check if it's a simple number word
            if (numbers[lower] !== undefined) {
                return numbers[lower];
            }
            
            // Handle compound numbers like "twenty one" or "twenty-one"
            const parts = lower.split(/[\s-]+/);
            if (parts.length === 2) {
                const first = numbers[parts[0]] || 0;
                const second = numbers[parts[1]] || 0;
                if (first > 0 && second > 0 && first >= 20) {
                    return first + second;
                }
            }
            
            return null;
        }
        function correctPronunciation(name) {
            const corrections = {
                'ghee': 'Guy',
                'gee': 'Guy',
                'g': 'Guy',
                'ge': 'Guy',
                'key': 'Guy'
            };
            
            const lowerName = name.toLowerCase().trim();
            
            // Only correct if it's actually a mispronunciation
            // Don't "correct" if user typed the actual name (preserve their capitalization)
            if (corrections[lowerName]) {
                return corrections[lowerName];
            }
            
            // Return original name with original capitalization preserved
            return name;
        }
        // Fuzzy match player name - finds closest match by pronunciation/similarity
        // Global variable to track pending voice confirmations
        let pendingVoiceConfirmation = null;
        
        function findClosestPlayer(spokenName) {
            if (!spokenName || players.length === 0) return null;
            
            const spoken = spokenName.toLowerCase().trim();
            
            // First, try exact match
            let player = players.find(p => p.name.toLowerCase() === spoken);
            if (player) return player;
            
            // Try with pronunciation correction
            const corrected = correctPronunciation(spoken);
            player = players.find(p => p.name.toLowerCase() === corrected.toLowerCase());
            if (player) return player;
            
            // Try partial contains match
            player = players.find(p => 
                p.name.toLowerCase().includes(spoken) || 
                spoken.includes(p.name.toLowerCase())
            );
            if (player) {
                // For partial matches, set up confirmation instead of returning immediately
                setupPlayerConfirmation(spokenName, player);
                return null; // Return null so normal processing doesn't continue
            }
            
            // Calculate similarity scores for all players
            const scores = players.map(p => {
                const playerName = p.name.toLowerCase();
                let score = 0;
                
                // Exact match (already checked above, but just in case)
                if (playerName === spoken) return { player: p, score: 1000 };
                
                // Check if one contains the other
                if (playerName.includes(spoken) || spoken.includes(playerName)) {
                    score += 500;
                }
                
                // Check first letter match
                if (playerName[0] === spoken[0]) {
                    score += 100;
                }
                
                // Check length similarity
                const lengthDiff = Math.abs(playerName.length - spoken.length);
                score += Math.max(0, 50 - (lengthDiff * 10));
                
                // Count matching characters
                const matchingChars = [...spoken].filter(char => playerName.includes(char)).length;
                score += matchingChars * 10;
                
                // Phonetic similarity (vowels)
                const spokenVowels = spoken.match(/[aeiou]/g) || [];
                const playerVowels = playerName.match(/[aeiou]/g) || [];
                const vowelMatch = spokenVowels.filter(v => playerVowels.includes(v)).length;
                score += vowelMatch * 20;
                
                // Check for common sound substitutions
                const soundAlikeMap = {
                    'v': 'b', 'b': 'v',
                    'f': 'v', 'v': 'f',
                    't': 'd', 'd': 't',
                    'k': 'c', 'c': 'k',
                    's': 'z', 'z': 's',
                    'm': 'n', 'n': 'm'
                };
                
                let soundAlikeScore = 0;
                for (let i = 0; i < Math.min(spoken.length, playerName.length); i++) {
                    const spokenChar = spoken[i];
                    const playerChar = playerName[i];
                    if (spokenChar === playerChar) {
                        soundAlikeScore += 15;
                    } else if (soundAlikeMap[spokenChar] === playerChar || soundAlikeMap[playerChar] === spokenChar) {
                        soundAlikeScore += 10;
                    }
                }
                score += soundAlikeScore;
                
                return { player: p, score: score };
            });
            
            // Sort by score descending
            scores.sort((a, b) => b.score - a.score);
            
            console.log('Fuzzy match scores for "' + spoken + '":', scores.map(s => ({ name: s.player.name, score: s.score })));
            
            // If the score is reasonably high but not perfect, ask for confirmation
            if (scores[0].score > 50) {
                console.log('Fuzzy match found:', scores[0].player.name, 'with score:', scores[0].score);
                // Set up confirmation for uncertain matches
                setupPlayerConfirmation(spokenName, scores[0].player);
                return null; // Return null so normal processing doesn't continue
            }
            
            return null;
        }
        
        // Set up player name confirmation
        function setupPlayerConfirmation(spokenName, suggestedPlayer) {
            pendingVoiceConfirmation = {
                type: 'player_confirmation',
                spokenName: spokenName,
                suggestedPlayer: suggestedPlayer,
                timestamp: Date.now()
            };
            
            speak(`Did you mean ${suggestedPlayer.name}? Say yes or no.`);
            
            // Set timeout to clear pending confirmation
            setTimeout(() => {
                if (pendingVoiceConfirmation && pendingVoiceConfirmation.timestamp === Date.now()) {
                    pendingVoiceConfirmation = null;
                    speak('No response received. Please try again.');
                }
            }, 8000); // 8 second timeout
        }
        
        // Handle voice confirmations in the main voice processing
        function handleVoiceConfirmation(transcript) {
            if (!pendingVoiceConfirmation) return false;
            
            const response = transcript.toLowerCase().trim();
            const confirmation = pendingVoiceConfirmation;
            
            if (response.includes('yes') || response === 'y' || response === 'yeah' || response === 'yep') {
                // User confirmed the suggestion
                pendingVoiceConfirmation = null;
                
                // Process the original command with the confirmed player
                const player = confirmation.suggestedPlayer;
                speak(`Got it, ${player.name}.`);
                
                // Here we would need to re-process the original command with the confirmed player
                // This is a simplified version - in practice you'd need to store the original command too
                return true;
                
            } else if (response.includes('no') || response === 'n' || response === 'nope') {
                // User rejected the suggestion
                pendingVoiceConfirmation = null;
                speak(`Okay. Please say the name again clearly.`);
                return true;
                
            }
            
            // If response wasn't clear yes/no, ask again
            speak(`Please say yes or no. Did you mean ${confirmation.suggestedPlayer.name}?`);
            return true;
        }
        
        // Announce current scores for all players
        function announceCurrentScores() {
            if (!gameInProgress || players.length === 0) {
                speak('No game in progress.');
                return;
            }
            
            let announcement = 'Current scores: ';
            const scoresList = [];
            
            // Get scores based on current game type
            players.forEach(player => {
                let currentScore = 0;
                
                if (currentGameType === '5crowns') {
                    // Sum up all rounds played so far
                    currentScore = CROWNS_ROUNDS.reduce((sum, round) => 
                        sum + (crownsScores[player.id]?.[round] || 0), 0);
                } else if (currentGameType === 'golf') {
                    // Sum up all holes played so far
                    if (golfMode === 'advanced') {
                        currentScore = 0;
                        GOLF_HOLES.forEach(hole => {
                            const par = golfCoursePar[hole] || 0;
                            const score = golfScores[player.id]?.[hole] || 0;
                            if (score > 0) currentScore += par + score;
                        });
                    } else {
                        currentScore = GOLF_HOLES.reduce((sum, hole) => 
                            sum + (golfScores[player.id]?.[hole] || 0), 0);
                    }
                } else if (currentGameType === 'scrabble') {
                    // Sum up all turns played so far
                    currentScore = SCRABBLE_TURNS.reduce((sum, turn) => 
                        sum + (scrabbleScores[player.id]?.[turn] || 0), 0);
                } else if (currentGameType === 'yahtzee') {
                    // Calculate Yahtzee total including bonuses
                    currentScore = calculateYahtzeeTotal(player.id);
                } else if (currentGameType === 'phase10') {
                    // Sum up all phase scores
                    currentScore = 0;
                    for (let phase = 1; phase <= 10; phase++) {
                        currentScore += phase10Scores[player.id]?.[`phase${phase}`] || 0;
                    }
                } else if (currentGameType === 'farkle' || currentGameType === 'general') {
                    // Sum up all turns in generic grid
                    currentScore = 0;
                    for (let turn = 1; turn <= 20; turn++) {
                        currentScore += genericGridScores[player.id]?.[`turn${turn}`] || 0;
                    }
                } else {
                    // Standard scoring mode
                    currentScore = player.score || 0;
                }
                
                const scoreUnit = currentGameType === 'darts' ? (currentScore === 1 ? 'leg' : 'legs') : 
                                 (currentScore === 1 ? 'point' : 'points');
                scoresList.push(`${player.name}: ${currentScore} ${scoreUnit}`);
            });
            
            announcement += scoresList.join(', ');
            speak(announcement);
            
            // Show visual feedback
            showVoiceFeedback(' Current Scores', scoresList.join('\n'));
            setTimeout(hideVoiceFeedback, 3000);
        }
        
        // Function to match Start button width to instructions panel width
        function matchStartButtonWidth() {
            const instructionsPanel = document.getElementById('standardModeInstructions');
            const startButton = document.getElementById('gameStateBtn');
            
            if (instructionsPanel && startButton) {
                // Get the actual rendered width of the instructions panel
                const instructionsWidth = instructionsPanel.getBoundingClientRect().width;
                console.log('Instructions panel width:', instructionsWidth + 'px');
                
                // Apply this exact width to the start button
                startButton.style.width = instructionsWidth + 'px';
                console.log('Applied width to Start button:', instructionsWidth + 'px');
            }
        }
        
        function switchTab(tabName) {
            // Cancel any voice operations when switching tabs
            cancelAllVoiceOperations();
            
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                // Add active class to the matching button
                if ((tabName === 'scorekeeper' && btn.textContent.trim() === 'Scoring') ||
                    (tabName === 'highscores' && btn.textContent.trim() === 'High Scores')) {
                    btn.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Show/hide game type row based on tab
            const gameTypeRow = document.querySelector('.game-type-row');
            
            if (tabName === 'scorekeeper') {
                document.getElementById('scorekeeperTab').classList.add('active');
                // Show add player section on scorekeeper tab only if user hasn't clicked "Done Adding"
                const addSection = document.getElementById('addPlayerSection');
                if (addSection && !isDoneAdding) {
                    addSection.style.display = 'flex';
                }
                // Show game type row on Scoring tab
                if (gameTypeRow) {
                    gameTypeRow.style.display = 'flex';
                }
                
                // Match Start button width to instructions panel when on scorekeeper tab
                setTimeout(matchStartButtonWidth, 100); // Small delay to ensure layout is complete
            } else if (tabName === 'highscores') {
                console.log('=== SWITCHING TO WALLS TAB ===');
                document.getElementById('highScoresTab').classList.add('active');
                renderWalls();
                
                // Hide add player section on High Scores tab
                const addSection = document.getElementById('addPlayerSection');
                if (addSection) {
                    addSection.style.display = 'none';
                }
                // Hide game type row on High Scores tab
                if (gameTypeRow) {
                    gameTypeRow.style.display = 'none';
                }
                console.log('=== WALLS TAB SWITCH COMPLETE ===');
            }
        }
        function toggleScoringMode(mode) {
            scoringMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-toggle-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide modes
            if (mode === 'standard') {
                document.getElementById('standardMode').style.display = 'block';
                document.getElementById('crownsMode').classList.remove('active');
            } else {
                document.getElementById('standardMode').style.display = 'none';
                document.getElementById('crownsMode').classList.add('active');
                renderCrownsTable();
            }
        }
        function initializeCrownsScores() {
            players.forEach(player => {
                if (!crownsScores[player.id]) {
                    crownsScores[player.id] = {};
                    CROWNS_ROUNDS.forEach(round => {
                        crownsScores[player.id][round] = 0;
                    });
                    saveCrownsScores();
                }
                // Initialize current round tracker
                if (currentCrownsRound[player.id] === undefined) {
                    currentCrownsRound[player.id] = 0; // Start at round 0 (which is "3")
                }
            });
        }
        function addScoreToCurrentRound(playerId, points) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            // Get current round index for this player
            let roundIndex = currentCrownsRound[playerId] || 0;
            
            // If we're past the last round, don't add
            if (roundIndex >= CROWNS_ROUNDS.length) {
                speak('All rounds complete for ' + player.name);
                showVoiceFeedback(`All rounds complete for ${player.name}`, '');
                setTimeout(hideVoiceFeedback, 2000);
                return;
            }
            const round = CROWNS_ROUNDS[roundIndex];
            
            // Add score to current round
            crownsScores[playerId][round] = points;
            saveCrownsScores();
            
            // Move to next round
            currentCrownsRound[playerId] = roundIndex + 1;
            localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            
            // Provide feedback
            speak(`${points} points for ${player.name} in round ${round}`);
            showVoiceFeedback(`${player.name}: ${points} pts (Round ${round})`, '');
            setTimeout(hideVoiceFeedback, 1500);
            
            // Re-render table with highlight
            renderCrownsTableWithHighlight(playerId, round);
        }
        function renderCrownsTableWithHighlight(highlightPlayerId, highlightRound) {
            renderCrownsTable();
            
            // Add highlight class to the newly entered cell
            setTimeout(() => {
                const table = document.getElementById('crownsTable');
                const rows = table.querySelectorAll('tbody tr');
                const roundIndex = CROWNS_ROUNDS.indexOf(highlightRound);
                
                if (roundIndex >= 0 && rows[roundIndex]) {
                    const playerIndex = players.findIndex(p => p.id === highlightPlayerId);
                    if (playerIndex >= 0) {
                        const cells = rows[roundIndex].querySelectorAll('td');
                        // +1 because first cell is the round label
                        if (cells[playerIndex + 1]) {
                            cells[playerIndex + 1].classList.add('newly-entered');
                        }
                    }
                }
            }, 100);
        }
        function renderCrownsTable() {
            if (players.length === 0) {
                document.getElementById('crownsTable').innerHTML = '';
                return;
            }
            initializeCrownsScores();
            let html = '<thead><tr><th class="round-label"><span class="crown-icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 16L3 5L8.5 10L12 4L15.5 10L21 5L19 16M19 19H5V21H19V19Z" fill="#4a4a4a" stroke="#4a4a4a" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></span></th>';
            
            // Player name headers (editable)
            players.forEach(player => {
                html += `<th class="player-name-header" onclick="editPlayerNameInGrid(${player.id})" id="crown-header-${player.id}">${escapeHtml(player.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            // Round rows
            CROWNS_ROUNDS.forEach(round => {
                const isHighlighted = highlightedRound === round ? ' highlighted' : '';
                if (isHighlighted) {
                    console.log('Round', round, 'should be highlighted. Class:', 'round-label' + isHighlighted);
                }
                html += `<tr><td class="round-label${isHighlighted}" onclick="toggleRoundHighlight('${round}')">${round}</td>`;
                players.forEach(player => {
                    const score = crownsScores[player.id][round] || 0;
                    html += `<td onclick="editCrownsScore(${player.id}, '${round}')" class="editable">${score}</td>`;
                });
                html += '</tr>';
            });
            // Total row
            html += '<tr class="total-row"><td class="round-label">TOT.</td>';
            players.forEach(player => {
                const total = CROWNS_ROUNDS.reduce((sum, round) => sum + (crownsScores[player.id][round] || 0), 0);
                html += `<td>${total}</td>`;
            });
            html += '</tr>';
            html += '</tbody>';
            document.getElementById('crownsTable').innerHTML = html;
            
            // Show the game management buttons
            const buttonsDiv = document.getElementById('crownsButtons');
            if (buttonsDiv && players.length > 0) {
                buttonsDiv.style.display = 'block';
            }
        }
        
        function toggleRoundHighlight(round) {
            console.log('=== toggleRoundHighlight called ===');
            console.log('Round clicked:', round);
            console.log('Current highlightedRound:', highlightedRound);
            
            // Toggle the highlight - if already highlighted, unhighlight it
            if (highlightedRound === round) {
                highlightedRound = null;
                console.log('Unhighlighting - set to null');
            } else {
                highlightedRound = round;
                console.log('Highlighting - set to:', round);
            }
            
            console.log('About to re-render table');
            renderCrownsTable();
            console.log('Table re-rendered');
        }
        function editPlayerNameInGrid(playerId) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const currentName = player.name;
            const cell = event.target;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.maxLength = 20;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                // If name is empty, delete the player and their column
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete player');
                    if (shouldDelete) {
                        // Remove player
                        players = players.filter(p => p.id !== playerId);
                        
                        // Remove their scores
                        delete crownsScores[playerId];
                        delete currentCrownsRound[playerId];
                        
                        savePlayers();
                        saveCrownsScores();
                        localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                    }
                    renderCrownsTable();
                    return;
                }
                
                // Update name if changed
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderCrownsTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function editPlayerNameInGolfGrid(playerId) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const currentName = player.name;
            const cell = event.target;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.maxLength = 20;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                // If name is empty, delete the player and their column
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        // Remove player
                        players = players.filter(p => p.id !== playerId);
                        
                        // Remove their scores
                        delete golfScores[playerId];
                        delete currentGolfHole[playerId];
                        
                        savePlayers();
                    }
                    renderGolfTable();
                    return;
                }
                
                // Update name if changed
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderGolfTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function editCrownsScore(playerId, round) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentScore = crownsScores[playerId][round] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="crowns-input-${playerId}-${round}" inputmode="numeric">`;
            
            const input = document.getElementById(`crowns-input-${playerId}-${round}`);
            input.focus();
            input.select();
            const saveScore = () => {
                const newScore = parseInt(input.value) || 0;
                crownsScores[playerId][round] = newScore;
                saveCrownsScores();
                renderCrownsTable();
            };
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function saveCrownsScores() {
            localStorage.setItem('scorekeeper_crowns_scores', JSON.stringify(crownsScores));
        }
        function loadCrownsScores() {
            const saved = localStorage.getItem('scorekeeper_crowns_scores');
            if (saved) {
                crownsScores = JSON.parse(saved);
            }
            
            const savedRounds = localStorage.getItem('scorekeeper_current_crowns_round');
            if (savedRounds) {
                currentCrownsRound = JSON.parse(savedRounds);
            }
        }
        // ===== GOLF SAVE/LOAD FUNCTIONS =====
        
        function saveGolfData() {
            localStorage.setItem('scorekeeper_golf_scores', JSON.stringify(golfScores));
            localStorage.setItem('scorekeeper_golf_par', JSON.stringify(golfCoursePar));
            localStorage.setItem('scorekeeper_golf_hcp', JSON.stringify(golfCourseHCP));
            localStorage.setItem('scorekeeper_golf_yrd', JSON.stringify(golfCourseYRD));
            localStorage.setItem('scorekeeper_golf_yrd_columns', JSON.stringify(golfCourseYrdColumns));
            localStorage.setItem('scorekeeper_golf_current_hole', JSON.stringify(currentGolfHole));
            localStorage.setItem('scorekeeper_current_golf_course', currentGolfCourse);
        }
        function loadGolfData() {
            const savedScores = localStorage.getItem('scorekeeper_golf_scores');
            if (savedScores) {
                golfScores = JSON.parse(savedScores);
            }
            
            const savedPar = localStorage.getItem('scorekeeper_golf_par');
            if (savedPar) {
                golfCoursePar = JSON.parse(savedPar);
            }
            
            const savedHcp = localStorage.getItem('scorekeeper_golf_hcp');
            if (savedHcp) {
                golfCourseHCP = JSON.parse(savedHcp);
            }
            
            const savedYrd = localStorage.getItem('scorekeeper_golf_yrd');
            if (savedYrd) {
                golfCourseYRD = JSON.parse(savedYrd);
            }
            
            const savedYrdColumns = localStorage.getItem('scorekeeper_golf_yrd_columns');
            if (savedYrdColumns) {
                golfCourseYrdColumns = JSON.parse(savedYrdColumns);
                // Ensure only 3 columns (remove Gold, Black, Green if they exist)
                if (golfCourseYrdColumns.length > 3) {
                    golfCourseYrdColumns = golfCourseYrdColumns.slice(0, 3);
                    localStorage.setItem('scorekeeper_golf_yrd_columns', JSON.stringify(golfCourseYrdColumns));
                }
            }
            
            const savedHole = localStorage.getItem('scorekeeper_golf_current_hole');
            if (savedHole) {
                currentGolfHole = JSON.parse(savedHole);
            }
            
            const savedCourse = localStorage.getItem('scorekeeper_current_golf_course');
            if (savedCourse) {
                currentGolfCourse = savedCourse;
                // Populate the dropdown display
                const selectedSpan = document.getElementById('selectedCourseName');
                if (selectedSpan) {
                    selectedSpan.textContent = currentGolfCourse;
                }
            }
        }
        function showVoiceFeedback(text, transcript) {
            const feedback = document.getElementById('voiceFeedback');
            const transcriptEl = document.getElementById('voiceTranscript');
            document.querySelector('.voice-feedback-text').textContent = text;
            // Use innerHTML instead of textContent to allow buttons to render
            transcriptEl.innerHTML = transcript || '';
            feedback.classList.add('show');
        }
        // ===== GOLF GRID FUNCTIONS =====
        
        function initializeGolfScores() {
            // Only initialize if golfScores doesn't exist
            if (!golfScores) {
                golfScores = {};
            }
            if (!currentGolfHole) {
                currentGolfHole = {};
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!golfScores[player.id]) {
                    golfScores[player.id] = {};
                    GOLF_HOLES.forEach(hole => {
                        golfScores[player.id][hole] = 0;
                    });
                }
                // Initialize current hole tracker for new players
                if (currentGolfHole[player.id] === undefined) {
                    currentGolfHole[player.id] = 0; // Start at hole 1 (index 0)
                }
            });
            
            console.log('Initialized golf scores:', golfScores);
        }
        function renderGolfTable() {
            const courseSelector = document.getElementById('golfCourseSelector');
            
            if (players.length === 0) {
                document.getElementById('golfTable').innerHTML = '';
                
                // Hide course selector when no players
                if (courseSelector) courseSelector.style.display = 'none';
                return;
            }
            // Show course selector when players exist
            if (courseSelector) {
                courseSelector.style.display = 'block';
            }
            
            // Check if each data type has any values (for conditional column display)
            const hasParData = Object.keys(golfCoursePar).length > 0;
            const hasHcpData = Object.keys(golfCourseHCP).length > 0;
            const hasYrdData = Object.keys(golfCourseYRD).length > 0;
            
            let html = '<thead><tr>';
            
            // Tee column header
            html += '<th class="crowns-hole-label golf-info-column">Tee</th>';
            
            // Show Par, HCP, and YRD columns if data exists (course is loaded)
            if (hasParData) html += '<th class="crowns-hole-label golf-info-column">Par</th>';
            if (hasHcpData) html += '<th class="crowns-hole-label golf-info-column">HCP</th>';
            if (hasYrdData) {
                // Add 3 yardage columns with editable names
                golfCourseYrdColumns.forEach((colName, idx) => {
                    html += `<th class="crowns-hole-label golf-info-column yrd-column-header" onclick="editYrdColumnName(${idx})" title="Click to edit color name">${escapeHtml(colName)}</th>`;
                });
            }
            
            // Player name headers (editable)
            players.forEach(player => {
                html += `<th class="crowns-player-header" onclick="editPlayerNameInGolfGrid(${player.id})">${escapeHtml(player.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Front 9 holes (1-9)
            for (let i = 0; i < 9; i++) {
                const hole = GOLF_HOLES[i];
                html += `<tr><td class="crowns-hole-label golf-info-column">${hole}</td>`;
                
                // Show Par, HCP, YRD columns if data exists
                if (hasParData) {
                    const par = golfCoursePar[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editPar('${hole}')">${par || ''}</td>`;
                }
                if (hasHcpData) {
                    const hcp = golfCourseHCP[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editHCP('${hole}')">${hcp || ''}</td>`;
                }
                if (hasYrdData) {
                    // Render 3 yardage columns
                    const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
                    yrdArray.forEach((yrdVal, idx) => {
                        html += `<td class="crowns-score golf-info-column" onclick="editYRD('${hole}', ${idx})">${yrdVal || ''}</td>`;
                    });
                }
                
                // Player score columns - show total strokes
                players.forEach(player => {
                    const scoreValue = golfScores[player.id]?.[hole] || 0;
                    const isCurrentHole = currentGolfHole[player.id] === i;
                    const highlightClass = isCurrentHole ? 'crowns-score-highlight' : '';
                    
                    // Display total strokes (or empty if 0)
                    const displayScore = scoreValue || '';
                    
                    html += `<td class="crowns-score editable ${highlightClass}" onclick="editGolfScore(${player.id}, '${hole}')">${displayScore}</td>`;
                });
                html += '</tr>';
            }
            
            // Front 9 Out subtotal row
            html += '<tr class="total-row golf-out-row"><td class="crowns-hole-label golf-info-column">OUT</td>';
            
            // Show course data totals if they exist
            if (hasParData) {
                let front9Par = 0;
                for (let i = 0; i < 9; i++) {
                    front9Par += golfCoursePar[GOLF_HOLES[i]] || 0;
                }
                html += `<td class="crowns-score golf-info-column">${front9Par || ''}</td>`;
            }
            if (hasHcpData) {
                html += `<td class="crowns-score golf-info-column"></td>`; // Empty HCP cell
            }
            if (hasYrdData) {
                // Total yards for front 9 - for each of 3 columns
                for (let colIdx = 0; colIdx < 3; colIdx++) {
                    let front9YrdCol = 0;
                    for (let i = 0; i < 9; i++) {
                        const yrdArray = golfCourseYRD[GOLF_HOLES[i]] || [0, 0, 0];
                        front9YrdCol += yrdArray[colIdx] || 0;
                    }
                    html += `<td class="crowns-score golf-info-column">${front9YrdCol || ''}</td>`;
                }
            }
            
            players.forEach(player => {
                let frontTotal = 0;
                for (let i = 0; i < 9; i++) {
                    const hole = GOLF_HOLES[i];
                    frontTotal += golfScores[player.id]?.[hole] || 0;
                }
                html += `<td class="crowns-score">${frontTotal || ''}</td>`;
            });
            html += '</tr>';
            
            // Back 9 holes (10-18)
            for (let i = 9; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                html += `<tr><td class="crowns-hole-label golf-info-column">${hole}</td>`;
                
                // Show Par, HCP, YRD columns if data exists
                if (hasParData) {
                    const par = golfCoursePar[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editPar('${hole}')">${par || ''}</td>`;
                }
                if (hasHcpData) {
                    const hcp = golfCourseHCP[hole] || 0;
                    html += `<td class="crowns-score golf-info-column" onclick="editHCP('${hole}')">${hcp || ''}</td>`;
                }
                if (hasYrdData) {
                    // Render 3 yardage columns
                    const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
                    yrdArray.forEach((yrdVal, idx) => {
                        html += `<td class="crowns-score golf-info-column" onclick="editYRD('${hole}', ${idx})">${yrdVal || ''}</td>`;
                    });
                }
                
                // Player score columns - show total strokes
                players.forEach(player => {
                    const scoreValue = golfScores[player.id]?.[hole] || 0;
                    const isCurrentHole = currentGolfHole[player.id] === i;
                    const highlightClass = isCurrentHole ? 'crowns-score-highlight' : '';
                    
                    // Display total strokes (or empty if 0)
                    const displayScore = scoreValue || '';
                    
                    html += `<td class="crowns-score editable ${highlightClass}" onclick="editGolfScore(${player.id}, '${hole}')">${displayScore}</td>`;
                });
                html += '</tr>';
            }
            
            // Back 9 IN subtotal row
            html += '<tr class="total-row"><td class="crowns-hole-label golf-info-column">IN</td>';
            
            // Show course data totals if they exist
            if (hasParData) {
                let back9Par = 0;
                for (let i = 9; i < 18; i++) {
                    back9Par += golfCoursePar[GOLF_HOLES[i]] || 0;
                }
                html += `<td class="crowns-score golf-info-column">${back9Par || ''}</td>`;
            }
            if (hasHcpData) {
                html += `<td class="crowns-score golf-info-column"></td>`; // Empty HCP cell
            }
            if (hasYrdData) {
                // Total yards for back 9 - for each of 3 columns
                for (let colIdx = 0; colIdx < 3; colIdx++) {
                    let back9YrdCol = 0;
                    for (let i = 9; i < 18; i++) {
                        const yrdArray = golfCourseYRD[GOLF_HOLES[i]] || [0, 0, 0];
                        back9YrdCol += yrdArray[colIdx] || 0;
                    }
                    html += `<td class="crowns-score golf-info-column">${back9YrdCol || ''}</td>`;
                }
            }
            
            players.forEach(player => {
                let backTotal = 0;
                for (let i = 9; i < 18; i++) {
                    const hole = GOLF_HOLES[i];
                    backTotal += golfScores[player.id]?.[hole] || 0;
                }
                html += `<td class="crowns-score">${backTotal || ''}</td>`;
            });
            html += '</tr>';
            
            // TOTAL row
            html += '<tr class="total-row"><td class="crowns-hole-label golf-info-column">TOT.</td>';
            
            // Show course data totals if they exist
            if (hasParData) {
                let totalPar = 0;
                GOLF_HOLES.forEach(hole => {
                    totalPar += golfCoursePar[hole] || 0;
                });
                html += `<td class="crowns-score golf-info-column">${totalPar || ''}</td>`;
            }
            if (hasHcpData) {
                html += `<td class="crowns-score golf-info-column"></td>`; // Empty HCP cell
            }
            if (hasYrdData) {
                // Total yards for 18 holes - for each of 3 columns
                for (let colIdx = 0; colIdx < 3; colIdx++) {
                    let totalYrdCol = 0;
                    GOLF_HOLES.forEach(hole => {
                        const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
                        totalYrdCol += yrdArray[colIdx] || 0;
                    });
                    html += `<td class="crowns-score golf-info-column">${totalYrdCol || ''}</td>`;
                }
            }
            
            players.forEach(player => {
                let total = 0;
                GOLF_HOLES.forEach(hole => {
                    total += golfScores[player.id]?.[hole] || 0;
                });
                html += `<td class="crowns-score">${total || ''}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('golfTable').innerHTML = html;
            
            // Show the game management buttons
            const buttonsDiv = document.getElementById('golfButtons');
            if (buttonsDiv && players.length > 0) {
                buttonsDiv.style.display = 'block';
            }
        }
        function editPar(hole) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentPar = golfCoursePar[hole] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentPar}" id="par-input-${hole}" inputmode="numeric" min="1" max="9">`;
            
            const input = document.getElementById(`par-input-${hole}`);
            input.focus();
            input.select();
            const savePar = () => {
                const newPar = parseInt(input.value);
                if (!isNaN(newPar) && newPar > 0) {
                    golfCoursePar[hole] = newPar;
                } else if (input.value === '' || input.value === '0') {
                    delete golfCoursePar[hole];
                }
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', savePar);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editHCP(hole) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentHCP = golfCourseHCP[hole] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentHCP}" id="hcp-input-${hole}" inputmode="numeric" min="1" max="18">`;
            
            const input = document.getElementById(`hcp-input-${hole}`);
            input.focus();
            input.select();
            const saveHCP = () => {
                const newHCP = parseInt(input.value);
                if (!isNaN(newHCP) && newHCP > 0) {
                    golfCourseHCP[hole] = newHCP;
                } else if (input.value === '' || input.value === '0') {
                    delete golfCourseHCP[hole];
                }
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', saveHCP);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editYRD(hole, colIdx) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const yrdArray = golfCourseYRD[hole] || [0, 0, 0];
            const currentYRD = yrdArray[colIdx] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentYRD}" id="yrd-input-${hole}-${colIdx}" inputmode="numeric" min="1" max="999">`;
            
            const input = document.getElementById(`yrd-input-${hole}-${colIdx}`);
            input.focus();
            input.select();
            const saveYRD = () => {
                const newYRD = parseInt(input.value);
                
                // Initialize array if it doesn't exist
                if (!golfCourseYRD[hole]) {
                    golfCourseYRD[hole] = [0, 0, 0];
                }
                
                if (!isNaN(newYRD) && newYRD > 0) {
                    golfCourseYRD[hole][colIdx] = newYRD;
                } else if (input.value === '' || input.value === '0') {
                    golfCourseYRD[hole][colIdx] = 0;
                }
                
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', saveYRD);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        async function editYrdColumnName(colIdx) {
            const currentName = golfCourseYrdColumns[colIdx];
            const newName = await customPrompt(`Edit tee box color name:`, ` Edit column name`, currentName);
            
            if (newName && newName.trim()) {
                golfCourseYrdColumns[colIdx] = newName.trim();
                saveGolfData();
                renderGolfTable();
            }
        }
        async function saveGolfCourse() {
            const courseName = document.getElementById('golfCourseName').value.trim();
            
            if (!courseName) {
                await customAlert('Please enter a course name', ' Course name required');
                return;
            }
            
            // Check if par values are set
            const hasParData = Object.keys(golfCoursePar).length > 0;
            if (!hasParData) {
                await customAlert('Please enter Par values for the holes before saving', ' Par values required');
                return;
            }
            
            // Save course data
            savedGolfCourses[courseName] = {
                par: {...golfCoursePar},
                hcp: {...golfCourseHCP},
                yrd: {...golfCourseYRD},
                yrdColumns: [...golfCourseYrdColumns]
            };
            
            currentGolfCourse = courseName;
            
            localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
            
            // Save current golf data
            saveGolfData();
            
            // Update the datalist
            updateSavedCoursesList();
            
            await customAlert(`Course "${courseName}" saved successfully!`, ' Course saved');
            console.log('Saved golf course:', courseName);
        }
        function editCourse(courseName) {
            if (!savedGolfCourses[courseName]) {
                customAlert(`Course "${courseName}" not found.`, ' Course not found');
                return;
            }
            
            // Close dropdown
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Store the original course name for reference
            window.editingCourseName = courseName;
            
            // Get course data
            const course = savedGolfCourses[courseName];
            
            // Populate the edit modal
            const modal = document.getElementById('editCourseModal');
            const nameInput = document.getElementById('editCourseName');
            const gridContainer = document.getElementById('editCourseGrid');
            
            nameInput.value = courseName;
            
            // Build the grid
            let html = `
                <div class="edit-course-grid-header">Tee</div>
                <div class="edit-course-grid-header">Par</div>
                <div class="edit-course-grid-header">HCP</div>
            `;
            
            // Add 4 YRD column headers: Gold, Blue, White, Red
            // Always use these 4 as defaults
            let courseYrdColumns = course.yrdColumns || ['Gold', 'Blue', 'White', 'Red'];
            
            // Ensure we have exactly 4 columns
            if (courseYrdColumns.length < 4) {
                // Pad with defaults if less than 4
                const defaultNames = ['Gold', 'Blue', 'White', 'Red'];
                while (courseYrdColumns.length < 4) {
                    courseYrdColumns.push(defaultNames[courseYrdColumns.length]);
                }
            } else if (courseYrdColumns.length > 4) {
                courseYrdColumns = courseYrdColumns.slice(0, 4);
            }
            
            // Store these for use in the modal editing
            window.currentEditingYrdColumns = [...courseYrdColumns];
            
            courseYrdColumns.forEach((colName, idx) => {
                html += `<div class="edit-course-grid-item">
                    <input type="text" class="wins-tracker-input" id="edit-color-name-${idx}" value="${escapeHtml(colName)}" maxlength="20" placeholder="Color name" style="width: 100%; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px; font-family: Outfit, sans-serif; font-weight: 600; font-size: 0.85rem;">
                </div>`;
            });
            
            for (let i = 0; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                const par = course.par[hole] || '';
                const hcp = course.hcp[hole] || '';
                const yrdArray = course.yrd?.[hole] || [0, 0, 0, 0];
                
                html += `
                    <div class="edit-course-grid-item" style="font-weight: 700;">${hole}</div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-par-${hole}" value="${par}" min="1" max="9" inputmode="numeric">
                    </div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-hcp-${hole}" value="${hcp}" min="1" max="18" inputmode="numeric">
                    </div>
                `;
                
                // Add 4 YRD input fields (Gold, Blue, White, Red)
                for (let colIdx = 0; colIdx < 4; colIdx++) {
                    const yrdVal = yrdArray[colIdx] || '';
                    html += `
                        <div class="edit-course-grid-item">
                            <input type="number" class="edit-course-input" id="edit-yrd-${hole}-${colIdx}" value="${yrdVal}" min="1" max="999" inputmode="numeric">
                        </div>
                    `;
                }
            }
            
            gridContainer.innerHTML = html;
            
            // Show modal
            modal.classList.add('show');
        }
        function addNewCourse() {
            // Close dropdown
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Mark that we're creating a new course (not editing)
            window.editingCourseName = null;
            
            // Populate the edit modal with empty data
            const modal = document.getElementById('editCourseModal');
            const nameInput = document.getElementById('editCourseName');
            const gridContainer = document.getElementById('editCourseGrid');
            
            if (!modal || !nameInput || !gridContainer) {
                console.error('Modal elements not found!');
                return;
            }
            
            nameInput.value = '';
            
            // Build the grid with empty values
            let html = `
                <div class="edit-course-grid-header">Tee</div>
                <div class="edit-course-grid-header">Par</div>
                <div class="edit-course-grid-header">HCP</div>
            `;
            
            // Add 4 YRD column headers: Gold, Blue, White, Red
            const displayColumns = ['Gold', 'Blue', 'White', 'Red'];
            
            // Store these for use in the modal editing
            window.currentEditingYrdColumns = [...displayColumns];
            
            displayColumns.forEach((colName, idx) => {
                html += `<div class="edit-course-grid-item">
                    <input type="text" class="wins-tracker-input" id="edit-color-name-${idx}" value="${escapeHtml(colName)}" maxlength="20" placeholder="Color name" style="width: 100%; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px; font-family: Outfit, sans-serif; font-weight: 600; font-size: 0.85rem;">
                </div>`;
            });
            
            for (let i = 0; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                
                html += `
                    <div class="edit-course-grid-item" style="font-weight: 700;">${hole}</div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-par-${hole}" value="" min="1" max="9" inputmode="numeric" placeholder="Par">
                    </div>
                    <div class="edit-course-grid-item">
                        <input type="number" class="edit-course-input" id="edit-hcp-${hole}" value="" min="1" max="18" inputmode="numeric" placeholder="HCP">
                    </div>
                `;
                
                // Add 4 YRD input fields (Gold, Blue, White, Red)
                for (let colIdx = 0; colIdx < 4; colIdx++) {
                    html += `
                        <div class="edit-course-grid-item">
                            <input type="number" class="edit-course-input" id="edit-yrd-${hole}-${colIdx}" value="" min="1" max="999" inputmode="numeric" placeholder="Yds">
                        </div>
                    `;
                }
            }
            
            gridContainer.innerHTML = html;
            
            // Show modal
            modal.classList.add('show');
        }
        function closeEditCourseModal() {
            const modal = document.getElementById('editCourseModal');
            modal.classList.remove('show');
            window.editingCourseName = null;
            window.currentEditingYrdColumns = null;
        }
        async function saveEditedCourse() {
            const originalName = window.editingCourseName;
            const newName = document.getElementById('editCourseName').value.trim();
            
            if (!newName) {
                await customAlert('Please enter a course name', ' Course name required');
                return;
            }
            
            // Collect Par and HCP values
            const newPar = {};
            const newHcp = {};
            const newYrd = {};
            let hasParData = false;
            
            for (let i = 0; i < 18; i++) {
                const hole = GOLF_HOLES[i];
                const parInput = document.getElementById(`edit-par-${hole}`);
                const hcpInput = document.getElementById(`edit-hcp-${hole}`);
                
                const parValue = parseInt(parInput.value);
                const hcpValue = parseInt(hcpInput.value);
                
                if (!isNaN(parValue) && parValue > 0) {
                    newPar[hole] = parValue;
                    hasParData = true;
                }
                
                if (!isNaN(hcpValue) && hcpValue > 0) {
                    newHcp[hole] = hcpValue;
                }
                
                // Collect 4 YRD values (Gold, Blue, White, Red)
                const yrdArray = [0, 0, 0, 0];
                let hasYrdData = false;
                for (let colIdx = 0; colIdx < 4; colIdx++) {
                    const yrdInput = document.getElementById(`edit-yrd-${hole}-${colIdx}`);
                    const yrdValue = parseInt(yrdInput.value);
                    if (!isNaN(yrdValue) && yrdValue > 0) {
                        yrdArray[colIdx] = yrdValue;
                        hasYrdData = true;
                    }
                }
                
                if (hasYrdData) {
                    newYrd[hole] = yrdArray;
                }
            }
            
            // Get the edited color names from input boxes
            const newYrdColumns = [];
            for (let i = 0; i < 4; i++) {
                const colorInput = document.getElementById(`edit-color-name-${i}`);
                const colorName = colorInput ? colorInput.value.trim() : ['Gold', 'Blue', 'White', 'Red'][i];
                newYrdColumns.push(colorName || ['Gold', 'Blue', 'White', 'Red'][i]);
            }
            
            if (!hasParData) {
                await customAlert('Please enter at least one Par value', ' Par values required');
                return;
            }
            
            // Check if name changed and new name already exists
            if (newName !== originalName && savedGolfCourses[newName]) {
                const overwrite = await customConfirm(`A course named "${newName}" already exists. Do you want to overwrite it?`, ' Course exists');
                if (!overwrite) {
                    return;
                }
            }
            
            // Remove old course if name changed
            if (newName !== originalName) {
                delete savedGolfCourses[originalName];
            }
            
            // Save updated course
            savedGolfCourses[newName] = {
                par: newPar,
                hcp: newHcp,
                yrd: newYrd,
                yrdColumns: newYrdColumns
            };
            
            localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
            
            // Update datalist
            updateSavedCoursesList();
            
            // If this is the currently loaded course, update it
            if (currentGolfCourse === originalName) {
                currentGolfCourse = newName;
                golfCoursePar = {...newPar};
                golfCourseHCP = {...newHcp};
                golfCourseYRD = {...newYrd};
                golfCourseYrdColumns = [...newYrdColumns];
                
                const selectedSpan = document.getElementById('selectedCourseName');
                if (selectedSpan) {
                    selectedSpan.textContent = newName;
                }
                
                saveGolfData();
                renderGolfTable();
            }
            
            // Close edit modal
            const editModal = document.getElementById('editCourseModal');
            editModal.classList.remove('show');
            window.editingCourseName = null;
            
            // Show success message
            const isNewCourse = !originalName;
            const successMessage = isNewCourse ? 
                `Course "${newName}" created successfully!` : 
                `Course "${newName}" updated successfully!`;
            await customAlert(successMessage, isNewCourse ? ' Course created' : ' Course updated');
            
            console.log('Updated golf course:', newName);
        }
        async function deleteCourse(courseName) {
            const confirm = await customConfirm(`Are you sure you want to delete "${courseName}"? This cannot be undone.`, ' Delete course');
            
            if (confirm) {
                delete savedGolfCourses[courseName];
                localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
                
                // Update dropdown list
                updateSavedCoursesList();
                
                // Show success message
                showVoiceFeedback(`Course Deleted: ${courseName}`, 'Successfully removed');
                setTimeout(hideVoiceFeedback, 2000);
                
                console.log('Deleted golf course:', courseName);
            }
        }
        function updateSavedCoursesList() {
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (!dropdownList) return;
            
            dropdownList.innerHTML = '';
            
            const courseNames = Object.keys(savedGolfCourses);
            const selectedSpan = document.getElementById('selectedCourseName');
            
            if (courseNames.length === 0) {
                // If no courses, show "Add a course" as the selected text
                if (selectedSpan) {
                    selectedSpan.textContent = 'Add a course';
                }
                
                // Don't populate dropdown list - clicking will directly open modal
            } else {
                // When courses exist, show "Select a course" if no course is currently loaded
                if (selectedSpan && !currentGolfCourse) {
                    selectedSpan.textContent = 'Select a course';
                }
                
                // Show all courses
                courseNames.forEach(courseName => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-list-item';
                    
                    // Create course name span (clickable to load)
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'dropdown-course-name';
                    nameSpan.textContent = courseName;
                    nameSpan.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        selectCourseFromDropdown(courseName);
                    });
                    
                    // Create buttons container
                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'dropdown-course-actions';
                    
                    // Edit button
                    const editBtn = document.createElement('button');
                    editBtn.className = 'dropdown-action-btn';
                    editBtn.innerHTML = '';
                    editBtn.title = 'Edit course';
                    editBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        editCourse(courseName);
                    });
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'dropdown-action-btn';
                    deleteBtn.innerHTML = '';
                    deleteBtn.title = 'Delete course';
                    deleteBtn.addEventListener('click', async function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        await deleteCourse(courseName);
                    });
                    
                    buttonsDiv.appendChild(editBtn);
                    buttonsDiv.appendChild(deleteBtn);
                    
                    item.appendChild(nameSpan);
                    item.appendChild(buttonsDiv);
                    dropdownList.appendChild(item);
                });
                
                // Add "Add New Course" button at bottom
                const addButton = document.createElement('div');
                addButton.className = 'dropdown-add-new-btn';
                addButton.innerHTML = ' Add new course';
                addButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    addNewCourse();
                });
                dropdownList.appendChild(addButton);
            }
        }
        function toggleGolfCourseDropdown() {
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            
            if (!dropdown || !dropdownList) {
                return;
            }
            
            // If no courses exist, directly open the Add Course dialog
            const courseNames = Object.keys(savedGolfCourses);
            
            if (courseNames.length === 0) {
                addNewCourse();
                return;
            }
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        function selectCourseFromDropdown(courseName) {
            const selectedSpan = document.getElementById('selectedCourseName');
            if (selectedSpan) {
                selectedSpan.textContent = courseName;
            }
            
            // Close the dropdown
            const dropdown = document.getElementById('golfCourseDropdown');
            const dropdownList = document.getElementById('golfCourseDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Load the course
            loadCourseByName(courseName);
        }
        
        function toggleGameTypeDropdown() {
            const dropdown = document.getElementById('gameTypeDropdown');
            const dropdownList = document.getElementById('gameTypeDropdownList');
            
            if (!dropdown || !dropdownList) return;
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        
        function selectGameType(gameValue) {
            console.log('=== selectGameType called ===');
            console.log('gameValue:', gameValue);
            
            const selectedSpan = document.getElementById('selectedGameType');
            const hiddenSelect = document.getElementById('gameType');
            const dropdown = document.getElementById('gameTypeDropdown');
            const dropdownList = document.getElementById('gameTypeDropdownList');
            
            // Get display name from the clicked item
            const gameNames = {
                'general': 'General',
                'golf': 'Golf',
                '5crowns': '5 Crowns',
                'phase10': 'Phase 10',
                'farkle': 'Farkle',
                'darts': 'Darts',
                'scrabble': 'Scrabble',
                'yahtzee': 'Yahtzee'
            };
            
            if (selectedSpan) {
                selectedSpan.textContent = gameNames[gameValue] || gameValue;
            }
            
            // Update hidden select
            if (hiddenSelect) {
                hiddenSelect.value = gameValue;
                console.log('Updated hidden select to:', hiddenSelect.value);
            }
            
            // Explicitly set currentGameType
            currentGameType = gameValue;
            console.log('Set currentGameType to:', currentGameType);
            
            // Close dropdown
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Trigger change
            console.log('About to call changeGameType()');
            changeGameType();
        }
        
        function toggleThemeDropdown() {
            const dropdown = document.getElementById('themeDropdown');
            const dropdownList = document.getElementById('themeDropdownList');
            
            if (!dropdown || !dropdownList) return;
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        
        function selectTheme(themeValue) {
            const selectedSpan = document.getElementById('selectedTheme');
            const hiddenSelect = document.getElementById('themeSelect');
            const dropdown = document.getElementById('themeDropdown');
            const dropdownList = document.getElementById('themeDropdownList');
            
            // Get display name
            const themeNames = {
                'stainless': 'Steel',
                'default': 'Neon'
            };
            
            if (selectedSpan) {
                selectedSpan.textContent = themeNames[themeValue] || themeValue;
            }
            
            // Update hidden select
            if (hiddenSelect) {
                hiddenSelect.value = themeValue;
            }
            
            // Close dropdown
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Trigger theme change
            changeTheme();
        }
        
        function loadCourseByName(courseName) {
            if (!savedGolfCourses[courseName]) {
                customAlert(`Course "${courseName}" not found.`, ' Course not found');
                return;
            }
            
            // Load course data
            const courseData = savedGolfCourses[courseName];
            golfCoursePar = {...courseData.par};
            golfCourseHCP = {...courseData.hcp};
            golfCourseYRD = {...(courseData.yrd || {})};
            
            // Load column names if saved with course, otherwise use defaults
            if (courseData.yrdColumns) {
                golfCourseYrdColumns = [...courseData.yrdColumns];
            } else {
                golfCourseYrdColumns = ['Blue', 'White', 'Red'];
            }
            
            currentGolfCourse = courseName;
            
            saveGolfData();
            renderGolfTable();
            
            // Show feedback
            showVoiceFeedback(`Course Loaded: ${courseName}`, `Par ${Object.values(golfCoursePar).reduce((sum, val) => sum + val, 0)}`);
            setTimeout(hideVoiceFeedback, 2000);
            
            console.log('Loaded golf course:', courseName);
        }
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            // Close golf course dropdown
            const golfDropdown = document.getElementById('golfCourseDropdown');
            const golfDropdownList = document.getElementById('golfCourseDropdownList');
            
            if (golfDropdown && golfDropdownList && 
                !golfDropdown.contains(e.target) && 
                !golfDropdownList.contains(e.target)) {
                golfDropdown.classList.remove('open');
                golfDropdownList.classList.remove('open');
            }
            
            // Close game type dropdown
            const gameDropdown = document.getElementById('gameTypeDropdown');
            const gameDropdownList = document.getElementById('gameTypeDropdownList');
            
            if (gameDropdown && gameDropdownList && 
                !gameDropdown.contains(e.target) && 
                !gameDropdownList.contains(e.target)) {
                gameDropdown.classList.remove('open');
                gameDropdownList.classList.remove('open');
            }
            
            // Close theme dropdown
            const themeDropdown = document.getElementById('themeDropdown');
            const themeDropdownList = document.getElementById('themeDropdownList');
            
            if (themeDropdown && themeDropdownList && 
                !themeDropdown.contains(e.target) && 
                !themeDropdownList.contains(e.target)) {
                themeDropdown.classList.remove('open');
                themeDropdownList.classList.remove('open');
            }
            
            // Close scorecard dropdown
            const scorecardDropdown = document.getElementById('scorecardDropdown');
            const scorecardDropdownList = document.getElementById('scorecardDropdownList');
            
            if (scorecardDropdown && scorecardDropdownList && 
                !scorecardDropdown.contains(e.target) && 
                !scorecardDropdownList.contains(e.target)) {
                scorecardDropdown.classList.remove('open');
                scorecardDropdownList.classList.remove('open');
            }
            
            // Close wins tracker dropdown
            const winsTrackerDropdown = document.getElementById('winsTrackerDropdown');
            const winsTrackerDropdownList = document.getElementById('winsTrackerDropdownList');
            
            if (winsTrackerDropdown && winsTrackerDropdownList && 
                !winsTrackerDropdown.contains(e.target) && 
                !winsTrackerDropdownList.contains(e.target)) {
                winsTrackerDropdown.classList.remove('open');
                winsTrackerDropdownList.classList.remove('open');
            }
            
            // Close Scrabble timer dropdown
            const scrabbleTimerDropdown = document.getElementById('scrabbleTimerDropdown');
            const scrabbleTimerDropdownList = document.getElementById('scrabbleTimerDropdownList');
            
            if (scrabbleTimerDropdown && scrabbleTimerDropdownList && 
                !scrabbleTimerDropdown.contains(e.target) && 
                !scrabbleTimerDropdownList.contains(e.target)) {
                scrabbleTimerDropdown.classList.remove('open');
                scrabbleTimerDropdownList.classList.remove('open');
            }
        });
        function loadSavedGolfCourses() {
            const saved = localStorage.getItem('scorekeeper_golf_courses');
            if (saved) {
                try {
                    savedGolfCourses = JSON.parse(saved);
                    
                    const standardNames = ['Blue', 'White', 'Red'];
                    
                    // Clean up any courses that have more than 3 yardage columns
                    Object.keys(savedGolfCourses).forEach(courseName => {
                        const course = savedGolfCourses[courseName];
                        
                        // Limit yrdColumns to 3 and replace Gold, Black, Green
                        if (course.yrdColumns) {
                            if (course.yrdColumns.length > 3) {
                                course.yrdColumns = course.yrdColumns.slice(0, 3);
                            }
                            // Replace Gold, Black, Green with Blue, White, Red
                            course.yrdColumns = course.yrdColumns.map((name, idx) => {
                                if (['Gold', 'Black', 'Green'].includes(name)) {
                                    return standardNames[idx] || name;
                                }
                                return name;
                            });
                        } else {
                            course.yrdColumns = standardNames;
                        }
                        
                        // Limit each hole's yardage array to 3 values
                        if (course.yrd) {
                            Object.keys(course.yrd).forEach(hole => {
                                if (Array.isArray(course.yrd[hole]) && course.yrd[hole].length > 3) {
                                    course.yrd[hole] = course.yrd[hole].slice(0, 3);
                                }
                            });
                        }
                    });
                    
                    // Save cleaned data back to localStorage
                    localStorage.setItem('scorekeeper_golf_courses', JSON.stringify(savedGolfCourses));
                } catch (e) {
                    console.error('Error loading golf courses:', e);
                }
            }
            // Always update the list to show proper default text
            updateSavedCoursesList();
        }
        function editGolfScore(playerId, hole) {
            // Cancel voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const cell = event.target;
            const currentScore = golfScores[playerId][hole] || 0;
            // Always use number input for total strokes
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="golf-input-${playerId}-${hole}" inputmode="numeric" min="0" max="20">`;
            
            const input = document.getElementById(`golf-input-${playerId}-${hole}`);
            input.focus();
            input.select();
            const saveScore = () => {
                const newScore = parseInt(input.value) || 0;
                if (!isNaN(newScore) && newScore >= 0) {
                    if (!golfScores[playerId]) {
                        golfScores[playerId] = {};
                    }
                    golfScores[playerId][hole] = newScore;
                }
                saveGolfData();
                renderGolfTable();
            };
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function addScoreToCurrentGolfHole(playerId, points) {
            const holeIndex = currentGolfHole[playerId];
            if (holeIndex >= GOLF_HOLES.length) {
                console.log('All holes completed for player', playerId);
                return false;
            }
            
            const hole = GOLF_HOLES[holeIndex];
            golfScores[playerId][hole] = points;
            
            // Move to next hole
            currentGolfHole[playerId] = holeIndex + 1;
            
            saveGolfData();
            
            console.log(`Added ${points} for player ${playerId} in hole ${hole}`);
            renderGolfTableWithHighlight(playerId, hole);
            
            return true;
        }
        function renderGolfTableWithHighlight(playerId, hole) {
            renderGolfTable();
            
            // Add temporary highlight animation
            setTimeout(() => {
                const cells = document.querySelectorAll('.crowns-score-highlight');
                cells.forEach(cell => {
                    cell.classList.remove('crowns-score-highlight');
                });
            }, 2000);
        }
        function toggleGolfMode() {
            const toggle = document.getElementById('golfModeToggle');
            const simpleLabel = document.getElementById('simpleLabel');
            const advancedLabel = document.getElementById('advancedLabel');
            
            if (toggle.checked) {
                // Advanced mode
                golfMode = 'advanced';
                simpleLabel.classList.remove('active');
                advancedLabel.classList.add('active');
                
                // Save preference
                localStorage.setItem('scorekeeper_golf_mode', 'advanced');
                
                console.log(' Switched to Advanced Golf mode');
                
                // Show helpful message
                showVoiceFeedback('Advanced Golf Mode', 'Enter course, set Par/HCP, use "over/under" scoring');
                setTimeout(hideVoiceFeedback, 3000);
                
                // Re-render golf table with advanced features
                renderGolfTable();
            } else {
                // Simple mode
                golfMode = 'simple';
                simpleLabel.classList.add('active');
                advancedLabel.classList.remove('active');
                
                // Save preference
                localStorage.setItem('scorekeeper_golf_mode', 'simple');
                
                console.log(' Switched to Simple Golf mode');
                
                // Show helpful message
                showVoiceFeedback('Simple Golf Mode', 'Standard stroke count scoring');
                setTimeout(hideVoiceFeedback, 2000);
                
                // Re-render golf table in simple mode
                renderGolfTable();
            }
        }
        
        // Load golf mode preference on page load
        function loadGolfMode() {
            const savedMode = localStorage.getItem('scorekeeper_golf_mode') || 'simple';
            const toggle = document.getElementById('golfModeToggle');
            
            if (toggle && savedMode === 'advanced') {
                toggle.checked = true;
                toggleGolfMode();
            } else if (toggle) {
                toggle.checked = false;
                golfMode = 'simple';
            }
        }
        // ===== SCRABBLE GRID FUNCTIONS =====
        
        function initializeScrabbleScores() {
            // Only initialize if scrabbleScores doesn't exist
            if (!scrabbleScores) {
                scrabbleScores = {};
            }
            if (!currentScrabbleTurn) {
                currentScrabbleTurn = {};
            }
            
            // Only reset turns if we're starting fresh (no existing scores)
            if (Object.keys(scrabbleScores).length === 0) {
                SCRABBLE_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
                scrabbleMaxTurn = 12;
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!scrabbleScores[player.id]) {
                    scrabbleScores[player.id] = {};
                    SCRABBLE_TURNS.forEach(turn => {
                        scrabbleScores[player.id][turn] = 0;
                    });
                    scrabbleScores[player.id]['unplayed'] = 0;
                    scrabbleScores[player.id]['opponents'] = 0;
                }
                // Initialize current turn tracker for new players
                if (currentScrabbleTurn[player.id] === undefined) {
                    currentScrabbleTurn[player.id] = 0; // Start at turn 1 (index 0)
                }
            });
            
            console.log('Initialized Scrabble scores:', scrabbleScores);
        }
        let scrabbleRenderTimeout = null;
        function renderScrabbleTable() {
            // Debounce renders to prevent duplication issues
            if (scrabbleRenderTimeout) {
                clearTimeout(scrabbleRenderTimeout);
            }
            
            scrabbleRenderTimeout = setTimeout(() => {
                renderScrabbleTableNow();
                scrabbleRenderTimeout = null;
            }, 10);
        }
        
        function renderScrabbleTableNow() {
            const buttonContainer = document.getElementById('scrabbleButtons');
            const wordChecker = document.getElementById('scrabbleWordChecker');
            
            console.log('=== RENDER SCRABBLE TABLE ===');
            console.log('Players:', players.length);
            console.log('scrabbleScores:', JSON.stringify(scrabbleScores, null, 2));
            
            if (players.length === 0) {
                document.getElementById('scrabbleTable').innerHTML = '';
                // Hide buttons and word checker when no players
                if (buttonContainer) buttonContainer.style.display = 'none';
                if (wordChecker) wordChecker.style.display = 'none';
                return;
            }
            // Show buttons and word checker when players exist
            if (buttonContainer) buttonContainer.style.display = 'block';
            if (wordChecker) {
                wordChecker.style.display = 'block';
                // Initialize the checkmark button state when word checker becomes visible
                setTimeout(() => {
                    updateScrabbleCheckButton();
                }, 100); // Small delay to ensure elements are rendered
            }
            let html = '<thead><tr><th class="crowns-hole-label">TURN</th>';
            
            // Header row with player names (editable)
            players.forEach(player => {
                html += `<th class="crowns-player-header" onclick="editPlayerNameInScrabbleGrid(${player.id})">${escapeHtml(player.name)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Turn rows
            SCRABBLE_TURNS.forEach((turn, index) => {
                html += `<tr><td class="crowns-hole-label">${turn}</td>`;
                players.forEach(player => {
                    const score = scrabbleScores[player.id]?.[turn] || 0;
                    const isCurrentTurn = currentScrabbleTurn[player.id] === index;
                    const highlightClass = isCurrentTurn ? 'crowns-score-highlight' : '';
                    html += `<td class="crowns-score ${highlightClass}" onclick="editScrabbleScore(${player.id}, '${turn}')">${score}</td>`;
                });
                html += '</tr>';
            });
            
            // Unplayed Tiles row
            html += '<tr><td class="crowns-hole-label" style="background: rgba(255,0,110,0.1);">Unplayed Tiles</td>';
            players.forEach(player => {
                const score = scrabbleScores[player.id]?.['unplayed'] || 0;
                // Display as negative number (except 0)
                const displayScore = score === 0 ? 0 : -score;
                console.log(`Rendering ${player.name} unplayed: ${displayScore}`);
                html += `<td class="crowns-score" style="background: rgba(255,0,110,0.1);" onclick="editScrabbleScore(${player.id}, 'unplayed')">${displayScore}</td>`;
            });
            html += '</tr>';
            
            // Opponents' Tiles row
            html += '<tr><td class="crowns-hole-label" style="background: rgba(0,245,255,0.1);">Opponents\' Tiles</td>';
            players.forEach(player => {
                const score = scrabbleScores[player.id]?.['opponents'] || 0;
                console.log(`Rendering ${player.name} opponents: ${score}`);
                html += `<td class="crowns-score" style="background: rgba(0,245,255,0.1);" onclick="editScrabbleScore(${player.id}, 'opponents')">${score}</td>`;
            });
            html += '</tr>';
            
            // Total row
            html += '<tr class="crowns-total-row"><td class="crowns-hole-label">Total Points</td>';
            players.forEach(player => {
                // Sum turn scores, subtract unplayed, add opponents
                let total = 0;
                SCRABBLE_TURNS.forEach(turn => {
                    total += scrabbleScores[player.id]?.[turn] || 0;
                });
                total -= scrabbleScores[player.id]?.['unplayed'] || 0;
                total += scrabbleScores[player.id]?.['opponents'] || 0;
                html += `<td class="crowns-total">${total}</td>`;
            });
            html += '</tr></tbody>';
            
            document.getElementById('scrabbleTable').innerHTML = html;
        }
        function editPlayerNameInScrabbleGrid(playerId) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            const currentName = player.name;
            const cell = event.target;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.maxLength = 20;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete scrabbleScores[playerId];
                        delete currentScrabbleTurn[playerId];
                        savePlayers();
                    }
                    renderScrabbleTable();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderScrabbleTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function editScrabbleScore(playerId, turn) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const cell = event.target;
            const currentScore = scrabbleScores[playerId][turn] || 0;
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="scrabble-input-${playerId}-${turn}" inputmode="numeric">`;
            
            const input = document.getElementById(`scrabble-input-${playerId}-${turn}`);
            input.focus();
            input.select();
            const saveScore = () => {
                const newScore = parseInt(input.value) || 0;
                scrabbleScores[playerId][turn] = newScore;
                
                // If unplayed tiles changed, recalculate opponents' tiles distribution
                if (turn === 'unplayed') {
                    console.log('Unplayed tiles changed - recalculating distribution');
                    recalculateScrabbleOpponentsTiles();
                }
                
                saveScrabbleData();
                renderScrabbleTable();
            };
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        
        function recalculateScrabbleOpponentsTiles() {
            console.log('=== RECALCULATING OPPONENTS TILES ===');
            
            // Calculate total unplayed tiles
            let totalUnplayed = 0;
            let playersWithNoTiles = [];
            
            players.forEach(player => {
                const unplayed = scrabbleScores[player.id]?.['unplayed'] || 0;
                console.log(`${player.name}: ${unplayed} unplayed tiles`);
                if (unplayed === 0) {
                    playersWithNoTiles.push(player);
                } else {
                    totalUnplayed += unplayed;
                }
            });
            
            console.log(`Total unplayed: ${totalUnplayed}`);
            console.log(`Players with no tiles: ${playersWithNoTiles.map(p => p.name).join(', ')}`);
            
            // Calculate points per player with no tiles
            let pointsPerPlayer = 0;
            if (playersWithNoTiles.length > 0) {
                pointsPerPlayer = Math.floor(totalUnplayed / playersWithNoTiles.length);
                console.log(`Points per player: ${totalUnplayed}  ${playersWithNoTiles.length} = ${pointsPerPlayer}`);
            }
            
            // Update opponents' tiles for all players
            players.forEach(player => {
                const unplayed = scrabbleScores[player.id]?.['unplayed'] || 0;
                if (unplayed === 0) {
                    // No unplayed tiles - collect from others
                    scrabbleScores[player.id]['opponents'] = pointsPerPlayer;
                    console.log(`${player.name}: opponents set to ${pointsPerPlayer}`);
                } else {
                    // Has unplayed tiles - don't collect
                    scrabbleScores[player.id]['opponents'] = 0;
                    console.log(`${player.name}: opponents set to 0`);
                }
            });
            
            // Save the updated data
            saveScrabbleData();
        }
        function addScoreToCurrentScrabbleTurn(playerId, points) {
            const turnIndex = currentScrabbleTurn[playerId];
            if (turnIndex >= SCRABBLE_TURNS.length) {
                console.log('All turns completed for player', playerId);
                return false;
            }
            
            const turn = SCRABBLE_TURNS[turnIndex];
            scrabbleScores[playerId][turn] = points;
            
            // Move to next turn
            currentScrabbleTurn[playerId] = turnIndex + 1;
            
            saveScrabbleData();
            console.log(`Added ${points} for player ${playerId} in turn ${turn}`);
            renderScrabbleTableWithHighlight(playerId, turn);
            
            return true;
        }
        function renderScrabbleTableWithHighlight(playerId, turn) {
            renderScrabbleTable();
            
            setTimeout(() => {
                const cells = document.querySelectorAll('.crowns-score-highlight');
                cells.forEach(cell => {
                    cell.classList.remove('crowns-score-highlight');
                });
            }, 2000);
        }
        // ===== SCRABBLE WORD CHECKER AND TIMER =====
        
        // Scrabble timer variables
        let scrabbleTimerDuration = 120; // 2 minutes default
        let scrabbleTimerInterval = null;
        let scrabbleTimeRemaining = 0;
        let currentScrabblePlayer = null;
        let currentScrabblePlayerIndex = 0;
        
        // Basic word list for Scrabble validation (common words only)
        const scrabbleWordList = new Set([
            // Top 1000 most common Scrabble words (abbreviated list)
            'the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'who', 'boy', 'did', 'does', 'each', 'find', 'here', 'make', 'many', 'more', 'move', 'over', 'said', 'some', 'take', 'than', 'them', 'well', 'were', 'what', 'when', 'work', 'back', 'been', 'came', 'come', 'down', 'first', 'from', 'give', 'good', 'have', 'just', 'know', 'last', 'left', 'life', 'like', 'long', 'look', 'most', 'much', 'name', 'only', 'open', 'over', 'part', 'play', 'same', 'seem', 'show', 'side', 'tell', 'turn', 'used', 'want', 'ways', 'will', 'word', 'year', 'your', 'about', 'after', 'again', 'asked', 'being', 'could', 'every', 'going', 'great', 'large', 'never', 'other', 'place', 'right', 'small', 'sound', 'still', 'such', 'think', 'three', 'under', 'water', 'where', 'while', 'would', 'write',
            // Two-letter words (all valid)
            'aa', 'ab', 'ad', 'ae', 'ag', 'ah', 'ai', 'al', 'am', 'an', 'ar', 'as', 'at', 'aw', 'ax', 'ay', 'ba', 'be', 'bi', 'bo', 'by', 'da', 'de', 'do', 'ed', 'ef', 'eh', 'el', 'em', 'en', 'er', 'es', 'et', 'ex', 'fa', 'fe', 'gi', 'go', 'ha', 'he', 'hi', 'hm', 'ho', 'id', 'if', 'in', 'is', 'it', 'jo', 'ka', 'ki', 'la', 'li', 'lo', 'ma', 'me', 'mi', 'mm', 'mo', 'mu', 'my', 'na', 'ne', 'no', 'nu', 'od', 'oe', 'of', 'oh', 'oi', 'ok', 'om', 'on', 'op', 'or', 'os', 'ow', 'ox', 'oy', 'pa', 'pe', 'pi', 're', 'sh', 'si', 'so', 'ta', 'ti', 'to', 'uh', 'um', 'un', 'up', 'us', 'ut', 'we', 'wo', 'xi', 'xu', 'ya', 'ye', 'yo', 'za'
        ]);
        
        // Global audio context for beeps (reuse to prevent memory issues)
        let globalAudioContext = null;
        
        // Create beep sound for timer
        function playBeep() {
            try {
                // Reuse audio context to prevent memory leaks
                if (!globalAudioContext) {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Check if context is suspended (common on mobile)
                if (globalAudioContext.state === 'suspended') {
                    globalAudioContext.resume();
                }
                
                const oscillator = globalAudioContext.createOscillator();
                const gainNode = globalAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(globalAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, globalAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, globalAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + 0.5);
                
                oscillator.start(globalAudioContext.currentTime);
                oscillator.stop(globalAudioContext.currentTime + 0.5);
                
                // Clean up after beep
                oscillator.onended = () => {
                    oscillator.disconnect();
                    gainNode.disconnect();
                };
            } catch (error) {
                // Fail silently for audio issues
                console.log('Could not play beep sound:', error);
            }
        }
        
        // Comprehensive timer cleanup function
        function clearScrabbleTimer() {
            if (scrabbleTimerInterval) {
                console.log('Clearing Scrabble timer interval');
                clearInterval(scrabbleTimerInterval);
                scrabbleTimerInterval = null;
            }
            scrabbleTimeRemaining = 0;
            currentScrabblePlayer = null;
            currentScrabblePlayerIndex = 0;
        }
        
        // Start timer for next player in rotation
        function startScrabbleTimerForNextPlayer() {
            if (!players || players.length === 0) {
                speak('Add players first.');
                return;
            }
            
            // Stop any existing timer
            if (scrabbleTimerInterval) {
                clearInterval(scrabbleTimerInterval);
                scrabbleTimerInterval = null;
            }
            
            // Ensure player index is within bounds
            if (currentScrabblePlayerIndex >= players.length) {
                currentScrabblePlayerIndex = 0;
            }
            
            // Get next player
            const player = players[currentScrabblePlayerIndex];
            if (!player) {
                speak('Player not found.');
                return;
            }
            
            currentScrabblePlayer = player.name;
            scrabbleTimeRemaining = scrabbleTimerDuration;
            
            // Show timer display and hide dropdown
            const timerDisplay = document.getElementById('scrabbleTimerDisplay');
            const dropdown = document.getElementById('scrabbleTimerDropdown');
            
            if (timerDisplay) {
                timerDisplay.style.display = 'block';
            }
            
            if (dropdown) {
                dropdown.style.opacity = '0';
            }
            
            // Update Go button to Stop button
            const goBtn = document.getElementById('scrabbleGoBtn');
            if (goBtn) {
                goBtn.innerHTML = '';
                goBtn.style.background = 'linear-gradient(135deg, var(--neon-pink), #ff0066)';
                goBtn.style.color = 'white';
                goBtn.title = 'Stop Timer';
            }
            
            updateTimerDisplay();
            speak(`${currentScrabblePlayer}'s turn. Timer started.`);
            
            scrabbleTimerInterval = setInterval(() => {
                // Prevent negative timer values
                if (scrabbleTimeRemaining <= 0) {
                    scrabbleTimeRemaining = 0;
                    updateTimerDisplay();
                    
                    // Preserve player name before clearing it in stopScrabbleTimer
                    const endedPlayerName = currentScrabblePlayer;
                    
                    // Clear interval immediately to prevent re-entry
                    clearInterval(scrabbleTimerInterval);
                    scrabbleTimerInterval = null;
                    
                    stopScrabbleTimer();
                    playBeep();
                    speak(`Time's up for ${endedPlayerName}!`);
                    showVoiceFeedback(' Time\'s Up!', `${endedPlayerName}'s turn ended`);
                    setTimeout(hideVoiceFeedback, 3000);
                    return; // Exit immediately
                }
                
                scrabbleTimeRemaining--;
                updateTimerDisplay();
                
                if (scrabbleTimeRemaining <= 3 && scrabbleTimeRemaining > 0) {
                    // Only speak and beep in final 3 seconds to prevent speech chaos
                    playBeep();
                    
                    // Only speak if no other speech is happening to prevent overlap
                    if (!window.speechSynthesis.speaking) {
                        speak(scrabbleTimeRemaining.toString());
                    }
                }
            }, 1000);
        }
        
        // Toggle timer (Go/Stop button functionality)
        function toggleScrabbleTimer() {
            // Force close dropdown if open
            const dropdown = document.getElementById('scrabbleTimerDropdown');
            const dropdownList = document.getElementById('scrabbleTimerDropdownList');
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Prevent double-clicking and race conditions
            const goBtn = document.getElementById('scrabbleGoBtn');
            if (goBtn && goBtn.disabled) {
                return; // Already processing a click
            }
            
            // Temporarily disable button to prevent rapid clicking
            if (goBtn) {
                goBtn.disabled = true;
                setTimeout(() => {
                    goBtn.disabled = false;
                }, 500); // Re-enable after 500ms
            }
            
            if (scrabbleTimerInterval) {
                // Timer is running, stop it
                stopScrabbleTimer();
            } else {
                // Timer not running, start it
                startScrabbleTimerForNextPlayer();
            }
        }
        
        // Stop the timer
        function stopScrabbleTimer() {
            if (scrabbleTimerInterval) {
                clearInterval(scrabbleTimerInterval);
                scrabbleTimerInterval = null;
            }
            
            // Hide timer display and show dropdown
            const timerDisplay = document.getElementById('scrabbleTimerDisplay');
            const dropdown = document.getElementById('scrabbleTimerDropdown');
            
            if (timerDisplay) {
                timerDisplay.style.display = 'none';
            }
            
            if (dropdown) {
                dropdown.style.opacity = '1';
            }
            
            // Reset Go button
            const goBtn = document.getElementById('scrabbleGoBtn');
            if (goBtn) {
                goBtn.innerHTML = '';
                goBtn.style.background = 'linear-gradient(135deg, var(--neon-green), #2ed600)';
                goBtn.style.color = 'black';
                goBtn.title = '';
            }
            
            // Advance to next player for next time (only if we had a current player AND players exist)
            if (currentScrabblePlayer && players && players.length > 0) {
                currentScrabblePlayerIndex = (currentScrabblePlayerIndex + 1) % players.length;
                currentScrabblePlayer = null;
                speak('Timer stopped.');
            } else {
                // Reset to safe state if no players
                currentScrabblePlayer = null;
                currentScrabblePlayerIndex = 0;
            }
        }
        
        // Update timer display
        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('scrabbleTimerDisplay');
            if (!timerDisplay) {
                return;
            }
            
            const minutes = Math.floor(scrabbleTimeRemaining / 60);
            const seconds = scrabbleTimeRemaining % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Check if display needs to be created or updated
            let playerDiv = timerDisplay.querySelector('.timer-player');
            let timeDiv = timerDisplay.querySelector('.timer-time');
            
            if (!playerDiv || !timeDiv) {
                // Create structure once with horizontal layout
                timerDisplay.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                        <div class="timer-player" style="font-weight: bold; font-size: 0.85rem; color: black; flex: 1; text-align: left;">${currentScrabblePlayer || 'No Player'}</div>
                        <div class="timer-time" style="font-size: 1.2rem; color: black; flex: 0 0 auto;">${timeString}</div>
                    </div>
                `;
                playerDiv = timerDisplay.querySelector('.timer-player');
                timeDiv = timerDisplay.querySelector('.timer-time');
            }
            
            // Update only text content and color (more efficient than innerHTML)
            if (playerDiv && playerDiv.textContent !== (currentScrabblePlayer || 'No Player')) {
                playerDiv.textContent = currentScrabblePlayer || 'No Player';
            }
            
            if (timeDiv) {
                timeDiv.textContent = timeString;
                // Keep text black but change to red when time is low
                const newColor = scrabbleTimeRemaining <= 30 ? '#ff0000' : 'black';
                if (timeDiv.style.color !== newColor) {
                    timeDiv.style.color = newColor;
                }
            }
        }
        
        function saveScrabbleData() {
            localStorage.setItem('scorekeeper_scrabble_scores', JSON.stringify(scrabbleScores));
            localStorage.setItem('scorekeeper_scrabble_max_turn', scrabbleMaxTurn.toString());
        }
        function loadScrabbleData() {
            const savedScores = localStorage.getItem('scorekeeper_scrabble_scores');
            const savedMaxTurn = localStorage.getItem('scorekeeper_scrabble_max_turn');
            if (savedScores) {
                scrabbleScores = JSON.parse(savedScores);
            }
            if (savedMaxTurn) {
                scrabbleMaxTurn = parseInt(savedMaxTurn);
            }
        }
        // Enhanced word checking with online Scrabble dictionary
        async function checkScrabbleWord(word) {
            if (!word || typeof word !== 'string') return false;
            
            const cleanWord = word.toLowerCase().trim().replace(/[^a-z]/g, '');
            if (cleanWord.length === 0) return false;
            
            // First check local word list for immediate response
            const localResult = scrabbleWordList.has(cleanWord);
            
            try {
                // Check online using WordsAPI or similar free service
                console.log(`Checking word "${cleanWord}" against online Scrabble dictionary...`);
                
                // Using a free dictionary API that checks word validity
                // Note: API key should be moved to environment variables in production
                const API_KEY = 'a2a73e7b926c924fad7001ca3111acd55af2ffabf50eb4ae5'; // TODO: Move to server-side
                const response = await fetch(`https://api.wordnik.com/v4/word.json/${encodeURIComponent(cleanWord)}/definitions?limit=1&includeRelated=false&useCanonical=false&includeTags=false&api_key=${API_KEY}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Online dictionary response:', data);
                    
                    // Check if word exists (has definitions)
                    const onlineResult = Array.isArray(data) && data.length > 0;
                    
                    // If online result differs from local, log it for improvement
                    if (onlineResult !== localResult) {
                        console.log(`Dictionary mismatch for "${cleanWord}": local=${localResult}, online=${onlineResult}`);
                    }
                    
                    return onlineResult;
                } else {
                    console.log('Online dictionary unavailable, using local result');
                    return localResult;
                }
                
            } catch (error) {
                console.log('Error checking online dictionary, using local result:', error.message);
                // Fallback to local result if online check fails
                return localResult;
            }
        }
        
        // Voice command to check word validity
        async function handleScrabbleWordCheck(transcript) {
            // Check for word validation commands
            if (transcript.includes('check word') || transcript.includes('is') && transcript.includes('valid') || 
                transcript.includes('word check') || transcript.includes('valid word')) {
                
                // Extract the word from the transcript
                let word = transcript.replace(/check\s+word|is\s+.*valid|word\s+check|valid\s+word/gi, '').trim();
                
                if (word) {
                    // Show checking feedback
                    showVoiceFeedback(' Checking...', `Looking up "${word}"`);
                    
                    try {
                        const isValid = await checkScrabbleWord(word);
                        const message = isValid ? `${word} is a valid Scrabble word.` : `${word} is not a valid Scrabble word.`;
                        const icon = isValid ? '' : '';
                        const source = ''; // Dictionary icon
                        
                        speak(message);
                        showVoiceFeedback(`${icon} ${source} Word Check`, `${word}: ${isValid ? 'Valid' : 'Invalid'}`);
                        setTimeout(hideVoiceFeedback, 3000);
                        
                    } catch (error) {
                        console.error('Error checking word via voice:', error);
                        speak('Error checking word. Please try again.');
                        showVoiceFeedback(' Error', 'Could not check word');
                        setTimeout(hideVoiceFeedback, 3000);
                    }
                    
                    return true;
                }
            }
            
            // Timer commands
            if ((transcript.includes('start timer') || transcript.includes('go') || transcript.includes('begin timer')) && currentGameType === 'scrabble') {
                if (!scrabbleTimerInterval) {
                    toggleScrabbleTimer();
                }
                return true;
            }
            
            if ((transcript.includes('stop timer') || transcript.includes('pause timer')) && currentGameType === 'scrabble') {
                if (scrabbleTimerInterval) {
                    toggleScrabbleTimer();
                }
                return true;
            }
            
            return false;
        }
        
        // Check word from manual input
        async function checkWordFromInput() {
            const input = document.getElementById('scrabbleWordInput');
            if (!input) return;
            
            const word = input.value.trim();
            if (!word) {
                speak('Please enter a word to check.');
                return;
            }
            
            // Show checking feedback
            showVoiceFeedback(' Checking...', `Looking up "${word}"`);
            
            try {
                const isValid = await checkScrabbleWord(word);
                const message = isValid ? `${word} is a valid Scrabble word.` : `${word} is not a valid Scrabble word.`;
                const icon = isValid ? '' : '';
                const source = ''; // Dictionary icon
                
                speak(message);
                showVoiceFeedback(`${icon} ${source} Word Check`, `${word}: ${isValid ? 'Valid' : 'Invalid'}`);
                setTimeout(hideVoiceFeedback, 3000);
                
            } catch (error) {
                console.error('Error checking word:', error);
                speak('Error checking word. Please try again.');
                showVoiceFeedback(' Error', 'Could not check word');
                setTimeout(hideVoiceFeedback, 3000);
            }
            
            // Clear input
            input.value = '';
            
            // Update button color back to blue (empty state)
            updateScrabbleCheckButton();
        }
        
        // Function to update checkmark button appearance based on input
        window.updateScrabbleCheckButton = function updateScrabbleCheckButton() {
            const input = document.getElementById('scrabbleWordInput');
            const button = document.getElementById('scrabbleCheckButton');
            
            console.log('updateScrabbleCheckButton called');
            console.log('Input found:', !!input);
            console.log('Button found:', !!button);
            
            if (!input || !button) {
                console.log('Missing elements - input:', !!input, 'button:', !!button);
                return;
            }
            
            const hasText = input.value.trim().length > 0;
            console.log('Input value:', input.value, 'hasText:', hasText);
            
            if (hasText) {
                // Green when text is entered - use explicit colors
                button.style.background = '#2ed600'; // Explicit green
                button.style.borderColor = '#2ed600';
                button.style.color = 'black';
                button.style.boxShadow = '0 4px 10px rgba(57, 255, 20, 0.3)';
                console.log('Button set to GREEN');
            } else {
                // Match Speaker button styling exactly (stainless theme voice-btn)
                button.style.background = 'radial-gradient(circle at 30% 30%, #e2e8f0, #b0b8c0)';
                button.style.border = '1px solid rgba(255, 255, 255, 0.5)';
                button.style.color = '#2d3748';
                button.style.boxShadow = `
                    inset 0 1px 2px rgba(255, 255, 255, 0.8),
                    inset 0 -1px 2px rgba(0, 0, 0, 0.25),
                    0 2px 4px rgba(0, 0, 0, 0.3),
                    0 1px 0 rgba(255, 255, 255, 0.5)
                `;
                console.log('Button set to SPEAKER STYLE');
            }
        }
        
        
        // Toggle Scrabble timer duration dropdown
        // VERSION: 2026-02-08-FIX-v2 - Scrabble Timer Dropdown Fixed
        function toggleScrabbleTimerDropdown() {
            const dropdown = document.getElementById('scrabbleTimerDropdown');
            const dropdownList = document.getElementById('scrabbleTimerDropdownList');
            
            if (!dropdown || !dropdownList) {
                console.error(' Timer dropdown elements not found');
                return;
            }
            
            // Don't open dropdown if timer is running
            if (scrabbleTimerInterval) {
                return;
            }
            
            // Prevent rapid toggling - increased delay
            if (dropdown.dataset.processing === 'true') {
                return;
            }
            dropdown.dataset.processing = 'true';
            
            // Close ALL other dropdowns first (aggressive cleanup)
            try {
                document.querySelectorAll('.custom-dropdown').forEach(dd => {
                    dd.classList.remove('open');
                });
                document.querySelectorAll('.custom-dropdown-list').forEach(ddl => {
                    ddl.classList.remove('open');
                });
                
                // Small delay to ensure other dropdowns are closed
                setTimeout(() => {
                    // Toggle THIS dropdown
                    dropdown.classList.toggle('open');
                    dropdownList.classList.toggle('open');
                }, 50);
                
            } catch (error) {
                console.error('Error closing other dropdowns:', error);
            }
            
            // Reset processing flag with longer delay
            setTimeout(() => {
                dropdown.dataset.processing = 'false';
            }, 400);
        }
        
        // Select timer duration from dropdown
        function selectTimerDuration(duration, displayText) {
            const dropdown = document.getElementById('scrabbleTimerDropdown');
            const dropdownList = document.getElementById('scrabbleTimerDropdownList');
            const selectedDisplay = document.getElementById('selectedTimerDuration');
            
            if (!dropdown || !dropdownList || !selectedDisplay) {
                console.error('Timer duration elements not found');
                return;
            }
            
            // Validate duration is positive integer
            if (!duration || duration <= 0 || !Number.isInteger(duration)) {
                console.error('Invalid timer duration:', duration);
                return;
            }
            
            // Close dropdown
            dropdown.classList.remove('open');
            dropdownList.classList.remove('open');
            
            // Update display
            selectedDisplay.textContent = displayText;
            
            // Update duration
            scrabbleTimerDuration = duration;
            
            // If timer is currently running, update the time remaining but don't restart
            if (scrabbleTimerInterval && currentScrabblePlayer) {
                // Ensure we don't set negative time
                scrabbleTimeRemaining = Math.max(0, scrabbleTimerDuration);
                updateTimerDisplay();
            }
            
            speak(`Timer duration set to ${displayText}`);
        }
        
        // Reset timer state when entering Scrabble mode
        function resetScrabbleTimerState() {
            // Stop any running timer
            if (scrabbleTimerInterval) {
                clearInterval(scrabbleTimerInterval);
                scrabbleTimerInterval = null;
            }
            
            // Reset variables
            currentScrabblePlayer = null;
            currentScrabblePlayerIndex = 0;
            scrabbleTimeRemaining = 0;
            
            // Reset UI elements
            const timerDisplay = document.getElementById('scrabbleTimerDisplay');
            const dropdown = document.getElementById('scrabbleTimerDropdown');
            const goBtn = document.getElementById('scrabbleGoBtn');
            const selectedDisplay = document.getElementById('selectedTimerDuration');
            
            if (timerDisplay) {
                timerDisplay.style.display = 'none';
            }
            
            if (dropdown) {
                dropdown.style.opacity = '1';
                dropdown.classList.remove('open');
            }
            
            if (goBtn) {
                goBtn.innerHTML = '';
                goBtn.style.background = 'linear-gradient(135deg, var(--neon-green), #2ed600)';
                goBtn.style.color = 'black';
                goBtn.title = '';
            }
            
            if (selectedDisplay) {
                selectedDisplay.textContent = '2 minutes';
            }
        }
        
        function addScrabbleRow() {
            // Cancel any voice operations when manually adding a row
            cancelAllVoiceOperations();
            
            // Increment the maximum turn number
            scrabbleMaxTurn++;
            const newTurn = scrabbleMaxTurn.toString();
            
            // Add the new turn to the SCRABBLE_TURNS array
            SCRABBLE_TURNS.push(newTurn);
            
            // Initialize scores for the new turn for all players
            players.forEach(player => {
                if (scrabbleScores[player.id]) {
                    scrabbleScores[player.id][newTurn] = 0;
                }
            });
            
            console.log(`Added turn ${newTurn} to Scrabble grid`);
            
            // Re-render the table
            renderScrabbleTable();
            
            // Show feedback
            speak(`Turn ${newTurn} added`);
            showVoiceFeedback(`Turn ${newTurn} added to grid`, '');
            setTimeout(hideVoiceFeedback, 1500);
        }
        // ===== SCRABBLE FINAL SCORING ADJUSTMENTS =====
        
        let scrabbleFinalPlayerIndex = 0;
        let scrabbleLeftoverTiles = {};
        let scrabbleIsCollectingTiles = false;
        let scrabbleProcessingResponse = false; // Prevent duplicate processing
        let scrabbleSpeaking = false; // Track when computer is speaking to prevent interruption
        
        function scrabbleFinalAdjustments() {
            if (players.length === 0) {
                customAlert('No players to adjust scores for!', ' No Players');
                return;
            }
            // Reset collection state FIRST
            scrabbleFinalPlayerIndex = 0;
            scrabbleLeftoverTiles = {};
            scrabbleIsCollectingTiles = true;
            scrabbleProcessingResponse = false;
            
            // Make sure recognition is running BEFORE speaking (allows interruption)
            if (!isListening && recognition) {
                try {
                    intentionallyStopped = false; // Clear flag before starting
                    isListening = true;
                    recognition.start();
                    updateVoiceButtonState();
                    console.log('Recognition started for Scrabble final adjustments');
                } catch (e) {
                    if (e.name === 'InvalidStateError') {
                        console.log('Recognition already running');
                        isListening = true;
                    } else {
                        console.error('Could not start recognition:', e);
                    }
                }
            }
            
            // Speak the intro (protected from interruption until complete)
            speak('Time for final scoring adjustments. I will ask each player for their unplayed tiles. You can say skip to enter manually.', true);
            
            // Start collecting for first player
            setTimeout(() => {
                askForUnplayedTiles();
            }, 5000); // 5 seconds - longer wait to ensure intro speech completes
        }
        
        function askForUnplayedTiles() {
            if (scrabbleFinalPlayerIndex >= players.length) {
                // All players done, calculate final scores
                finishScrabbleFinalAdjustments();
                return;
            }
            
            const player = players[scrabbleFinalPlayerIndex];
            
            // Reset processing flag for this player
            scrabbleProcessingResponse = false;
            
            // Make sure recognition is running
            if (!isListening && recognition) {
                try {
                    intentionallyStopped = false; // Clear flag before starting
                    isListening = true; // Set BEFORE starting
                    recognition.start();
                    updateVoiceButtonState();
                } catch (e) {
                    if (e.name !== 'InvalidStateError') {
                        console.error('Could not start recognition:', e);
                        isListening = false;
                    } else {
                        isListening = true; // Already running, set to true
                    }
                }
            }
            
            // Only mention "skip" option for the first player
            if (scrabbleFinalPlayerIndex === 0) {
                speak(`How many unplayed tiles for ${player.name}? Say a number, say skip, or click Manual Entry.`, true);
                showVoiceFeedback(
                    `Waiting for ${player.name}'s unplayed tiles...`, 
                    `<button onclick="manualEntryForUnplayedTiles()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, var(--neon-blue), #00c4cc); color: black; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">Manual Entry</button>`
                );
            } else {
                speak(`How many unplayed tiles for ${player.name}?`, true);
                showVoiceFeedback(
                    `Waiting for ${player.name}'s unplayed tiles...`, 
                    `<button onclick="manualEntryForUnplayedTiles()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, var(--neon-blue), #00c4cc); color: black; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">Manual Entry</button>`
                );
            }
        }
        
        function processUnplayedTilesResponse(transcript) {
            // Prevent duplicate processing from interim results
            if (scrabbleProcessingResponse) {
                console.log(' Already processing response, ignoring duplicate:', transcript);
                return;
            }
            
            console.log(' Processing unplayed tiles response:', transcript);
            
            const player = players[scrabbleFinalPlayerIndex];
            
            // Check for skip/manual command
            if (transcript.includes('skip') || transcript.includes('manual') || transcript.includes('enter')) {
                scrabbleProcessingResponse = true; // Mark as processing
                
                speak(`Skipping ${player.name}. You can enter their tiles manually.`, true);
                showVoiceFeedback(`Skipped ${player.name}`, 'Enter manually in grid');
                
                // Set to 0 as placeholder (can be edited manually)
                scrabbleLeftoverTiles[player.id] = 0;
                
                // Immediately update the grid to show 0 unplayed tiles
                scrabbleScores[player.id]['unplayed'] = 0;
                renderScrabbleTable();
                
                // Move to next player
                scrabbleFinalPlayerIndex++;
                
                setTimeout(() => {
                    scrabbleProcessingResponse = false; // Reset flag before moving on
                    if (scrabbleFinalPlayerIndex < players.length) {
                        askForUnplayedTiles();
                    } else {
                        hideVoiceFeedback();
                        finishScrabbleFinalAdjustments();
                    }
                }, 5000); // 5 seconds to ensure speech completes
                return;
            }
            
            // Convert transcript to number with improved recognition
            let points = convertWordToNumber(transcript);
            
            // Additional number patterns for better recognition
            if (points === null) {
                // Try parsing digits directly
                const digitMatch = transcript.match(/\d+/);
                if (digitMatch) {
                    points = parseInt(digitMatch[0]);
                }
            }
            
            // Check for common misrecognitions
            if (points === null) {
                const numberWords = {
                    'won': 1, 'to': 2, 'too': 2, 'for': 4, 'ate': 8,
                    'ate': 8, 'none': 0, 'no': 0, 'oh': 0
                };
                if (numberWords.hasOwnProperty(transcript)) {
                    points = numberWords[transcript];
                }
            }
            
            if (points !== null && points >= 0) {
                scrabbleProcessingResponse = true; // Mark as processing
                
                scrabbleLeftoverTiles[player.id] = points;
                
                // Immediately update the grid to show unplayed tiles
                scrabbleScores[player.id]['unplayed'] = points;
                renderScrabbleTable();
                
                console.log(` ${player.name}: ${points} unplayed tiles`);
                
                if (points === 0) {
                    speak(`${player.name}, zero unplayed tiles.`, true);
                } else {
                    speak(`${player.name}, ${points} ${points === 1 ? 'point' : 'points'} in unplayed tiles.`, true);
                }
                
                showVoiceFeedback(`${player.name}: ${points} unplayed tiles`, transcript);
                
                // Move to next player
                scrabbleFinalPlayerIndex++;
                
                setTimeout(() => {
                    scrabbleProcessingResponse = false; // Reset flag before moving on
                    if (scrabbleFinalPlayerIndex < players.length) {
                        askForUnplayedTiles();
                    } else {
                        hideVoiceFeedback();
                        finishScrabbleFinalAdjustments();
                    }
                }, 5000); // 5 seconds to ensure speech completes before next question
            } else {
                console.log(` Could not recognize number from: "${transcript}"`);
                
                // Don't keep repeating - just show the error once
                if (!scrabbleProcessingResponse) {
                    scrabbleProcessingResponse = true; // Prevent repeating
                    
                    speak('I did not understand that number. Please say the number again, or click Manual Entry.');
                    
                    // Show feedback with properly rendered button
                    const feedbackDiv = document.getElementById('voiceFeedback');
                    const feedbackText = document.getElementById('feedbackText');
                    const feedbackSubtext = document.getElementById('feedbackSubtext');
                    
                    if (feedbackDiv && feedbackText && feedbackSubtext) {
                        feedbackText.textContent = 'Number not recognized';
                        feedbackSubtext.innerHTML = `"${transcript}"<br><button onclick="manualEntryForUnplayedTiles()" style="margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, var(--neon-blue), #00c4cc); color: black; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">Manual Entry</button>`;
                        feedbackDiv.classList.add('active');
                    }
                    
                    // Reset processing flag after a delay to allow retry
                    setTimeout(() => {
                        scrabbleProcessingResponse = false;
                    }, 2000);
                }
            }
        }
        
        async function manualEntryForUnplayedTiles() {
            const player = players[scrabbleFinalPlayerIndex];
            
            // Cancel all voice operations when using manual entry
            cancelAllVoiceOperations();
            
            // Prompt for manual entry
            const input = await customPrompt(`${player.name}: How many points in unplayed tiles?`, '0', ' Unplayed tiles');
            
            if (input === null) {
                // User cancelled - ask again with voice
                askForUnplayedTiles();
                return;
            }
            
            const points = parseInt(input) || 0;
            
            // Mark as processing to prevent voice interference
            scrabbleProcessingResponse = true;
            
            // Store the value
            scrabbleLeftoverTiles[player.id] = points;
            
            // Immediately update the grid to show unplayed tiles
            scrabbleScores[player.id]['unplayed'] = points;
            renderScrabbleTable();
            
            console.log(`${player.name}: ${points} unplayed tiles (manual entry)`);
            
            // Provide feedback
            speak(`${player.name}, ${points} ${points === 1 ? 'point' : 'points'} in unplayed tiles.`);
            showVoiceFeedback(`${player.name}: ${points} unplayed tiles`, 'Manual entry');
            
            // Move to next player
            scrabbleFinalPlayerIndex++;
            
            setTimeout(() => {
                if (scrabbleFinalPlayerIndex < players.length) {
                    askForUnplayedTiles();
                } else {
                    hideVoiceFeedback();
                    finishScrabbleFinalAdjustments();
                }
            }, 2000); // Shorter wait since manual entry is deliberate
        }
        
        async function finishScrabbleFinalAdjustments() {
            scrabbleIsCollectingTiles = false;
            scrabbleProcessingResponse = false; // Reset flag
            scrabbleSpeaking = false; // Ensure speech flag is cleared
            
            console.log('=== FINISHING SCRABBLE FINAL ADJUSTMENTS ===');
            console.log('Leftover tiles collected:', scrabbleLeftoverTiles);
            console.log('Players:', players.map(p => p.name));
            
            // Calculate totals
            let totalLeftover = 0;
            let playersWithNoTiles = [];
            
            players.forEach(player => {
                const leftover = scrabbleLeftoverTiles[player.id] || 0;
                console.log(`${player.name} (ID: ${player.id}): ${leftover} unplayed tiles`);
                if (leftover === 0) {
                    playersWithNoTiles.push(player);
                    console.log(`   ${player.name} has NO tiles (will receive points)`);
                } else {
                    totalLeftover += leftover;
                    console.log(`   ${player.name} has ${leftover} tiles (will lose points)`);
                }
            });
            
            console.log('Total leftover points:', totalLeftover);
            console.log('Players with no tiles:', playersWithNoTiles.map(p => p.name));
            
            // Calculate points to distribute to players with no leftover tiles
            let pointsPerPlayer = 0;
            if (playersWithNoTiles.length > 0) {
                pointsPerPlayer = Math.floor(totalLeftover / playersWithNoTiles.length);
                console.log(`Points per player with no tiles: ${totalLeftover}  ${playersWithNoTiles.length} = ${pointsPerPlayer}`);
            } else {
                console.log('No players with zero tiles - no points to distribute');
            }
            
            // Apply adjustments
            players.forEach(player => {
                const leftover = scrabbleLeftoverTiles[player.id] || 0;
                
                if (leftover > 0) {
                    // Deduct leftover tiles
                    scrabbleScores[player.id]['unplayed'] = leftover;
                    scrabbleScores[player.id]['opponents'] = 0;
                    console.log(`${player.name}: SET unplayed=${leftover}, opponents=0`);
                } else {
                    // No leftover - collect points from others
                    scrabbleScores[player.id]['unplayed'] = 0;
                    scrabbleScores[player.id]['opponents'] = pointsPerPlayer;
                    console.log(`${player.name}: SET unplayed=0, opponents=${pointsPerPlayer}`);
                }
            });
            
            console.log('Final scrabbleScores:', scrabbleScores);
            
            // Re-render the table
            renderScrabbleTable();
            
            // Calculate final scores with pre-adjustment scores for tiebreaker
            let finalScores = players.map(player => {
                let preAdjustmentTotal = 0;
                SCRABBLE_TURNS.forEach(turn => {
                    preAdjustmentTotal += scrabbleScores[player.id]?.[turn] || 0;
                });
                
                const unplayed = scrabbleScores[player.id]?.['unplayed'] || 0;
                const opponents = scrabbleScores[player.id]?.['opponents'] || 0;
                const finalTotal = preAdjustmentTotal - unplayed + opponents;
                
                console.log(`${player.name} final: ${preAdjustmentTotal} turns - ${unplayed} unplayed + ${opponents} opponents = ${finalTotal}`);
                
                return { 
                    player, 
                    total: finalTotal,
                    preAdjustmentTotal: preAdjustmentTotal  // Store for tiebreaker
                };
            });
            
            // Sort by final score, with tiebreaker using pre-adjustment score
            finalScores.sort((a, b) => {
                if (b.total !== a.total) {
                    return b.total - a.total;  // Primary: highest final score
                } else {
                    return b.preAdjustmentTotal - a.preAdjustmentTotal;  // Tiebreaker: highest pre-adjustment score
                }
            });
            
            // Check if winner was determined by tiebreaker
            const winner = finalScores[0];
            const topScore = winner.total;
            const playersWithTopScore = finalScores.filter(item => item.total === topScore);
            const wonByTiebreaker = playersWithTopScore.length > 1 && 
                                   playersWithTopScore[0].preAdjustmentTotal !== playersWithTopScore[1].preAdjustmentTotal;
            
            // Show results with universal completion system
            const formattedScores = finalScores.map(item => ({
                name: item.player.name,
                total: item.total,
                player: item.player
            }));
            
            const winnerData = {
                name: winner.player.name,
                player: winner.player,
                total: winner.total
            };
            
            await handleUniversalGameCompletion('scrabble', winnerData, formattedScores);
            
            // Create proper Supreme Champion announcement with all scores
            const winnerText = wonByTiebreaker 
                ? `${winner.player.name} is the Supreme Champion with ${winner.total} points on a tiebreaker!`
                : `${winner.player.name} is the Supreme Champion with ${winner.total} points!`;
            
            // Get other players' scores (excluding winner)
            const otherPlayers = finalScores.filter(score => score.player.id !== winner.player.id);
            let voiceAnnouncement = `Game over! Winner: ${winnerText}`;
            
            if (otherPlayers.length > 0) {
                const otherScores = otherPlayers.map(score => 
                    `${score.player.name}: ${score.total} ${score.total === 1 ? 'point' : 'points'}`
                ).join(', ');
                voiceAnnouncement += `. Other scores: ${otherScores}`;
            }
            
            speak(voiceAnnouncement, true);
            
            // Update walls with all player scores (higher is better in Scrabble)
            finalScores.forEach(item => {
                updateWalls('Scrabble', item.player.name, item.total, false);
            });
            
            console.log('Updated walls with Scrabble scores');
        }
        function hideVoiceFeedback() {
            setTimeout(() => {
                document.getElementById('voiceFeedback').classList.remove('show');
            }, 300);
        }
        // ===== YAHTZEE GRID FUNCTIONS =====
        
        function initializeYahtzeeScores() {
            // Only initialize if yahtzeeScores doesn't exist
            if (!yahtzeeScores) {
                yahtzeeScores = {};
            }
            if (!yahtzeeUsedCategories) {
                yahtzeeUsedCategories = {};
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!yahtzeeScores[player.id]) {
                    yahtzeeScores[player.id] = {
                        // Upper Section
                        ones: 0,
                        twos: 0,
                        threes: 0,
                        fours: 0,
                        fives: 0,
                        sixes: 0,
                        upperTotal: 0,
                        upperBonus: 0,
                        // Lower Section
                        threeKind: 0,
                        fourKind: 0,
                        fullHouse: 0,
                        smStraight: 0,
                        lgStraight: 0,
                        yahtzee: 0,
                        chance: 0,
                        yahtzeeBonus: 0 // For additional Yahtzees
                    };
                }
                // Initialize used categories tracker
                if (!yahtzeeUsedCategories[player.id]) {
                    yahtzeeUsedCategories[player.id] = {};
                }
            });
            
            console.log('Initialized Yahtzee scores:', yahtzeeScores);
        }
        function renderYahtzeeTable() {
            const buttonContainer = document.getElementById('yahtzeeButtons');
            
            console.log('=== RENDER YAHTZEE TABLE ===');
            console.log('Players:', players.length);
            console.log('yahtzeeScores:', JSON.stringify(yahtzeeScores, null, 2));
            
            if (players.length === 0) {
                document.getElementById('yahtzeeTable').innerHTML = '';
                // Hide buttons when no players
                if (buttonContainer) buttonContainer.style.display = 'none';
                return;
            }
            // Show buttons when players exist
            if (buttonContainer) buttonContainer.style.display = 'block';
            
            let html = '<thead><tr><th class="crowns-hole-label" style="min-width: 120px;">CATEGORY</th>';
            
            // Player headers
            players.forEach(player => {
                html += `<th class="crowns-player-header">
                    <div style="cursor: pointer;" onclick="editYahtzeePlayerName(${player.id})">${player.name}</div>
                </th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // UPPER SECTION
            html += '<tr class="section-divider"><td colspan="' + (players.length + 1) + '" style="background: var(--neon-blue); color: black; font-weight: 800; text-align: center; padding: 8px;">UPPER SECTION</td></tr>';
            
            const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
            const upperNames = ['Aces (1s)', 'Twos (2s)', 'Threes (3s)', 'Fours (4s)', 'Fives (5s)', 'Sixes (6s)'];
            
            upperCategories.forEach((cat, idx) => {
                html += `<tr><td class="crowns-hole-label">${upperNames[idx]}</td>`;
                players.forEach(player => {
                    const score = yahtzeeScores[player.id][cat] || 0;
                    const used = yahtzeeUsedCategories[player.id][cat];
                    const cellClass = used ? 'yahtzee-used' : 'yahtzee-available';
                    html += `<td class="${cellClass}" onclick="enterYahtzeeScore(${player.id}, '${cat}')" style="cursor: pointer;">${score > 0 ? score : (used ? '0' : '-')}</td>`;
                });
                html += '</tr>';
            });
            
            // Upper section total
            html += '<tr style="background: rgba(0, 245, 255, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">TOTAL</td>';
            players.forEach(player => {
                const total = (yahtzeeScores[player.id].ones || 0) + 
                             (yahtzeeScores[player.id].twos || 0) + 
                             (yahtzeeScores[player.id].threes || 0) + 
                             (yahtzeeScores[player.id].fours || 0) + 
                             (yahtzeeScores[player.id].fives || 0) + 
                             (yahtzeeScores[player.id].sixes || 0);
                html += `<td style="font-weight: 700;">${total}</td>`;
            });
            html += '</tr>';
            
            // Bonus (35 points if total >= 63)
            html += '<tr style="background: rgba(255, 215, 0, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">BONUS 35 (if 63)</td>';
            players.forEach(player => {
                const total = (yahtzeeScores[player.id].ones || 0) + 
                             (yahtzeeScores[player.id].twos || 0) + 
                             (yahtzeeScores[player.id].threes || 0) + 
                             (yahtzeeScores[player.id].fours || 0) + 
                             (yahtzeeScores[player.id].fives || 0) + 
                             (yahtzeeScores[player.id].sixes || 0);
                const bonus = total >= 63 ? 35 : 0;
                yahtzeeScores[player.id].upperBonus = bonus;
                html += `<td style="font-weight: 700; color: ${bonus > 0 ? '#28a745' : 'inherit'};">${bonus > 0 ? '+35' : '-'}</td>`;
            });
            html += '</tr>';
            
            // LOWER SECTION
            html += '<tr class="section-divider"><td colspan="' + (players.length + 1) + '" style="background: var(--neon-pink); color: black; font-weight: 800; text-align: center; padding: 8px;">LOWER SECTION</td></tr>';
            
            const lowerCategories = [
                { key: 'threeKind', name: '3 of a Kind', desc: 'Total of all dice' },
                { key: 'fourKind', name: '4 of a Kind', desc: 'Total of all dice' },
                { key: 'fullHouse', name: 'Full House', desc: '25 points' },
                { key: 'smStraight', name: 'Small Straight', desc: '30 points' },
                { key: 'lgStraight', name: 'Large Straight', desc: '40 points' },
                { key: 'yahtzee', name: 'YAHTZEE', desc: '50 points' },
                { key: 'chance', name: 'Chance', desc: 'Total of all dice' }
            ];
            
            lowerCategories.forEach(cat => {
                html += `<tr><td class="crowns-hole-label">${cat.name}<br><span style="font-size: 0.85rem; opacity: 0.7;">${cat.desc}</span></td>`;
                players.forEach(player => {
                    const score = yahtzeeScores[player.id][cat.key] || 0;
                    const used = yahtzeeUsedCategories[player.id][cat.key];
                    const cellClass = used ? 'yahtzee-used' : 'yahtzee-available';
                    html += `<td class="${cellClass}" onclick="enterYahtzeeScore(${player.id}, '${cat.key}')" style="cursor: pointer;">${score > 0 ? score : (used ? '0' : '-')}</td>`;
                });
                html += '</tr>';
            });
            
            // Yahtzee Bonus
            html += '<tr style="background: rgba(255, 215, 0, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">Yahtzee Bonus<br><span style="font-size: 0.85rem; opacity: 0.7;">100 per extra</span></td>';
            players.forEach(player => {
                const bonus = yahtzeeScores[player.id].yahtzeeBonus || 0;
                html += `<td style="font-weight: 700; color: ${bonus > 0 ? '#28a745' : 'inherit'};">${bonus > 0 ? bonus : '-'}</td>`;
            });
            html += '</tr>';
            
            // Lower section total
            html += '<tr style="background: rgba(0, 245, 255, 0.1);"><td class="crowns-hole-label" style="font-weight: 700;">LOWER TOTAL</td>';
            players.forEach(player => {
                const total = (yahtzeeScores[player.id].threeKind || 0) + 
                             (yahtzeeScores[player.id].fourKind || 0) + 
                             (yahtzeeScores[player.id].fullHouse || 0) + 
                             (yahtzeeScores[player.id].smStraight || 0) + 
                             (yahtzeeScores[player.id].lgStraight || 0) + 
                             (yahtzeeScores[player.id].yahtzee || 0) + 
                             (yahtzeeScores[player.id].chance || 0) + 
                             (yahtzeeScores[player.id].yahtzeeBonus || 0);
                html += `<td style="font-weight: 700;">${total}</td>`;
            });
            html += '</tr>';
            
            // GRAND TOTAL
            html += '<tr style="background: rgba(255, 0, 110, 0.2);"><td class="crowns-hole-label" style="font-weight: 800; font-size: 1.2rem;">GRAND TOTAL</td>';
            players.forEach(player => {
                const upperTotal = (yahtzeeScores[player.id].ones || 0) + 
                                  (yahtzeeScores[player.id].twos || 0) + 
                                  (yahtzeeScores[player.id].threes || 0) + 
                                  (yahtzeeScores[player.id].fours || 0) + 
                                  (yahtzeeScores[player.id].fives || 0) + 
                                  (yahtzeeScores[player.id].sixes || 0) +
                                  (yahtzeeScores[player.id].upperBonus || 0);
                const lowerTotal = (yahtzeeScores[player.id].threeKind || 0) + 
                                  (yahtzeeScores[player.id].fourKind || 0) + 
                                  (yahtzeeScores[player.id].fullHouse || 0) + 
                                  (yahtzeeScores[player.id].smStraight || 0) + 
                                  (yahtzeeScores[player.id].lgStraight || 0) + 
                                  (yahtzeeScores[player.id].yahtzee || 0) + 
                                  (yahtzeeScores[player.id].chance || 0) + 
                                  (yahtzeeScores[player.id].yahtzeeBonus || 0);
                const grandTotal = upperTotal + lowerTotal;
                player.score = grandTotal; // Update player's main score
                html += `<td style="font-weight: 800; font-size: 1.2rem; color: var(--neon-blue);">${grandTotal}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('yahtzeeTable').innerHTML = html;
            savePlayers(); // Save updated totals
        }
        async function enterYahtzeeScore(playerId, category) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            // Allow overwriting scores - remove the used category check
            // if (yahtzeeUsedCategories[playerId][category]) {
            //     customAlert(`${category} has already been used for ${player.name}!`, ' Category Used');
            //     return;
            // }
            
            const cell = event.target;
            const currentScore = yahtzeeScores[playerId][category] || 0;
            const categoryInfo = YAHTZEE_CATEGORIES[category];
            
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="yahtzee-input-${playerId}-${category}" inputmode="numeric">`;
            
            const input = document.getElementById(`yahtzee-input-${playerId}-${category}`);
            input.focus();
            input.select();
            
            const saveScore = () => {
                const score = parseInt(input.value);
                
                if (isNaN(score) || score < 0) {
                    customAlert('Please enter a valid score (0 or greater)', ' Invalid Score');
                    renderYahtzeeTable();
                    return;
                }
                
                // Save state for undo
                saveStateForUndo(`${player.name} - ${categoryInfo.name}: ${score}`);
                
                // Set the score
                yahtzeeScores[playerId][category] = score;
                yahtzeeUsedCategories[playerId][category] = true;
                
                // Check for Yahtzee bonus (if scoring additional yahtzees)
                if (category === 'yahtzee' && score === 50 && yahtzeeUsedCategories[playerId].yahtzee && yahtzeeScores[playerId].yahtzee > 0) {
                    yahtzeeScores[playerId].yahtzeeBonus = (yahtzeeScores[playerId].yahtzeeBonus || 0) + 100;
                    speak(`Yahtzee bonus! ${player.name} gets 100 extra points!`);
                }
                
                saveYahtzeeData();
                renderYahtzeeTable();
                
                // No voice feedback for manual input
            };
            
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editYahtzeePlayerName(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const currentName = player.name;
            const cell = event.target;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete yahtzeeScores[playerId];
                        delete yahtzeeUsedCategories[playerId];
                        savePlayers();
                    }
                    renderYahtzeeTable();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderYahtzeeTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function saveYahtzeeData() {
            localStorage.setItem('scorekeeper_yahtzee_scores', JSON.stringify(yahtzeeScores));
            localStorage.setItem('scorekeeper_yahtzee_used', JSON.stringify(yahtzeeUsedCategories));
        }
        function loadYahtzeeData() {
            const savedScores = localStorage.getItem('scorekeeper_yahtzee_scores');
            const savedUsed = localStorage.getItem('scorekeeper_yahtzee_used');
            
            if (savedScores) {
                yahtzeeScores = JSON.parse(savedScores);
            }
            if (savedUsed) {
                yahtzeeUsedCategories = JSON.parse(savedUsed);
            }
        }
        // ===== PHASE 10 GRID FUNCTIONS =====
        
        function initializePhase10Scores() {
            if (!phase10Scores) {
                phase10Scores = {};
            }
            if (!phase10Completed) {
                phase10Completed = {};
            }
            
            players.forEach(player => {
                if (!phase10Scores[player.id]) {
                    phase10Scores[player.id] = {};
                    PHASE10_PHASES.forEach(phase => {
                        phase10Scores[player.id][phase.num] = 0;
                    });
                }
                if (!phase10Completed[player.id]) {
                    phase10Completed[player.id] = {};
                }
            });
            
            console.log('Initialized Phase 10 scores:', phase10Scores);
        }
        function renderPhase10Table() {
            const buttonContainer = document.getElementById('phase10Buttons');
            
            console.log('=== RENDER PHASE 10 TABLE ===');
            console.log('Players:', players.length);
            
            if (players.length === 0) {
                document.getElementById('phase10Table').innerHTML = '';
                // Hide buttons when no players
                if (buttonContainer) buttonContainer.style.display = 'none';
                return;
            }
            // Show buttons when players exist
            if (buttonContainer) buttonContainer.style.display = 'block';
            
            let html = '<thead><tr><th class="crowns-hole-label" style="min-width: 140px;">PHASE</th>';
            
            players.forEach(player => {
                html += `<th class="crowns-player-header">
                    <div style="cursor: pointer;" onclick="editPhase10PlayerName(${player.id})">${player.name}</div>
                </th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            PHASE10_PHASES.forEach(phase => {
                html += `<tr>`;
                html += `<td class="crowns-hole-label"><strong>Phase ${phase.num}</strong><br><span style="font-size: 0.85rem; opacity: 0.7;">${phase.name}</span></td>`;
                
                players.forEach(player => {
                    const score = phase10Scores[player.id][phase.num] || 0;
                    const completed = phase10Completed[player.id][phase.num];
                    const cellStyle = completed ? 'background: rgba(0, 245, 255, 0.2); font-weight: 700;' : '';
                    const displayScore = completed ? ` ${score}` : score;
                    html += `<td style="cursor: pointer; ${cellStyle}" onclick="enterPhase10Score(${player.id}, ${phase.num})">${displayScore > 0 || completed ? displayScore : '-'}</td>`;
                });
                
                html += '</tr>';
            });
            
            // Total row
            html += '<tr style="border-top: 2px solid var(--neon-blue); background: rgba(255, 0, 110, 0.2);"><td class="crowns-hole-label" style="font-weight: 800; font-size: 1.2rem;">TOTAL</td>';
            players.forEach(player => {
                let total = 0;
                PHASE10_PHASES.forEach(phase => {
                    total += phase10Scores[player.id][phase.num] || 0;
                });
                player.score = total;
                html += `<td style="font-weight: 800; font-size: 1.2rem; color: var(--neon-pink);">${total}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('phase10Table').innerHTML = html;
            savePlayers();
        }
        async function enterPhase10Score(playerId, phaseNum) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const cell = event.target;
            const currentScore = phase10Scores[playerId][phaseNum] || 0;
            const isCompleted = phase10Completed[playerId][phaseNum];
            
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="phase10-input-${playerId}-${phaseNum}" inputmode="numeric">`;
            
            const input = document.getElementById(`phase10-input-${playerId}-${phaseNum}`);
            input.focus();
            input.select();
            
            const saveScore = () => {
                const score = parseInt(input.value);
                
                if (isNaN(score) || score < 0) {
                    customAlert('Please enter a valid score (0 or greater)', ' Invalid Score');
                    renderPhase10Table();
                    return;
                }
                
                saveStateForUndo(`${player.name} - Phase ${phaseNum}: ${score}`);
                
                phase10Scores[playerId][phaseNum] = score;
                // Mark as completed if score is 0 (phase was completed)
                if (score === 0) {
                    phase10Completed[playerId][phaseNum] = true;
                }
                
                savePhase10Data();
                renderPhase10Table();
                
                // No voice feedback for manual input
            };
            
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editPhase10PlayerName(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const currentName = player.name;
            const cell = event.target;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete phase10Scores[playerId];
                        delete phase10Completed[playerId];
                        savePlayers();
                    }
                    renderPhase10Table();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderPhase10Table();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function savePhase10Data() {
            localStorage.setItem('scorekeeper_phase10_scores', JSON.stringify(phase10Scores));
            localStorage.setItem('scorekeeper_phase10_completed', JSON.stringify(phase10Completed));
        }
        function loadPhase10Data() {
            const savedScores = localStorage.getItem('scorekeeper_phase10_scores');
            const savedCompleted = localStorage.getItem('scorekeeper_phase10_completed');
            
            if (savedScores) {
                phase10Scores = JSON.parse(savedScores);
            }
            if (savedCompleted) {
                phase10Completed = JSON.parse(savedCompleted);
            }
        }
        // ===== GENERIC GRID FUNCTIONS (for General/Darts/Farkle) =====
        
        function initializeGenericGridScores() {
            // Only initialize if genericGridScores doesn't exist
            if (!genericGridScores) {
                genericGridScores = {};
            }
            if (!currentGenericTurn) {
                currentGenericTurn = {};
            }
            
            // Only reset turns if we're starting fresh (no existing scores)
            if (Object.keys(genericGridScores).length === 0) {
                GENERIC_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
                genericMaxTurn = 12;
            }
            
            players.forEach(player => {
                // Only initialize new players, preserve existing data
                if (!genericGridScores[player.id]) {
                    genericGridScores[player.id] = {};
                    GENERIC_TURNS.forEach(turn => {
                        genericGridScores[player.id][turn] = 0;
                    });
                }
                // Initialize current turn tracker for new players
                if (currentGenericTurn[player.id] === undefined) {
                    currentGenericTurn[player.id] = 0; // Start at turn 1 (index 0)
                }
            });
            
            console.log('Initialized Generic Grid scores:', genericGridScores);
        }
        function renderGenericGridTable() {
            const buttonContainer = document.getElementById('genericGridButtons');
            const gameButtonContainer = document.getElementById('genericGridGameButtons');
            
            console.log('=== RENDER GENERIC GRID TABLE ===');
            console.log('Players:', players.length);
            console.log('genericGridScores:', JSON.stringify(genericGridScores, null, 2));
            
            if (players.length === 0) {
                document.getElementById('genericGridTable').innerHTML = '';
                // Hide buttons when no players
                if (buttonContainer) buttonContainer.style.display = 'none';
                if (gameButtonContainer) gameButtonContainer.style.display = 'none';
                return;
            }
            // Show buttons when players exist
            if (buttonContainer) buttonContainer.style.display = 'flex';
            if (gameButtonContainer) gameButtonContainer.style.display = 'block';
            
            let html = '<thead><tr><th class="crowns-hole-label">TURN</th>';
            
            // Player headers - clickable to edit names
            players.forEach(player => {
                html += `<th class="crowns-player-header">
                    <div style="cursor: pointer;" onclick="editGenericGridPlayerName(${player.id})">${player.name}</div>
                </th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // Turn rows
            GENERIC_TURNS.forEach((turn, index) => {
                const isHighlighted = highlightedGenericTurn === turn ? ' highlighted' : '';
                html += `<tr>`;
                html += `<td class="crowns-hole-label${isHighlighted}" onclick="toggleGenericTurnHighlight('${turn}')" style="cursor: pointer;">${turn}</td>`;
                
                players.forEach(player => {
                    const score = genericGridScores[player.id][turn] || 0;
                    const isCurrentTurn = currentGenericTurn[player.id] === index;
                    const cellClass = isCurrentTurn ? 'current-turn-cell' : '';
                    html += `<td class="${cellClass}" onclick="editGenericGridScore(${player.id}, '${turn}')" style="cursor: pointer;">${score}</td>`;
                });
                
                html += '</tr>';
            });
            
            // Total row
            html += '<tr style="border-top: 2px solid var(--neon-blue); background: rgba(0, 245, 255, 0.1);"><td class="crowns-hole-label" style="font-weight: 800;">TOTAL</td>';
            players.forEach(player => {
                let total = 0;
                GENERIC_TURNS.forEach(turn => {
                    total += genericGridScores[player.id][turn] || 0;
                });
                player.score = total; // Update player's main score
                html += `<td style="font-weight: 800;">${total}</td>`;
            });
            html += '</tr>';
            
            html += '</tbody>';
            
            document.getElementById('genericGridTable').innerHTML = html;
            savePlayers(); // Save updated totals
        }
        
        function toggleGenericTurnHighlight(turn) {
            console.log('=== toggleGenericTurnHighlight called ===');
            console.log('Turn clicked:', turn);
            console.log('Current highlightedGenericTurn:', highlightedGenericTurn);
            
            // Toggle the highlight - if already highlighted, unhighlight it
            if (highlightedGenericTurn === turn) {
                highlightedGenericTurn = null;
                console.log('Unhighlighting - set to null');
            } else {
                highlightedGenericTurn = turn;
                console.log('Highlighting - set to:', turn);
            }
            
            console.log('About to re-render Generic Grid table');
            renderGenericGridTable();
            console.log('Generic Grid table re-rendered');
        }
        
        function addGenericRow() {
            // Add a new turn
            genericMaxTurn++;
            GENERIC_TURNS.push(genericMaxTurn.toString());
            
            // Initialize the new turn for all players
            players.forEach(player => {
                if (genericGridScores[player.id]) {
                    genericGridScores[player.id][genericMaxTurn.toString()] = 0;
                }
            });
            
            saveGenericGridData();
            renderGenericGridTable();
            
            speak(`Added turn ${genericMaxTurn}`);
            showVoiceFeedback(`Turn ${genericMaxTurn} added`, '');
            setTimeout(hideVoiceFeedback, 1500);
        }
        async function editGenericGridScore(playerId, turn) {
            // Cancel any voice operations when manually editing
            cancelAllVoiceOperations();
            
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const cell = event.target;
            const currentScore = genericGridScores[playerId][turn] || 0;
            
            cell.innerHTML = `<input type="number" class="crowns-score-input" value="${currentScore}" id="generic-input-${playerId}-${turn}" inputmode="numeric">`;
            
            const input = document.getElementById(`generic-input-${playerId}-${turn}`);
            input.focus();
            input.select();
            
            const saveScore = () => {
                const score = parseInt(input.value);
                
                if (isNaN(score)) {
                    customAlert('Please enter a valid number', ' Invalid Score');
                    renderGenericGridTable();
                    return;
                }
                
                // Save state for undo
                saveStateForUndo(`${player.name} - Turn ${turn}: ${score}`);
                
                genericGridScores[playerId][turn] = score;
                
                saveGenericGridData();
                renderGenericGridTable();
                
                // No voice feedback for manual input
            };
            
            input.addEventListener('blur', saveScore);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        function editGenericGridPlayerName(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            const currentName = player.name;
            const cell = event.target;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.cssText = 'width: 100%; background: rgba(0,0,0,0.5); color: inherit; border: 2px solid var(--neon-blue); padding: 4px; font-size: inherit; font-family: inherit;';
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            const saveEdit = async () => {
                const newName = input.value.trim();
                
                if (newName === '') {
                    const shouldDelete = await customConfirm(`Delete ${player.name} and remove their column?`, ' Delete Player');
                    if (shouldDelete) {
                        players = players.filter(p => p.id !== playerId);
                        delete genericGridScores[playerId];
                        delete currentGenericTurn[playerId];
                        savePlayers();
                    }
                    renderGenericGridTable();
                    return;
                }
                
                if (newName !== currentName) {
                    player.name = newName;
                    savePlayers();
                }
                renderGenericGridTable();
            };
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
            });
        }
        function addScoreToCurrentGenericTurn(playerId, points) {
            const player = players.find(p => p.id === playerId);
            if (!player) return false;
            // Get current turn index for this player
            let turnIndex = currentGenericTurn[playerId] || 0;
            
            // If we're past the last turn, don't add
            if (turnIndex >= GENERIC_TURNS.length) {
                speak('All turns complete for ' + player.name);
                showVoiceFeedback(`All turns complete for ${player.name}`, '');
                setTimeout(hideVoiceFeedback, 2000);
                return false;
            }
            const turn = GENERIC_TURNS[turnIndex];
            
            // Add score to current turn
            genericGridScores[playerId][turn] = points;
            saveGenericGridData();
            
            // Move to next turn
            currentGenericTurn[playerId] = turnIndex + 1;
            localStorage.setItem('scorekeeper_current_generic_turn', JSON.stringify(currentGenericTurn));
            
            // Provide feedback
            speak(`${points} points for ${player.name} in turn ${turn}`);
            showVoiceFeedback(`${player.name}: ${points} pts (Turn ${turn})`, '');
            setTimeout(hideVoiceFeedback, 1500);
            
            // Re-render table with highlight
            renderGenericGridTableWithHighlight(playerId, turn);
            return true;
        }
        function renderGenericGridTableWithHighlight(playerId, turn) {
            renderGenericGridTable();
            
            // Highlight the updated cell
            setTimeout(() => {
                const table = document.getElementById('genericGridTable');
                const headers = table.querySelectorAll('th.crowns-player-header');
                
                let playerColumnIndex = -1;
                headers.forEach((header, index) => {
                    const player = players[index];
                    if (player && player.id === playerId) {
                        playerColumnIndex = index + 1; // +1 because first column is turn labels
                    }
                });
                
                if (playerColumnIndex !== -1) {
                    const turnIndex = GENERIC_TURNS.indexOf(turn);
                    if (turnIndex !== -1) {
                        const rows = table.querySelectorAll('tbody tr');
                        const targetRow = rows[turnIndex];
                        if (targetRow) {
                            const cells = targetRow.querySelectorAll('td');
                            const targetCell = cells[playerColumnIndex];
                            if (targetCell) {
                                targetCell.style.animation = 'highlightCell 1s ease';
                                setTimeout(() => {
                                    targetCell.style.animation = '';
                                }, 1000);
                            }
                        }
                    }
                }
            }, 50);
        }
        function saveGenericGridData() {
            localStorage.setItem('scorekeeper_generic_grid_scores', JSON.stringify(genericGridScores));
            localStorage.setItem('scorekeeper_current_generic_turn', JSON.stringify(currentGenericTurn));
            localStorage.setItem('scorekeeper_generic_turns', JSON.stringify(GENERIC_TURNS));
            localStorage.setItem('scorekeeper_generic_max_turn', genericMaxTurn.toString());
        }
        function loadGenericGridData() {
            const savedScores = localStorage.getItem('scorekeeper_generic_grid_scores');
            const savedTurn = localStorage.getItem('scorekeeper_current_generic_turn');
            const savedTurns = localStorage.getItem('scorekeeper_generic_turns');
            const savedMaxTurn = localStorage.getItem('scorekeeper_generic_max_turn');
            
            if (savedScores) {
                genericGridScores = JSON.parse(savedScores);
            }
            if (savedTurn) {
                currentGenericTurn = JSON.parse(savedTurn);
            }
            if (savedTurns) {
                GENERIC_TURNS = JSON.parse(savedTurns);
            }
            if (savedMaxTurn) {
                genericMaxTurn = parseInt(savedMaxTurn);
            }
        }
        // ===== TEXT PREPROCESSING FOR VOICE RECOGNITION =====
        function preprocessTranscript(transcript) {
            let processed = transcript.toLowerCase().trim();
            
            console.log('Original transcript:', transcript);
            
            // Fix common misrecognitions
            // "Had" at the start is almost always "Add"
            if (processed.startsWith('had ')) {
                processed = 'add ' + processed.substring(4);
                console.log('Corrected "had" to "add"');
            }
            
            // "At" at the start is almost always "Add"
            if (processed.startsWith('at ')) {
                processed = 'add ' + processed.substring(3);
                console.log('Corrected "at" to "add"');
            }
            
            // Fix "twenty four" when it should be "twenty for"
            // "20 for Steven" often misheard as "24 Steven" or "twenty four Steven"
            // Pattern: [number ending in 0-9] + "four" + [name]  [number] + "for" + [name]
            processed = processed.replace(/\b(ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred)\s+four\s+/gi, '$1 for ');
            processed = processed.replace(/\b(\d+)\s*four\s+/gi, '$1 for ');
            processed = processed.replace(/\b(10|11|12|13|14|15|16|17|18|19|20|30|40|50|60|70|80|90|100)\s*4\s+/gi, '$1 for ');
            console.log('After "four"  "for" correction:', processed);
            
            // Replace "had" with "add" throughout
            processed = processed.replace(/\bhad\b/gi, 'add');
            
            // Replace "at" with "add" when followed by a name (for adding players)
            // "at Guy"  "add Guy"
            // "at Emma and Jonathan"  "add Emma and Jonathan"
            processed = processed.replace(/\bat\s+([A-Z])/gi, 'add $1');
            
            // Improve "done" detection - common misrecognitions
            processed = processed.replace(/\bdon\b/gi, 'done');
            processed = processed.replace(/\bdun\b/gi, 'done');
            processed = processed.replace(/\bdum\b/gi, 'done');
            processed = processed.replace(/\bdone\b/gi, 'done');
            
            // FIX NUMBER MISINTERPRETATIONS AT END OF SCORING COMMANDS
            // These only apply when they appear at the end after a name
            // "give Ellen too"  "give Ellen 2"
            // "Jonathan for"  "Jonathan 4"
            // "Emma to"  "Emma 2"
            // "Guy fore"  "Guy 4"
            
            // Pattern: [name] + [misheard number word at end]
            // Match "too", "to", "two" at end  2
            processed = processed.replace(/\b(too|to|two)$/i, '2');
            
            // Match "for", "fore", "four" at end  4
            processed = processed.replace(/\b(for|fore|four)$/i, '4');
            
            // Also handle in "give [name] [number]" pattern
            processed = processed.replace(/\bgive\s+(\w+)\s+(too|to|two)$/i, 'give $1 2');
            processed = processed.replace(/\bgive\s+(\w+)\s+(for|fore|four)$/i, 'give $1 4');
            
            // Handle in "[number] for [name]" - but preserve legitimate "for"
            // Only if "for" is at position where number should be
            // "to for Emma"  "2 for Emma" (to  2, keep "for")
            processed = processed.replace(/^(too|to|two)\s+for\s+/i, '2 for ');
            
            // More comprehensive number word corrections at end of commands
            processed = processed.replace(/\b(won|one)$/i, '1');
            processed = processed.replace(/\b(tree|free|three)$/i, '3');
            processed = processed.replace(/\b(fife|five)$/i, '5');
            processed = processed.replace(/\b(sex|six)$/i, '6');
            processed = processed.replace(/\b(ate|eight)$/i, '8');
            processed = processed.replace(/\b(mine|nine)$/i, '9');
            
            console.log('After number corrections:', processed);
            
            // FIX GUY NAME RECOGNITION - catch all variations
            // "give me 7"  "give guy 7"
            // "give d7"  "give guy 7"
            // "give g7"  "give guy 7"
            // Common patterns where Guy is misheard
            processed = processed.replace(/\bgive\s+me\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+d\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+g\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+ghee\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+gee\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+key\b/gi, 'give guy');
            processed = processed.replace(/\bgive\s+ge\b/gi, 'give guy');
            
            // Handle patterns like "d7", "g7", "d 7", "g 7"
            processed = processed.replace(/\b([dg])\s*(\d+)\b/gi, 'guy $2');
            
            // Handle standalone variations at word boundaries
            processed = processed.replace(/\bghee\b/gi, 'guy');
            processed = processed.replace(/\bgee\b/gi, 'guy');
            processed = processed.replace(/\bkey\b/gi, 'guy');
            processed = processed.replace(/\bge\b/gi, 'guy');
            
            // Handle "for" patterns: "5 for me"  "5 for guy"
            processed = processed.replace(/\bfor\s+me\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+d\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+g\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+ghee\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+gee\b/gi, 'for guy');
            processed = processed.replace(/\bfor\s+key\b/gi, 'for guy');
            
            // Handle "change/update" patterns
            processed = processed.replace(/\b(change|update)\s+me\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+d\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+g\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+ghee\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+gee\b/gi, '$1 guy');
            processed = processed.replace(/\b(change|update)\s+key\b/gi, '$1 guy');
            
            // Handle at start of command: "me 5"  "guy 5", "d 5"  "guy 5"
            if (processed.match(/^(me|d|g|ghee|gee|key|ge)\s+\d+/i)) {
                processed = processed.replace(/^(me|d|g|ghee|gee|key|ge)\s+/i, 'guy ');
                console.log('Corrected name at start to "guy"');
            }
            
            // Sometimes "done" is heard at the end with extra words
            if (processed.includes('done')) {
                console.log('DONE word detected in transcript');
            }
            
            console.log('Preprocessed transcript:', processed);
            return processed;
        }
        function parseMultipleScores(transcript) {
            // Parse multiple score entries from a single transcript
            // Supports formats like:
            // "Guy 20 Jonathan 5 Jeff 75"
            // "Give Guy 20 Give Jonathan 5 Jeff 75"
            // "20 for Guy 5 for Jonathan 75 for Jeff"
            // "Guy gets 20 Jonathan gets 5"
            
            const scores = [];
            
            // Clean up the transcript - remove filler words
            let cleaned = transcript.toLowerCase();
            cleaned = cleaned.replace(/\b(give|gets?|scored?|points?|for)\b/g, ' ');
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            
            // Pattern 1: "name number name number" - most common
            // Look for patterns: word(s) followed by number
            const pattern1 = /([a-z]+(?:\s+[a-z]+)?)\s+(\d+)/gi;
            let matches = [...cleaned.matchAll(pattern1)];
            
            if (matches.length > 0) {
                matches.forEach(match => {
                    const name = match[1].trim();
                    const points = parseInt(match[2]);
                    
                    // Validate it's not a weird match
                    if (name.length > 0 && name.length < 30 && points >= 0 && points <= 9999) {
                        scores.push({ name, points });
                    }
                });
            }
            
            // If we found multiple scores, return them
            if (scores.length > 1) {
                console.log('Parsed multiple scores:', scores);
                return scores;
            }
            
            // Alternative pattern: "number name number name"
            const pattern2 = /(\d+)\s+([a-z]+(?:\s+[a-z]+)?)/gi;
            matches = [...cleaned.matchAll(pattern2)];
            
            if (matches.length > 1) {
                scores.length = 0; // Clear previous attempts
                matches.forEach(match => {
                    const points = parseInt(match[1]);
                    const name = match[2].trim();
                    
                    if (name.length > 0 && name.length < 30 && points >= 0 && points <= 9999) {
                        scores.push({ name, points });
                    }
                });
            }
            
            return scores.length > 1 ? scores : null;
        }
        async function processVoiceCommand(originalTranscript) {
            // First, check if we're waiting for a voice confirmation
            if (pendingVoiceConfirmation) {
                if (handleVoiceConfirmation(originalTranscript)) {
                    return; // Confirmation was handled
                }
            }
            
            // Preprocess to fix common misrecognitions
            const transcript = preprocessTranscript(originalTranscript);
            
            // Check for multi-score input (e.g., "Guy 20 Jonathan 5 Jeff 75")
            // This needs to be checked early before single-score processing
            if (gameInProgress && players.length > 0) {
                const multiScores = parseMultipleScores(transcript);
                if (multiScores && multiScores.length > 1) {
                    console.log('Detected multiple scores:', multiScores);
                    
                    let successCount = 0;
                    let feedbackMessages = [];
                    
                    multiScores.forEach(scoreEntry => {
                        const { name, points } = scoreEntry;
                        
                        // Find player (exact or fuzzy match)
                        let player = players.find(p => p.name.toLowerCase() === name.toLowerCase());
                        if (!player) {
                            player = findClosestPlayer(name);
                        }
                        
                        if (player) {
                            // Process score based on current game mode
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                addScoreToCurrentRound(player.id, points);
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                const success = addScoreToCurrentGolfHole(player.id, points);
                                if (success) {
                                    successCount++;
                                    feedbackMessages.push(`${player.name}: ${points}`);
                                }
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                const success = addScoreToCurrentScrabbleTurn(player.id, points);
                                if (success) {
                                    successCount++;
                                    feedbackMessages.push(`${player.name}: ${points}`);
                                }
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                const success = addScoreToCurrentGenericTurn(player.id, points);
                                if (success) {
                                    successCount++;
                                    feedbackMessages.push(`${player.name}: ${points}`);
                                }
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                // Phase 10 doesn't have automatic turn advancement via voice
                                player.score += points;
                                savePlayers();
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                // Yahtzee doesn't have automatic turn advancement via voice
                                player.score += points;
                                savePlayers();
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            } else {
                                // Standard mode
                                saveStateForUndo(`add ${points} to ${player.name}`);
                                player.score += points;
                                savePlayers();
                                successCount++;
                                feedbackMessages.push(`${player.name}: ${points}`);
                            }
                        }
                    });
                    
                    if (successCount > 0) {
                        // Player scoring interface removed - games use dedicated interfaces
                        const feedback = feedbackMessages.join(', ');
                        speak(`Scores added for ${successCount} player${successCount > 1 ? 's' : ''}`);
                        showVoiceFeedback(` ${successCount} score${successCount > 1 ? 's' : ''} added`, feedback);
                        setTimeout(hideVoiceFeedback, 2500);
                        return;
                    }
                }
            }
            
            // Check for button/menu commands first (before other checks)
            // These should work at any time
            
            // "Start Game" or "End Game" button
            if (transcript === 'start game' || transcript === 'start') {
                if (!gameInProgress) {
                    toggleGameState();
                    return;
                }
            }
            
            if (transcript === 'end game' || transcript === 'end' || 
                transcript === 'and game' || transcript === 'endgame' || 
                transcript === 'finish game' || transcript === 'finish' ||
                transcript === 'stop game' || transcript === 'stop') {
                if (gameInProgress) {
                    toggleGameState();
                    return;
                }
            }
            
            // Voice shortcuts for common actions
            
            // "Undo" or "Undo last" - trigger undo functionality
            if (transcript === 'undo' || transcript === 'undo last' || 
                transcript === 'undo that' || transcript === 'take that back') {
                if (gameInProgress && undoStack.length > 0) {
                    undoAction();
                    return;
                } else {
                    speak('Nothing to undo.');
                    return;
                }
            }
            
            // "What's the score?" - announce current scores
            if (transcript.includes("what's the score") || transcript.includes("whats the score") ||
                transcript.includes('current score') || transcript.includes('tell me the score') ||
                transcript === 'score' || transcript === 'scores') {
                if (gameInProgress && players.length > 0) {
                    announceCurrentScores();
                    return;
                } else {
                    speak('No game in progress.');
                    return;
                }
            }
            
            // Scrabble-specific voice commands (word checker and timer)
            if (currentGameType === 'scrabble') {
                if (await handleScrabbleWordCheck(transcript)) {
                    return; // Scrabble command was handled
                }
            }
            
            // "Reset Scores" button
            if (transcript === 'reset scores' || transcript === 'reset score') {
                resetScores();
                return;
            }
            
            // "Reset All" button
            if (transcript === 'reset all' || transcript === 'reset everything') {
                resetAll();
                return;
            }
            
            // Speaker ON commands
            if (transcript === 'sound on' || 
                transcript === 'computer voice on' || 
                transcript === 'computer on' || 
                transcript === 'speaker on' || 
                transcript === 'volume on') {
                if (isSpeakerMuted) {
                    toggleSpeaker();
                    showVoiceFeedback('Voice enabled', '');
                    setTimeout(hideVoiceFeedback, 1500);
                } else {
                    speak('Voice is already on');
                    showVoiceFeedback('Voice already on', '');
                    setTimeout(hideVoiceFeedback, 1500);
                }
                return;
            }
            
            // Speaker OFF commands
            if (transcript === 'sound off' || 
                transcript === 'computer voice off' || 
                transcript === 'computer off' || 
                transcript === 'speaker off' || 
                transcript === 'volume off') {
                if (!isSpeakerMuted) {
                    speak('Voice disabled');
                    showVoiceFeedback('Voice disabled', '');
                    setTimeout(() => {
                        toggleSpeaker();
                        hideVoiceFeedback();
                    }, 1500);
                } else {
                    showVoiceFeedback('Voice already off', '');
                    setTimeout(hideVoiceFeedback, 1500);
                }
                return;
            }
            
            // "Add More Players" button
            if (transcript === 'add more players' || transcript === 'more players') {
                addMorePlayerFields();
                showVoiceFeedback('Added more player fields', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            // "Done Adding Player Names" button
            if (transcript === 'done adding player names' || 
                transcript === 'done adding players' ||
                transcript === 'done adding names') {
                doneAdding();
                return;
            }
            
            // Tab switching: "Scoring", "High Scores"
            if (transcript === 'scoring' || transcript === 'scorekeeper') {
                switchTab('scorekeeper');
                showVoiceFeedback('Switched to Scoring tab', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            if (transcript === 'high scores' || transcript === 'scores') {
                switchTab('highscores');
                showVoiceFeedback('Switched to High Scores tab', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            // Scrabble buttons
            if (transcript === 'add new scoring row' || transcript === 'add row' || transcript === 'new row') {
                if (currentGameType === 'scrabble') {
                    addScrabbleRow();
                    return;
                } else if (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle') {
                    addGenericRow();
                    return;
                } else {
                    showVoiceFeedback('Only available in Scrabble, General, Darts, or Farkle modes', '');
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            
            if (transcript === 'final scoring adjustments' || 
                transcript === 'final adjustments' ||
                transcript === 'final scoring') {
                if (currentGameType === 'scrabble') {
                    scrabbleFinalAdjustments();
                    return;
                } else {
                    showVoiceFeedback('Only available in Scrabble mode', '');
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            
            // Ignore voice input while computer is speaking protected Scrabble instructions
            if (scrabbleSpeaking) {
                console.log(' Ignoring input while computer is speaking Scrabble instructions');
                return;
            }
            
            // Check if we're collecting Scrabble unplayed tiles
            if (scrabbleIsCollectingTiles) {
                processUnplayedTilesResponse(transcript);
                return;
            }
            
            // Check if we're asking for game type
            if (isAskingGameType) {
                // Ignore input during the initial speech to prevent self-listening
                if (window.gameTypeIgnoreUntil && Date.now() < window.gameTypeIgnoreUntil) {
                    console.log('Ignoring input during initial speech (self-listening prevention)');
                    return;
                }
                
                const gametype = detectGameType(transcript);
                if (gametype) {
                    window.gameTypeIgnoreUntil = null; // Clear ignore flag
                    currentGameType = gametype;
                    document.getElementById('gameType').value = gametype;
                    
                    // Update the custom dropdown display
                    const selectedGameSpan = document.getElementById('selectedGameType');
                    if (selectedGameSpan) {
                        const gameNames = {
                            'general': 'General',
                            'golf': 'Golf',
                            '5crowns': '5 Crowns',
                            'phase10': 'Phase 10',
                            'farkle': 'Farkle',
                            'darts': 'Darts',
                            'scrabble': 'Scrabble',
                            'yahtzee': 'Yahtzee'
                        };
                        selectedGameSpan.textContent = gameNames[gametype] || gametype;
                    }
                    
                    localStorage.setItem('scorekeeper_gametype', gametype);
                    
                    // Check for manually entered player names in the input fields
                    const manualPlayers = [];
                    const inputs = [
                        document.getElementById('playerNameInput1'),
                        document.getElementById('playerNameInput2'),
                        document.getElementById('playerNameInput3'),
                        document.getElementById('playerNameInput4')
                    ];
                    
                    // Also check any additional input fields that may have been added
                    const allInputs = document.querySelectorAll('#playerInputsContainer input[type="text"]');
                    
                    allInputs.forEach(input => {
                        if (input && input.value.trim() !== '') {
                            const name = input.value.trim();
                            const correctedName = correctPronunciation(name);
                            
                            // Check if player already exists
                            const existingPlayer = players.find(p => 
                                p.name.toLowerCase() === correctedName.toLowerCase()
                            );
                            
                            if (!existingPlayer) {
                                manualPlayers.push(correctedName);
                            }
                        }
                    });
                    
                    // Change game type (this switches to appropriate grid mode)
                    changeGameType();
                    
                    // Add manually entered players to the game
                    if (manualPlayers.length > 0) {
                        console.log('Adding manual players to game:', manualPlayers);
                        
                        manualPlayers.forEach(playerName => {
                            const newPlayer = {
                                id: Date.now() + Math.random(),
                                name: playerName,
                                score: 0
                            };
                            players.push(newPlayer);
                            
                            // Initialize grid scores based on game type
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                crownsScores[newPlayer.id] = {};
                                CROWNS_ROUNDS.forEach(round => {
                                    crownsScores[newPlayer.id][round] = 0;
                                });
                                currentCrownsRound[newPlayer.id] = 0;
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                golfScores[newPlayer.id] = {};
                                GOLF_HOLES.forEach(hole => {
                                    golfScores[newPlayer.id][hole] = 0;
                                });
                                currentGolfHole[newPlayer.id] = 0;
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                scrabbleScores[newPlayer.id] = {};
                                SCRABBLE_TURNS.forEach(turn => {
                                    scrabbleScores[newPlayer.id][turn] = 0;
                                });
                                scrabbleScores[newPlayer.id]['unplayed'] = 0;
                                scrabbleScores[newPlayer.id]['opponents'] = 0;
                                currentScrabbleTurn[newPlayer.id] = 0;
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                yahtzeeScores[newPlayer.id] = {
                                    ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                    upperTotal: 0, upperBonus: 0,
                                    threeKind: 0, fourKind: 0, fullHouse: 0,
                                    smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                    yahtzeeBonus: 0
                                };
                                yahtzeeUsedCategories[newPlayer.id] = {};
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                phase10Scores[newPlayer.id] = {};
                                PHASE10_PHASES.forEach(phase => {
                                    phase10Scores[newPlayer.id][phase.num] = 0;
                                });
                                phase10Completed[newPlayer.id] = {};
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                genericGridScores[newPlayer.id] = {};
                                GENERIC_TURNS.forEach(turn => {
                                    genericGridScores[newPlayer.id][turn] = 0;
                                });
                                currentGenericTurn[newPlayer.id] = 0;
                            }
                        });
                        
                        // Save and update tables - player scoring interface removed
                        savePlayers();
                        
                        // Render appropriate grid
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            saveCrownsScores();
                            renderCrownsTable();
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            renderGolfTable();
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            renderScrabbleTable();
                        } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                            saveYahtzeeData();
                            renderYahtzeeTable();
                        } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                            savePhase10Data();
                            renderPhase10Table();
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            saveGenericGridData();
                            renderGenericGridTable();
                        }
                        
                        // Clear input fields
                        allInputs.forEach(input => {
                            if (input) input.value = '';
                        });
                    }
                    
                    // If we're not in voice-guided setup mode, mark game as in progress
                    // If we are in voice-guided setup, stay in that mode until players are added
                    if (!isVoiceGuidedSetup) {
                        gameInProgress = true;
                    }
                    updateGameStateButton();
                    
                    isAskingGameType = false;
                    // Don't stop recognition - let it continue running
                    
                    const gameNames = {
                        'golf': 'Golf',
                        '5crowns': '5 Crowns',
                        'phase10': 'Phase 10',
                        'farkle': 'Farkle',
                        'darts': 'Darts',
                        'scrabble': 'Scrabble',
                        'yahtzee': 'Yahtzee',
                        'general': 'General'
                    };
                    
                    const playerCount = manualPlayers.length;
                    const playerMessage = playerCount > 0 ? ` ${playerCount} player${playerCount !== 1 ? 's' : ''} added.` : '';
                    const instructionMessage = playerCount === 0 ? ' Add player names, then say "Done adding" when complete.' : '';
                    speak(`Great! ${gameNames[gametype]} selected.${playerMessage}${instructionMessage}`);
                    showVoiceFeedback(`${gameNames[gametype]} selected!`, transcript);
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                    speak('I didn\'t catch that. Please say Golf, 5 Crowns, Phase 10, Farkle, Darts, Scrabble, Yahtzee, or General.');
                    showVoiceFeedback('Game not recognized', transcript);
                    setTimeout(() => {
                        hideVoiceFeedback();
                        // Don't stop recognition - let user try again immediately
                    }, 3000);
                    return;
                }
            }
            // Check if user says "done" - should work to hide player entry section
            console.log('Checking done command. isAddingMode:', isAddingMode, 'transcript:', transcript);
            
            // Done command works in two contexts:
            // 1. When in voice adding mode (isAddingMode = true)
            // 2. When players exist and user wants to finish setup
            const isDoneCommand = transcript.includes('done') || 
                                  transcript.includes('finished') || 
                                  transcript.includes('that\'s it') ||
                                  transcript.includes('that is it') ||
                                  transcript.includes('stop');
            
            if (isDoneCommand && (isAddingMode || players.length > 0)) {
                console.log(' Done command MATCHED! Calling doneAdding()...');
                
                // Exit adding mode but keep recognition running
                isAddingMode = false;
                // Keep voice recognition running so user can continue with commands
                
                // Call the centralized doneAdding function
                doneAdding();
                return;
            }
            // Check if user wants to start adding players
            if (!isAddingMode && (
                transcript.startsWith('add players') ||
                transcript.startsWith('add names') ||
                transcript === 'add' ||
                transcript.startsWith('add player')
            )) {
                isAddingMode = true;
                addedPlayersInSession = [];
                showVoiceFeedback('Say names... (say "done" when finished)', '');
                return;
            }
            // If in adding mode, treat everything as a name to add
            if (isAddingMode) {
                let names;
                
                // Check if there are commas (typed) or not (voice)
                if (transcript.includes(',')) {
                    // Has commas - split on commas and "and"
                    names = transcript
                        .split(/\s*,\s*and\s+|\s*,\s*|\s+and\s+/)
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                } else {
                    // No commas - voice input - split on " and " AND each word
                    names = transcript
                        .replace(/\s+and\s+/g, ' ')  // Remove " and "
                        .split(/\s+/)  // Split on whitespace
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                }
                
                // Apply filters and corrections
                names = names
                    .filter(name => !['add', 'player', 'players', 'name', 'names', 'and'].includes(name))
                    .map(name => correctPronunciation(name));
                console.log('Adding mode - parsed names:', names);
                if (names.length > 0) {
                    let addedToFields = 0;
                    let addedToGame = 0;
                    
                    names.forEach(name => {
                        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
                        
                        // 1. POPULATE INPUT FIELD (visual feedback)
                        const container = document.getElementById('playerInputsContainer');
                        const allInputs = container.querySelectorAll('input[type="text"]');
                        let foundEmpty = false;
                        
                        for (let input of allInputs) {
                            if (!input.value.trim()) {
                                input.value = capitalizedName;
                                addedToFields++;
                                foundEmpty = true;
                                
                                // Add flash animation
                                input.style.animation = 'none';
                                setTimeout(() => {
                                    input.style.animation = 'pulse 0.5s ease';
                                }, 10);
                                
                                break;
                            }
                        }
                        
                        // If all fields are full, create new fields automatically
                        if (!foundEmpty) {
                            addMorePlayerFields();
                            // Try again to fill the newly created field
                            const newInputs = container.querySelectorAll('input[type="text"]');
                            for (let input of newInputs) {
                                if (!input.value.trim()) {
                                    input.value = capitalizedName;
                                    addedToFields++;
                                    break;
                                }
                            }
                        }
                        
                        // 2. IMMEDIATELY ADD TO GAME (functional)
                        // Check if player already exists
                        const existingPlayer = players.find(p => p.name.toLowerCase() === capitalizedName.toLowerCase());
                        if (!existingPlayer) {
                            const newPlayer = {
                                id: Date.now() + Math.random(),
                                name: capitalizedName,
                                score: 0
                            };
                            players.push(newPlayer);
                            addedToGame++;
                            
                            // Initialize grid scores if in grid mode
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                crownsScores[newPlayer.id] = {};
                                CROWNS_ROUNDS.forEach(round => {
                                    crownsScores[newPlayer.id][round] = 0;
                                });
                                currentCrownsRound[newPlayer.id] = 0;
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                golfScores[newPlayer.id] = {};
                                GOLF_HOLES.forEach(hole => {
                                    golfScores[newPlayer.id][hole] = 0;
                                });
                                currentGolfHole[newPlayer.id] = 0;
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                scrabbleScores[newPlayer.id] = {};
                                SCRABBLE_TURNS.forEach(turn => {
                                    scrabbleScores[newPlayer.id][turn] = 0;
                                });
                                scrabbleScores[newPlayer.id]['unplayed'] = 0;
                                scrabbleScores[newPlayer.id]['opponents'] = 0;
                                currentScrabbleTurn[newPlayer.id] = 0;
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                yahtzeeScores[newPlayer.id] = {
                                    ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                    upperTotal: 0, upperBonus: 0,
                                    threeKind: 0, fourKind: 0, fullHouse: 0,
                                    smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                    yahtzeeBonus: 0
                                };
                                yahtzeeUsedCategories[newPlayer.id] = {};
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                phase10Scores[newPlayer.id] = {};
                                PHASE10_PHASES.forEach(phase => {
                                    phase10Scores[newPlayer.id][phase.num] = 0;
                                });
                                phase10Completed[newPlayer.id] = {};
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                genericGridScores[newPlayer.id] = {};
                                GENERIC_TURNS.forEach(turn => {
                                    genericGridScores[newPlayer.id][turn] = 0;
                                });
                                currentGenericTurn[newPlayer.id] = 0;
                            }
                        }
                        
                        addedPlayersInSession.push(capitalizedName);
                    });
                    
                    // Save players but DON'T render the interface yet - we're still in adding mode
                    if (addedToGame > 0) {
                        savePlayers();
                        // Don't call renderPlayers() here - wait for "Done Adding"
                        
                        // Only render grid tables if in grid mode (they don't show +/- buttons)
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            saveCrownsScores();
                            renderCrownsTable();
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            renderGolfTable();
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            renderScrabbleTable();
                        } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                            saveYahtzeeData();
                            renderYahtzeeTable();
                        } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                            savePhase10Data();
                            renderPhase10Table();
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            saveGenericGridData();
                            renderGenericGridTable();
                        }
                    }
                    
                    const count = addedPlayersInSession.length;
                    showVoiceFeedback(`${addedToGame} player${addedToGame !== 1 ? 's' : ''} added!`, names.join(', '));
                }
                return;
            }
            // If not in adding mode, process other commands
            showVoiceFeedback('Processing...', transcript);
            // Command: Undo last action
            if (transcript === 'undo' || transcript === 'undo that' || transcript === 'go back') {
                undo();
                return;
            }
            // Command: Correction commands (undo and allow re-entry)
            if (transcript === 'make correction' || 
                transcript === 'fix scores' || 
                transcript === 'fix' ||
                transcript === 'wrong' ||
                transcript === 'wrong entry' ||
                transcript === 'wrong number' ||
                transcript === 'wrong score' ||
                transcript === 'delete' ||
                transcript === 'delete score' ||
                transcript === 'delete entry' ||
                transcript === 'remove' ||
                transcript === 'remove score' ||
                transcript === 'remove entry') {
                undo();
                speak('Score removed. Please enter the correct score.');
                showVoiceFeedback('Ready for correction...', 'Say the correct score');
                setTimeout(hideVoiceFeedback, 3000);
                return;
            }
            // Command: Final Scoring Adjustments (Scrabble only)
            if (transcript.includes('final scoring') || 
                transcript.includes('final adjustments') ||
                transcript === 'final scoring adjustments') {
                if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    console.log(' Final Scoring Adjustments command detected');
                    scrabbleFinalAdjustments();
                    return;
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                    speak('Final scoring adjustments are only available in Scrabble mode');
                    showVoiceFeedback('Not in Scrabble mode', 'Switch to Scrabble to use this feature');
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            // Command: Golf over/under scoring (Advanced mode only)
            if (golfMode === 'advanced' && scoringMode === 'golf' && currentGameType === 'golf') {
                // Patterns: "Jonathan 1 over", "Jonathan plus 1", "Jonathan 1 under", "Jonathan minus 1"
                const overUnderPattern = /^(\w+)\s+(\d+)?\s*(over|under|plus|minus)\s*(\d+)?$/i;
                const match = transcript.match(overUnderPattern);
                
                if (match) {
                    const nameInput = match[1];
                    const num1 = match[2];
                    const command = match[3].toLowerCase();
                    const num2 = match[4];
                    
                    // Get the number (could be before or after the command)
                    const number = parseInt(num1 || num2 || '1');
                    
                    // Find matching player
                    const matchedPlayer = players.find(p => 
                        p.name.toLowerCase().startsWith(nameInput.toLowerCase())
                    );
                    
                    if (matchedPlayer) {
                        // Determine if it's over or under
                        const isOver = (command === 'over' || command === 'plus');
                        const scoreValue = isOver ? number : -number;
                        
                        // Find current hole for this player
                        const holeIndex = currentGolfHole[matchedPlayer.id] || 0;
                        if (holeIndex >= GOLF_HOLES.length) {
                            speak(`${matchedPlayer.name} has completed all holes`);
                            showVoiceFeedback('All holes complete', 'Start a new game');
                            return;
                        }
                        
                        const currentHole = GOLF_HOLES[holeIndex];
                        const par = golfCoursePar[currentHole];
                        
                        if (!par) {
                            speak(`Please set par for hole ${currentHole} first`);
                            showVoiceFeedback('Par not set', `Set par for hole ${currentHole}`);
                            return;
                        }
                        
                        // Save state for undo
                        saveStateForUndo(`${matchedPlayer.name} ${scoreValue > 0 ? '+' : ''}${scoreValue} on hole ${currentHole}`);
                        
                        // Add score
                        if (!golfScores[matchedPlayer.id]) {
                            golfScores[matchedPlayer.id] = {};
                        }
                        golfScores[matchedPlayer.id][currentHole] = scoreValue;
                        
                        // Move to next hole
                        currentGolfHole[matchedPlayer.id] = holeIndex + 1;
                        
                        saveGolfData();
                        
                        // Announce the score
                        const actualScore = par + scoreValue;
                        let announcement;
                        if (scoreValue > 0) {
                            announcement = `${matchedPlayer.name}, ${number} over par. Score: ${actualScore}`;
                        } else if (scoreValue < 0) {
                            announcement = `${matchedPlayer.name}, ${Math.abs(number)} under par. Score: ${actualScore}`;
                        } else {
                            announcement = `${matchedPlayer.name}, par. Score: ${actualScore}`;
                        }
                        
                        speak(announcement);
                        showVoiceFeedback(announcement, `Hole ${currentHole}`);
                        
                        renderGolfTable();
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: Add single player (or multiple with commas/and)
            if (transcript.startsWith('add ')) {
                console.log(' Add command detected. Full transcript:', transcript);
                const namesString = transcript.replace('add ', '').trim();
                console.log('Names string extracted:', namesString);
                
                if (namesString && !['players', 'names', 'player', 'name'].includes(namesString)) {
                    let names;
                    
                    // Check if there are commas (typed input) or not (voice input)
                    if (namesString.includes(',')) {
                        // Has commas - split on commas and "and"
                        names = namesString
                            .split(/\s*,\s*and\s+|\s*,\s*|\s+and\s+/)
                            .map(name => name.trim())
                            .filter(name => name.length > 0);
                        console.log('Detected commas - using comma split');
                    } else {
                        // No commas - voice input - split on " and " AND treat each word as a name
                        // First remove "and" to get individual words
                        names = namesString
                            .replace(/\s+and\s+/g, ' ')  // Remove " and "
                            .split(/\s+/)  // Split on whitespace
                            .map(name => name.trim())
                            .filter(name => name.length > 0);
                        console.log('No commas detected - treating each word as a name');
                    }
                    
                    // Apply filters and corrections
                    names = names
                        .filter(name => !['add', 'player', 'players', 'name', 'names', 'and'].includes(name))
                        .map(name => correctPronunciation(name));
                    
                    console.log('Parsed names from "' + namesString + '":', names);
                    console.log('Number of names:', names.length);
                    
                    if (names.length > 0) {
                        // Save state for undo
                        saveStateForUndo(`add ${names.length} player${names.length > 1 ? 's' : ''}`);
                        
                        let addedCount = 0;
                        names.forEach((name, index) => {
                            console.log(`Processing name ${index + 1}/${names.length}:`, name);
                            const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
                            console.log('  Capitalized:', capitalizedName);
                            
                            // Populate field
                            const container = document.getElementById('playerInputsContainer');
                            if (container) {
                                const allInputs = container.querySelectorAll('input[type="text"]');
                                let foundEmpty = false;
                                
                                for (let input of allInputs) {
                                    if (!input.value.trim()) {
                                        input.value = capitalizedName;
                                        foundEmpty = true;
                                        console.log('   Added to field');
                                        
                                        // Add flash animation
                                        input.style.animation = 'none';
                                        setTimeout(() => {
                                            input.style.animation = 'pulse 0.5s ease';
                                        }, 10);
                                        
                                        break;
                                    }
                                }
                                
                                // If all fields are full, create new fields
                                if (!foundEmpty) {
                                    console.log('   All fields full, creating new row');
                                    addMorePlayerFields();
                                    const newInputs = container.querySelectorAll('input[type="text"]');
                                    for (let input of newInputs) {
                                        if (!input.value.trim()) {
                                            input.value = capitalizedName;
                                            console.log('   Added to new field');
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // Add to game immediately
                            const existingPlayer = players.find(p => p.name.toLowerCase() === capitalizedName.toLowerCase());
                            if (!existingPlayer) {
                                console.log('   Adding to game');
                                const newPlayer = {
                                    id: Date.now() + Math.random(),
                                    name: capitalizedName,
                                    score: 0
                                };
                                players.push(newPlayer);
                                addedCount++;
                                
                                // Initialize grid scores if in grid mode
                                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                    crownsScores[newPlayer.id] = {};
                                    CROWNS_ROUNDS.forEach(round => {
                                        crownsScores[newPlayer.id][round] = 0;
                                    });
                                    currentCrownsRound[newPlayer.id] = 0;
                                } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                    golfScores[newPlayer.id] = {};
                                    GOLF_HOLES.forEach(hole => {
                                        golfScores[newPlayer.id][hole] = 0;
                                    });
                                    currentGolfHole[newPlayer.id] = 0;
                                } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                    scrabbleScores[newPlayer.id] = {};
                                    SCRABBLE_TURNS.forEach(turn => {
                                        scrabbleScores[newPlayer.id][turn] = 0;
                                    });
                                    scrabbleScores[newPlayer.id]['unplayed'] = 0;
                                    scrabbleScores[newPlayer.id]['opponents'] = 0;
                                    currentScrabbleTurn[newPlayer.id] = 0;
                                } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                    yahtzeeScores[newPlayer.id] = {
                                        ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                        upperTotal: 0, upperBonus: 0,
                                        threeKind: 0, fourKind: 0, fullHouse: 0,
                                        smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                        yahtzeeBonus: 0
                                    };
                                    yahtzeeUsedCategories[newPlayer.id] = {};
                                } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                    phase10Scores[newPlayer.id] = {};
                                    PHASE10_PHASES.forEach(phase => {
                                        phase10Scores[newPlayer.id][phase.num] = 0;
                                    });
                                    phase10Completed[newPlayer.id] = {};
                                } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                    genericGridScores[newPlayer.id] = {};
                                    GENERIC_TURNS.forEach(turn => {
                                        genericGridScores[newPlayer.id][turn] = 0;
                                    });
                                    currentGenericTurn[newPlayer.id] = 0;
                                }
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                console.log('   Player already exists, skipping');
                            }
                        });
                        
                        if (addedCount > 0) {
                            savePlayers();
                            // Player scoring interface removed - games use dedicated interfaces
                            
                            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                                saveCrownsScores();
                                renderCrownsTable();
                            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                                renderGolfTable();
                            } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                                renderScrabbleTable();
                            } else if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                                saveYahtzeeData();
                                renderYahtzeeTable();
                            } else if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                                savePhase10Data();
                                renderPhase10Table();
                            } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                                saveGenericGridData();
                                renderGenericGridTable();
                            }
                        }
                        
                        const displayNames = names.join(', ');
                        showVoiceFeedback(`Added ${addedCount} player${addedCount > 1 ? 's' : ''}!`, displayNames);
                        setTimeout(hideVoiceFeedback, 1500);
                    }
                    return;
                }
            }
            // Command: Give points - "give [name] [number] points" or "give [name] [number]"
            const giveMatch = transcript.match(/give\s+(.+?)\s+(.+?)(?:\s+points?)?$/i);
            if (giveMatch) {
                const name = correctPronunciation(giveMatch[1].toLowerCase().trim());
                const numberPart = giveMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Give command match:', name, numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        // In 5 Crowns mode, add to current round
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // In Golf mode, add to current hole
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            // In Scrabble mode, add to current turn
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All 20 turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode
                            saveStateForUndo(`add ${points} to ${player.name}`);
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: "[number] for/to [name]" - e.g. "5 for Guy" or "5 to Guy"
            const forMatch = transcript.match(/^(.+?)\s+(?:for|to)\s+(.+)$/i);
            if (forMatch) {
                const numberPart = forMatch[1].trim();
                const name = correctPronunciation(forMatch[2].toLowerCase().trim());
                const points = convertWordToNumber(numberPart);
                
                console.log('For/To command match:', numberPart, 'for/to', name, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All 20 turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: "[name] [number]" - e.g. "Guy 5"
            // This pattern should come after "for/to" to avoid conflicts
            const nameNumberMatch = transcript.match(/^(.+?)\s+(\d+|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand)$/i);
            if (nameNumberMatch) {
                const name = correctPronunciation(nameNumberMatch[1].toLowerCase().trim());
                const numberPart = nameNumberMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Name-Number command match:', name, numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode
                            saveStateForUndo(`add ${points} to ${player.name}`);
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: "change [name] to [number]" or "update [name] to [number]" - UPDATE score instead of add
            const changeMatch = transcript.match(/(?:change|update)\s+(.+?)\s+to\s+(.+)$/i);
            if (changeMatch) {
                const name = correctPronunciation(changeMatch[1].toLowerCase().trim());
                const numberPart = changeMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Change command match:', name, 'to', numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            // Update the most recent round (go back one)
                            const currentRoundIndex = currentCrownsRound[player.id] || 0;
                            if (currentRoundIndex > 0) {
                                const previousRound = CROWNS_ROUNDS[currentRoundIndex - 1];
                                crownsScores[player.id][previousRound] = points;
                                saveCrownsScores();
                                renderCrownsTableWithHighlight(player.id, previousRound);
                                speak(`Updated ${player.name} round ${previousRound} to ${points}`);
                                showVoiceFeedback(`Round ${previousRound}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            }
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // Update the most recent hole (go back one)
                            const currentHoleIndex = currentGolfHole[player.id] || 0;
                            if (currentHoleIndex > 0) {
                                const previousHole = GOLF_HOLES[currentHoleIndex - 1];
                                golfScores[player.id][previousHole] = points;
                                renderGolfTableWithHighlight(player.id, previousHole);
                                speak(`Updated ${player.name} hole ${previousHole} to ${points}`);
                                showVoiceFeedback(`Hole ${previousHole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            }
                        } else {
                            // Standard mode - SET score (not add)
                            player.score = points;
                            savePlayers();
                            
                            speak(`${player.name} score updated to ${points}`);
                            showVoiceFeedback(`${player.name}: ${points} points`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: Simple format - "[number] [name]" (e.g. "20 Jonathan")
            // Check if first part is a number, second part is a name
            const numberFirstMatch = transcript.match(/^(.+?)[\s,]+(.+)$/i);
            if (numberFirstMatch) {
                const firstPart = numberFirstMatch[1].trim();
                const secondPart = numberFirstMatch[2].trim();
                const firstAsNumber = convertWordToNumber(firstPart);
                
                // If first part is a number, treat second part as name
                if (firstAsNumber !== null) {
                    const points = firstAsNumber;
                    const name = correctPronunciation(secondPart.toLowerCase().trim());
                    
                    console.log('Number-first pattern match:', points, name);
                    
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        // In 5 Crowns mode, add to current round
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // In Golf mode, add to current hole
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            // In Scrabble mode, add to current turn
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode
                            saveStateForUndo(`add ${points} to ${player.name}`);
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        // First part is a number but player not found
                        // Fall through to name-first pattern (maybe it's actually name-number format)
                        console.log('Number-first pattern: player not found, trying name-first');
                    }
                }
            }
            // Command: Simple format - "[name] [number]" or "[name], [number]"
            // This needs to handle both digits and number words
            const simpleAddMatch = transcript.match(/^(.+?)[\s,]+(.+)$/i);
            if (simpleAddMatch) {
                const name = correctPronunciation(simpleAddMatch[1].toLowerCase().trim());
                const numberPart = simpleAddMatch[2].trim();
                const points = convertWordToNumber(numberPart);
                
                console.log('Simple add match:', name, numberPart, 'converted to:', points);
                
                if (points !== null) {
                    // Try exact match first, then fuzzy match
                    let player = players.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() ||
                        p.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // If no exact match, try fuzzy matching
                    if (!player) {
                        player = findClosestPlayer(name);
                        if (player) {
                            console.log('Fuzzy matched "' + name + '" to player:', player.name);
                        }
                    }
                    
                    if (player) {
                        // In 5 Crowns mode, add to current round
                        if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                            addScoreToCurrentRound(player.id, points);
                        } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                            // In Golf mode, add to current hole
                            const holeIndex = currentGolfHole[player.id];
                            const hole = GOLF_HOLES[holeIndex];
                            const success = addScoreToCurrentGolfHole(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on hole ${hole}`);
                                showVoiceFeedback(`Hole ${hole}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                            } else {
                                speak('All holes completed');
                                showVoiceFeedback('All 18 holes completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                            // In Scrabble mode, add to current turn
                            const turnIndex = currentScrabbleTurn[player.id];
                            const turn = SCRABBLE_TURNS[turnIndex];
                            const success = addScoreToCurrentScrabbleTurn(player.id, points);
                            if (success) {
                                speak(`${points} for ${player.name} on turn ${turn}`);
                                showVoiceFeedback(`Turn ${turn}: ${points} points`, player.name);
                                setTimeout(hideVoiceFeedback, 1500);
                        } else if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                            // In Generic Grid mode, add to current turn
                            const success = addScoreToCurrentGenericTurn(player.id, points);
                            if (!success) {
                                speak('All turns completed');
                                showVoiceFeedback('All turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                                speak('All turns completed');
                                showVoiceFeedback('All 20 turns completed!', '');
                                setTimeout(hideVoiceFeedback, 2000);
                            }
                        } else {
                            // Standard mode - add to total
                            player.score += points;
                            savePlayers();
                            
                            showVoiceFeedback(`+${points} to ${player.name}!`, transcript);
                            setTimeout(hideVoiceFeedback, 1500);
                            
                            const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                            if (scoreElement) {
                                scoreElement.classList.remove('pulse');
                                void scoreElement.offsetWidth;
                                scoreElement.classList.add('pulse');
                            }
                        }
                        return;
                    } else {
                        showVoiceFeedback(`Player "${name}" not found`, transcript);
                        setTimeout(hideVoiceFeedback, 2000);
                        return;
                    }
                }
            }
            // Command: Subtract format - "[name] minus [number]" or "[name], minus [number]"
            const simpleSubtractMatch = transcript.match(/^(\w+(?:\s+\w+)*?)[\s,]+(?:minus|negative)\s+(\d+)$/i);
            if (simpleSubtractMatch) {
                const name = correctPronunciation(simpleSubtractMatch[1].toLowerCase().trim());
                const points = parseInt(simpleSubtractMatch[2]);
                
                // Try exact match first, then fuzzy match
                let player = players.find(p => 
                    p.name.toLowerCase() === name.toLowerCase() ||
                    p.name.toLowerCase().includes(name.toLowerCase()) || 
                    name.toLowerCase().includes(p.name.toLowerCase())
                );
                
                // If no exact match, try fuzzy matching
                if (!player) {
                    player = findClosestPlayer(name);
                    if (player) {
                        console.log('Fuzzy matched "' + name + '" to player:', player.name);
                    }
                }
                
                if (player) {
                    player.score -= points;
                    savePlayers();
                    
                    showVoiceFeedback(`-${points} from ${player.name}!`, transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    
                    const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                    if (scoreElement) {
                        scoreElement.classList.remove('pulse');
                        void scoreElement.offsetWidth;
                        scoreElement.classList.add('pulse');
                    }
                    return;
                } else {
                    showVoiceFeedback(`Player "${name}" not found`, transcript);
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            // Command: Take points - "take [number] from [name]" or "subtract [number] from [name]"
            const takeMatch = transcript.match(/(?:take|subtract|remove)\s+(\d+)(?:\s+points?)?\s+from\s+(\w+(?:\s+\w+)*)/i);
            if (takeMatch) {
                const points = parseInt(takeMatch[1]);
                const name = takeMatch[2].toLowerCase();
                const player = players.find(p => p.name.toLowerCase().includes(name) || name.includes(p.name.toLowerCase()));
                
                if (player) {
                    player.score -= points;
                    savePlayers();
                    
                    showVoiceFeedback(`-${points} from ${player.name}!`, transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    
                    const scoreElement = document.querySelector(`[data-player-id="${player.id}"] .score-number`);
                    if (scoreElement) {
                        scoreElement.classList.remove('pulse');
                        void scoreElement.offsetWidth;
                        scoreElement.classList.add('pulse');
                    }
                    return;
                } else {
                    showVoiceFeedback(`Player "${name}" not found`, transcript);
                    setTimeout(hideVoiceFeedback, 2000);
                    return;
                }
            }
            // Command: Reset scores
            if (transcript.includes('reset') && transcript.includes('score')) {
                if (players.length > 0) {
                    players.forEach(p => p.score = 0);
                    savePlayers();
                    
                    showVoiceFeedback('All scores reset!', transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    return;
                }
            }
            // Command: Reset all
            if (transcript.includes('reset') && (transcript.includes('all') || transcript.includes('everything'))) {
                if (players.length > 0) {
                    players = [];
                    savePlayers();
                    
                    showVoiceFeedback('Everything reset!', transcript);
                    setTimeout(hideVoiceFeedback, 1500);
                    return;
                }
            }
            // If nothing matched, show feedback
            showVoiceFeedback('Command not recognized', transcript);
            setTimeout(hideVoiceFeedback, 2000);
        }
        // Load players from localStorage on startup
        function loadPlayers() {
            // Clear players and scores on launch for fresh start
            players = [];
            crownsScores = {};
            currentCrownsRound = {};
            gameInProgress = false; // Reset game state on page load
            savePlayers();
            saveCrownsScores();
            localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            
            
            // Load game type (keep the last selected game, but not if it's general)
            const savedGameType = localStorage.getItem('scorekeeper_gametype');
            if (savedGameType && savedGameType !== 'general') {
                currentGameType = savedGameType;
                const hiddenSelect = document.getElementById('gameType');
                if (hiddenSelect) {
                    hiddenSelect.value = savedGameType;
                }
                // Also update the visible dropdown display
                const selectedSpan = document.getElementById('selectedGameType');
                const gameNames = {
                    'general': 'General',
                    'golf': 'Golf',
                    '5crowns': '5 Crowns',
                    'phase10': 'Phase 10',
                    'farkle': 'Farkle',
                    'darts': 'Darts',
                    'scrabble': 'Scrabble',
                    'yahtzee': 'Yahtzee'
                };
                if (selectedSpan) {
                    selectedSpan.textContent = gameNames[savedGameType] || savedGameType;
                }
                changeGameType();
            }
            // Load walls
            loadWalls();
            
            // Load 5 Crowns scores
            loadCrownsScores();
            // Check if we've asked for game type before
            const askedBefore = localStorage.getItem('scorekeeper_asked_gametype');
            hasAskedGameType = askedBefore === 'true';
            // Don't auto-start voice on page load - user must click "Start Voice Recognition"
            
            // Ensure Start button is green on load
            updateGameStateButton();
        }
        // Save players to localStorage
        function savePlayers() {
            localStorage.setItem('scorekeeper_players', JSON.stringify(players));
        }
        
        // Save player input field values to sessionStorage
        function savePlayerInputs() {
            const inputs = {
                input1: document.getElementById('playerNameInput1')?.value || '',
                input2: document.getElementById('playerNameInput2')?.value || '',
                input3: document.getElementById('playerNameInput3')?.value || '',
                input4: document.getElementById('playerNameInput4')?.value || ''
            };
            console.log('Saving player inputs:', inputs);
            sessionStorage.setItem('scorekeeper_player_inputs', JSON.stringify(inputs));
            
            // Verify it was saved
            const verification = sessionStorage.getItem('scorekeeper_player_inputs');
            console.log('Verification - data in sessionStorage:', verification);
        }
        
        // Load player input field values from sessionStorage
        function loadPlayerInputs() {
            console.log('=== Loading Player Inputs ===');
            console.log('Current URL:', window.location.href);
            console.log('Protocol:', window.location.protocol);
            console.log('All sessionStorage keys:', Object.keys(sessionStorage));
            console.log('sessionStorage length:', sessionStorage.length);
            console.log('Looking for key: scorekeeper_player_inputs');
            const saved = sessionStorage.getItem('scorekeeper_player_inputs');
            console.log('Loading player inputs from sessionStorage:', saved);
            if (saved) {
                const inputs = JSON.parse(saved);
                console.log('Parsed inputs:', inputs);
                const input1 = document.getElementById('playerNameInput1');
                const input2 = document.getElementById('playerNameInput2');
                const input3 = document.getElementById('playerNameInput3');
                const input4 = document.getElementById('playerNameInput4');
                
                console.log('Found input elements:', {input1: !!input1, input2: !!input2, input3: !!input3, input4: !!input4});
                
                if (input1) input1.value = inputs.input1 || '';
                if (input2) input2.value = inputs.input2 || '';
                if (input3) input3.value = inputs.input3 || '';
                if (input4) input4.value = inputs.input4 || '';
                
                console.log('Values set to:', {
                    input1: input1?.value,
                    input2: input2?.value,
                    input3: input3?.value,
                    input4: input4?.value
                });
            } else {
                console.log('No saved player inputs found in sessionStorage');
            }
        }
        // Game Start
        function toggleGameVariantDropdown() {
            const dropdown = document.getElementById('gameVariantDropdown');
            const dropdownList = document.getElementById('gameVariantDropdownList');
            
            if (!dropdown || !dropdownList) return;
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
                dropdownList.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                dropdownList.classList.add('open');
            }
        }
        
        function selectGameVariant(variant) {
            const selectedSpan = document.getElementById('selectedGameVariant');
            const dropdown = document.getElementById('gameVariantDropdown');
            const dropdownList = document.getElementById('gameVariantDropdownList');
            
            if (selectedSpan) {
                selectedSpan.textContent = variant;
            }
            
            // Close dropdown
            if (dropdown) dropdown.classList.remove('open');
            if (dropdownList) dropdownList.classList.remove('open');
            
            // Set the starting score and trigger change
            startingScore = parseInt(variant);
            changeGameVariant();
        }
        
        function changeGameVariant() {
            // If game is in progress, update all player scores
            if (gameStarted) {
                players.forEach(player => {
                    if (dartsScores[player.id]) {
                        dartsScores[player.id].score = startingScore;
                        dartsScores[player.id].currentTurn = [];
                        dartsScores[player.id].doubledIn = !requireDoubleIn; // If double in not required, set to true
                        dartsScores[player.id].currentTurnTotal = 0;
                        dartsScores[player.id].currentTurnStartScore = startingScore;
                    }
                });
                renderGame();
            }
        }
        
        function startGameDarts() {
            if (players.length < 1) {
                return;
            }
            
            gameStarted = true;
            dartsScores = {};
            dartsHistory = [];
            dartsNextMultiplier = null;
            dartsKeypadRendered = false; // Reset flag for new game
            
            players.forEach(player => {
                dartsScores[player.id] = {
                    score: startingScore,
                    legs: 0,
                    sets: 0,
                    doubledIn: !requireDoubleIn,
                    currentTurn: [],
                    darts: 0,
                    currentTurnTotal: 0,
                    currentTurnStartScore: startingScore
                };
            });
            
            dartsCurrentPlayer = players[0].id;
            
            // Hide all other game modes
            const standardMode = document.getElementById('standardMode');
            const crownsMode = document.getElementById('crownsMode');
            const golfMode = document.getElementById('golfMode');
            const scrabbleMode = document.getElementById('scrabbleMode');
            const yahtzeeMode = document.getElementById('yahtzeeMode');
            const phase10Mode = document.getElementById('phase10Mode');
            const genericGridMode = document.getElementById('genericGridMode');
            
            if (standardMode) standardMode.style.display = 'none';
            if (crownsMode) crownsMode.classList.remove('active');
            if (golfMode) golfMode.classList.remove('active');
            if (scrabbleMode) scrabbleMode.classList.remove('active');
            if (yahtzeeMode) yahtzeeMode.classList.remove('active');
            if (phase10Mode) phase10Mode.classList.remove('active');
            if (genericGridMode) genericGridMode.classList.remove('active');
            
            // Show Darts container
            const darts501Container = document.getElementById('darts501Container');
            if (darts501Container) {
                darts501Container.style.display = 'block';
            }
            
            // Show game area
            const gameArea = document.getElementById('gameArea');
            if (gameArea) {
                gameArea.style.display = 'block';
            }
            
            // Show the game management buttons
            const buttonsDiv = document.getElementById('dartsButtons');
            if (buttonsDiv) {
                buttonsDiv.style.display = 'block';
            }
            
            renderGame();
        }

        

        // Game Rendering
        function renderGame() {
            renderDartsPlayers();
            renderKeypad();
        }

        function renderDartsPlayers() {
            // Get the playersContainer inside gameArea (not the one in standardMode)
            const gameArea = document.getElementById('gameArea');
            const container = gameArea ? gameArea.querySelector('#playersContainer') : null;
            
            if (!container) {
                return;
            }
            
            let html = '';
            
            players.forEach((player, index) => {
                const data = dartsScores[player.id];
                
                if (!data) {
                    return;
                }
                
                let dartsHTML = '';
                for (let i = 0; i < 3; i++) {
                    const dart = data.currentTurn[i];
                    let dartText = '';
                    let bgColor = '#f0f0f0';
                    let textColor = '#333';
                    
                    if (dart && dart.value !== undefined) {
                        // Check if dart is counted or not (for Double In rule)
                        if (dart.counted === false) {
                            // Uncounted dart - show in red
                            bgColor = '#ffebee'; // Light red background
                            textColor = '#c62828'; // Red text
                        } else {
                            // Counted dart - use normal colors based on type
                            if (dart.type === 'double') {
                                bgColor = '#4CAF50'; // Green for double
                                textColor = 'white';
                            } else if (dart.type === 'triple') {
                                bgColor = '#FF9800'; // Orange for triple
                                textColor = 'white';
                            }
                        }
                        
                        // Add prefix based on type
                        if (dart.type === 'double') {
                            dartText = 'D' + dart.value;
                        } else if (dart.type === 'triple') {
                            dartText = 'T' + dart.value;
                        } else {
                            dartText = dart.value;
                        }
                    }
                    
                    dartsHTML += `<div style="width: 58px; height: 40px; background: ${bgColor}; border: 2px solid #ddd; display: flex; align-items: center; justify-content: center; font-weight: bold; color: ${textColor}; border-radius: 4px; padding: 0 6px; box-sizing: border-box;">${dartText}</div>`;
                }
                
                let turnTotal = 0;
                data.currentTurn.forEach(dart => {
                    if (dart && dart.counted) turnTotal += dart.score;
                });
                
                const isActive = dartsCurrentPlayer === player.id;
                const activeClass = isActive ? ' darts-player-card active' : ' darts-player-card';
                
                html += `
                    <div class="${activeClass}" 
                         data-player-id="${player.id}" 
                         data-player-index="${index}"
                         draggable="true"
                         ondragstart="handleDartsDragStart(event, ${index})"
                         ondragover="handleDartsDragOver(event)"
                         ondragleave="handleDartsDragLeave(event)"
                         ondrop="handleDartsDrop(event, ${index})"
                         ondragend="handleDartsDragEnd(event)"
                         ontouchstart="handleTouchStart(event, ${index})"
                         ontouchmove="handleTouchMove(event)"
                         ontouchend="handleTouchEnd(event, ${index})"
                         onclick="selectDartsPlayer('${player.id}')" 
                         style="display: flex; align-items: center; gap: 15px; background: white; border: 2px solid #4CAF50; padding: 10px 15px; min-height: 50px; margin: 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: move; transition: background 0.2s ease;">
                        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 120px;" onclick="event.stopPropagation()">
                            <div style="display: flex; gap: 10px; align-items: baseline;">
                                <div style="font-size: 1.2rem; font-weight: bold; color: #333;">${data.score}</div>
                                <div style="font-size: 1.2rem; font-weight: bold; color: #333;">${player.name}</div>
                            </div>
                            <div style="display: flex; gap: 10px; font-size: 0.85rem; color: #000;">
                                <div>Turn Total: ${turnTotal}</div>
                                <div>Legs: ${data.legs}</div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-left: auto;" onclick="event.stopPropagation()">${dartsHTML}</div>
                    </div>
                `;
            });
            
            // Clear and style the container
            container.innerHTML = '';
            container.style.cssText = 'display: flex; flex-direction: column; gap: 10px; width: 100%; padding: 0;';
            
            // Set innerHTML
            container.innerHTML = html;
        }

        function renderKeypad() {
            // Use flag to prevent multiple renders - much more reliable than checking DOM
            if (dartsKeypadRendered) return;
            
            const container = document.getElementById('keypadContainer');
            const actionContainer = document.getElementById('actionButtonsContainer');
            
            if (!container || !actionContainer) return;
            
            // Mark as rendered BEFORE doing any work
            dartsKeypadRendered = true;
            
            // Clear both containers to ensure clean state
            container.innerHTML = '';
            actionContainer.innerHTML = '';
            
            // Reorder numbers: 0 first, then 1-20, then 25, then 50, then 100
            const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25, 50, 100];
            numbers.forEach(num => {
                const btn = document.createElement('button');
                btn.className = 'darts-keypad-btn';
                btn.textContent = num;
                btn.onclick = () => dartHit(num);
                container.appendChild(btn);
            });
            
            // Action buttons in separate container - each taking 1/3 width
            const doubleBtn = document.createElement('button');
            doubleBtn.className = 'darts-keypad-btn double';
            doubleBtn.textContent = 'Double';
            doubleBtn.style.flex = '1';
            doubleBtn.onclick = () => setMultiplier('double');
            actionContainer.appendChild(doubleBtn);
            
            const tripleBtn = document.createElement('button');
            tripleBtn.className = 'darts-keypad-btn triple';
            tripleBtn.textContent = 'Triple';
            tripleBtn.style.flex = '1';
            tripleBtn.onclick = () => setMultiplier('triple');
            actionContainer.appendChild(tripleBtn);
            
            const undoBtn = document.createElement('button');
            undoBtn.className = 'darts-keypad-btn undo';
            undoBtn.textContent = 'UNDO';
            undoBtn.style.flex = '1';
            undoBtn.onclick = () => undoDarts();
            actionContainer.appendChild(undoBtn);
        }

        // Game Logic
        function setMultiplier(type) {
            dartsNextMultiplier = type;
        }

        function dartHit(value) {
            const playerData = dartsScores[dartsCurrentPlayer];
            if (!playerData) return;
            
            if (playerData.currentTurn.length >= 3) return;
            
            // Track starting score for this turn (on first dart)
            if (playerData.currentTurn.length === 0) {
                playerData.currentTurnStartScore = playerData.score;
            }
            
            let score = value;
            let type = 'single';
            
            if (dartsNextMultiplier === 'double') {
                score = value * 2;
                type = 'double';
                dartsNextMultiplier = null;
            } else if (dartsNextMultiplier === 'triple') {
                score = value * 3;
                type = 'triple';
                dartsNextMultiplier = null;
            }
            
            console.log('Saving to history. Current player:', dartsCurrentPlayer, 'History length before:', dartsHistory.length);
            dartsHistory.push({
                scores: JSON.parse(JSON.stringify(dartsScores)),
                currentPlayer: dartsCurrentPlayer
            });
            console.log('History length after save:', dartsHistory.length);
            
            // Determine if this dart will be counted
            let isCounted = true;
            if (requireDoubleIn && !playerData.doubledIn) {
                // During double-in phase, count if this is a double OR if a double was already thrown in this turn
                const doubleAlreadyThrown = playerData.currentTurn.some(d => d.type === 'double' && d.value > 0);
                isCounted = (type === 'double' && value > 0) || doubleAlreadyThrown;
            }
            
            playerData.currentTurn.push({ value, score, type, counted: isCounted });
            playerData.darts++;
            
            // Calculate turn total considering double-in rule
            let turnTotal = 0;
            if (requireDoubleIn && !playerData.doubledIn) {
                // During double-in phase - only count double darts
                for (let i = 0; i < playerData.currentTurn.length; i++) {
                    if (playerData.currentTurn[i].counted) {
                        turnTotal += playerData.currentTurn[i].score;
                    }
                }
            } else {
                // After double-in phase, count all darts
                playerData.currentTurn.forEach(dart => {
                    if (dart) turnTotal += dart.score;
                });
            }
            
            // Store the turn total for display in renderPlayers
            playerData.currentTurnTotal = turnTotal;
            
            // Calculate new score based on STARTING score of the turn, not current score
            const newScore = playerData.currentTurnStartScore - turnTotal;
            
            // Check for bust - but handle double-in phase specially
            let isBust = false;
            if (requireDoubleIn && !playerData.doubledIn) {
                // In double-in phase, only bust if all 3 darts thrown with no double found
                if (playerData.currentTurn.length === 3) {
                    const doubleFound = playerData.currentTurn.some(d => d.type === 'double' && d.value > 0);
                    if (!doubleFound) {
                        isBust = true;
                    }
                }
            } else {
                // Normal bust checking (score goes negative or equals 1)
                if (newScore < 0 || newScore === 1) {
                    isBust = true;
                }
            }
            
            if (isBust) {
                endTurn(true);
                return;
            }
            
            // Win
            if (newScore === 0) {
                if (requireDoubleOut) {
                    // Must finish with a double
                    if (type === 'double') {
                        playerData.score = 0;
                        playerData.legs++;
                        renderGame();
                        
                        const winner = players.find(p => p.id === dartsCurrentPlayer);
                        showWinner(winner.name);
                    } else {
                        endTurn(true);
                    }
                } else {
                    // Can finish with any dart
                    playerData.score = 0;
                    playerData.legs++;
                    renderGame();
                    
                    const winner = players.find(p => p.id === dartsCurrentPlayer);
                    showWinner(winner.name);
                }
                return;
            }
            
            playerData.score = newScore;
            
            // Always render to show dart boxes and turn total
            renderGame();
            
            // Check if turn is complete (3 darts)
            if (playerData.currentTurn.length === 3) {
                endTurn(false);
            }
        }

        // Helper function to hide all game modes
        function hideAllGameModes() {
            // Clean up any active timers first
            if (typeof clearScrabbleTimer === 'function') {
                clearScrabbleTimer();
            }
            
            const standardMode = document.getElementById('standardMode');
            const crownsMode = document.getElementById('crownsMode');
            const golfMode = document.getElementById('golfMode');
            const scrabbleMode = document.getElementById('scrabbleMode');
            const yahtzeeMode = document.getElementById('yahtzeeMode');
            const phase10Mode = document.getElementById('phase10Mode');
            const genericGridMode = document.getElementById('genericGridMode');
            const darts501Container = document.getElementById('darts501Container');
            
            // Hide game mode containers
            if (standardMode) standardMode.style.display = 'none';
            if (crownsMode) crownsMode.classList.remove('active');
            if (golfMode) golfMode.classList.remove('active');
            if (scrabbleMode) scrabbleMode.classList.remove('active');
            if (yahtzeeMode) yahtzeeMode.classList.remove('active');
            if (phase10Mode) phase10Mode.classList.remove('active');
            if (genericGridMode) genericGridMode.classList.remove('active');
            if (darts501Container) darts501Container.style.display = 'none';
            
            // Hide all game button containers
            const scrabbleButtons = document.getElementById('scrabbleButtons');
            const yahtzeeButtons = document.getElementById('yahtzeeButtons');
            const phase10Buttons = document.getElementById('phase10Buttons');
            const genericGridButtons = document.getElementById('genericGridButtons');
            const genericGridGameButtons = document.getElementById('genericGridGameButtons');
            
            if (scrabbleButtons) scrabbleButtons.style.display = 'none';
            if (yahtzeeButtons) yahtzeeButtons.style.display = 'none';
            if (phase10Buttons) phase10Buttons.style.display = 'none';
            if (genericGridButtons) genericGridButtons.style.display = 'none';
            if (genericGridGameButtons) genericGridGameButtons.style.display = 'none';
        }

        function selectDartsPlayer(playerId) {
            console.log('Selecting player:', playerId);
            dartsCurrentPlayer = playerId;
            renderGame();
        }
        
        // Drag and drop variables
        let draggedPlayerIndex = null;
        
        function handleDartsDragStart(event, index) {
            draggedPlayerIndex = index;
            event.target.style.opacity = '0.4';
            event.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDartsDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            // Add visual feedback
            const target = event.currentTarget;
            if (target && target.classList.contains('darts-player-card')) {
                target.style.borderColor = '#2196F3';
                target.style.borderWidth = '3px';
            }
            return false;
        }
        
        function handleDartsDragLeave(event) {
            // Remove visual feedback when dragging out
            const target = event.currentTarget;
            if (target && target.classList.contains('darts-player-card')) {
                target.style.borderColor = '#4CAF50';
                target.style.borderWidth = '2px';
            }
        }
        
        function handleDartsDrop(event, dropIndex) {
            event.stopPropagation();
            event.preventDefault();
            
            // Remove visual feedback
            const target = event.currentTarget;
            if (target && target.classList.contains('darts-player-card')) {
                target.style.borderColor = '#4CAF50';
                target.style.borderWidth = '2px';
            }
            
            if (draggedPlayerIndex === null || draggedPlayerIndex === dropIndex) {
                return false;
            }
            
            // Reorder the players array
            const draggedPlayer = players[draggedPlayerIndex];
            players.splice(draggedPlayerIndex, 1);
            players.splice(dropIndex, 0, draggedPlayer);
            
            // Set the top player as the current player
            dartsCurrentPlayer = players[0].id;
            
            // Re-render to show new order
            renderGame();
            
            return false;
        }
        
        function handleDartsDragEnd(event) {
            event.target.style.opacity = '1';
            // Reset all borders
            document.querySelectorAll('.darts-player-card').forEach(card => {
                card.style.borderColor = '#4CAF50';
                card.style.borderWidth = '2px';
            });
            draggedPlayerIndex = null;
        }
        
        // Touch event handlers for mobile devices
        let touchDraggedIndex = null;
        let touchDragElement = null;
        
        function handleTouchStart(event, index) {
            touchDraggedIndex = index;
            touchDragElement = event.currentTarget;
            touchDragElement.style.opacity = '0.4';
        }
        
        function handleTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // Reset all borders
            document.querySelectorAll('.darts-player-card').forEach(card => {
                card.style.borderColor = '#4CAF50';
                card.style.borderWidth = '2px';
            });
            
            // Highlight the element we're over
            if (elementBelow && elementBelow.classList.contains('darts-player-card')) {
                elementBelow.style.borderColor = '#2196F3';
                elementBelow.style.borderWidth = '3px';
            }
        }
        
        function handleTouchEnd(event, dropIndex) {
            if (touchDragElement) {
                touchDragElement.style.opacity = '1';
            }
            
            // Reset all borders
            document.querySelectorAll('.darts-player-card').forEach(card => {
                card.style.borderColor = '#4CAF50';
                card.style.borderWidth = '2px';
            });
            
            if (touchDraggedIndex === null || touchDraggedIndex === dropIndex) {
                touchDraggedIndex = null;
                touchDragElement = null;
                return;
            }
            
            // Reorder the players array
            const draggedPlayer = players[touchDraggedIndex];
            players.splice(touchDraggedIndex, 1);
            players.splice(dropIndex, 0, draggedPlayer);
            
            // Set the top player as the current player
            dartsCurrentPlayer = players[0].id;
            
            // Re-render to show new order
            renderGame();
            
            touchDraggedIndex = null;
            touchDragElement = null;
        }
        
        function endTurn(bust) {
            const playerData = dartsScores[dartsCurrentPlayer];
            
            if (bust) {
                // On bust, restore the score to what it was at the start of this turn
                playerData.score = playerData.currentTurnStartScore;
            }
            
            // Check if this turn had a double (for double-in rule)
            if (requireDoubleIn && !playerData.doubledIn) {
                const doubleFound = playerData.currentTurn.some(d => d.type === 'double' && d.value > 0);
                if (doubleFound) {
                    playerData.doubledIn = true;
                }
            }
            
            const currentIndex = players.findIndex(p => p.id === dartsCurrentPlayer);
            const nextIndex = (currentIndex + 1) % players.length;
            dartsCurrentPlayer = players[nextIndex].id;
            
            // Clear the NEW current player's old turn data to prepare for their new turn
            dartsScores[dartsCurrentPlayer].currentTurn = [];
            dartsScores[dartsCurrentPlayer].darts = 0;
            dartsScores[dartsCurrentPlayer].currentTurnTotal = 0;
            dartsScores[dartsCurrentPlayer].currentTurnStartScore = 0;
            
            renderGame();
        }

        function resetLeg() {
            players.forEach(player => {
                dartsScores[player.id].score = startingScore;
                dartsScores[player.id].currentTurn = [];
                dartsScores[player.id].doubledIn = !requireDoubleIn; // If double in not required, set to true
                dartsScores[player.id].darts = 0;
                dartsScores[player.id].currentTurnTotal = 0;
                dartsScores[player.id].currentTurnStartScore = startingScore;
            });
            renderGame();
        }

        function undoDarts() {
            console.log('Undo called. History length:', dartsHistory.length);
            if (dartsHistory.length === 0) {
                alert('Nothing to undo');
                return;
            }
            const historyState = dartsHistory.pop();
            console.log('Restoring state. Player:', historyState.currentPlayer);
            dartsScores = historyState.scores;
            dartsCurrentPlayer = historyState.currentPlayer;
            console.log('Current player now:', dartsCurrentPlayer);
            renderGame();
        }

        function newLeg() {
            resetLeg();
        }
        
        function newSet() {
            // Reset leg
            resetLeg();
            // Also reset legs counter for all players
            players.forEach(player => {
                if (dartsScores[player.id]) {
                    dartsScores[player.id].legs = 0;
                }
            });
            renderGame();
        }

        function resetAll() { resetGame(); }
        function resetGame() {
            if (!confirm('Reset entire game?')) return;
            
            gameStarted = false;
            players = [];
            dartsScores = {};
            dartsKeypadRendered = false; // Reset flag so keypad can be rendered again
            
            const gameArea = document.getElementById('gameArea');
            if (gameArea) gameArea.style.display = 'none';
            document.getElementById('resetBtn').style.display = 'none';
            document.getElementById('keypadContainer').innerHTML = '';
            document.getElementById('actionButtonsContainer').innerHTML = '';
        }

        function showWinner(name) {
            const modal = document.getElementById('winnerModal');
            document.getElementById('winnerText').textContent = 'Winner!';
            document.getElementById('winnerDetails').textContent = `${name} wins the leg!`;
            modal.classList.add('active');
            
            // Announce winner and other player scores
            let announcement = `${name} wins! `;
            
            // Add other players' legs won (not current score)
            const otherPlayers = players.filter(p => p.name !== name);
            if (otherPlayers.length > 0) {
                announcement += "Other players' scores: ";
                otherPlayers.forEach((player, index) => {
                    const playerLegs = dartsScores[player.id]?.legs || 0;
                    const legWord = playerLegs === 1 ? 'leg' : 'legs';
                    announcement += `${player.name}: ${playerLegs} ${legWord}`;
                    if (index < otherPlayers.length - 1) {
                        announcement += ", ";
                    }
                });
            }
            
            speak(announcement);
        }

        function closeWinnerModal() {
            document.getElementById('winnerModal').classList.remove('active');
            resetLeg(); // Reset the leg for the next round
        }

        function updateGameRules() {
            requireDoubleIn = document.getElementById('doubleInCheckbox').checked;
            requireDoubleOut = document.getElementById('doubleOutCheckbox').checked;
        }

        // toggleMenu function already defined as window.toggleMenu above

        function changeGameType() {
            // Cancel any voice operations when manually changing game type
            cancelAllVoiceOperations();
            
            const select = document.getElementById('gameType');
            // Only read from select if it exists and matches currentGameType
            // This prevents overwriting when selectGameType has already set currentGameType
            if (select && select.value && select.value !== currentGameType) {
                console.log('changeGameType: Select value differs from currentGameType');
                console.log('  select.value:', select.value);
                console.log('  currentGameType:', currentGameType);
                console.log('  Using currentGameType (already set by selectGameType)');
            }
            // If no select found, currentGameType should already be set by selectGameType
            console.log('changeGameType called, currentGameType:', currentGameType);
            
            localStorage.setItem('scorekeeper_gametype', currentGameType);
            
            // If no players, always show standard mode with empty state
            if (players.length === 0) {
                console.log('No players - showing standard mode empty state');
                const standardMode = document.getElementById('standardMode');
                const crownsMode = document.getElementById('crownsMode');
                const golfMode = document.getElementById('golfMode');
                const scrabbleMode = document.getElementById('scrabbleMode');
                const yahtzeeMode = document.getElementById('yahtzeeMode');
                const phase10Mode = document.getElementById('phase10Mode');
                const genericGridMode = document.getElementById('genericGridMode');
                const darts501Container = document.getElementById('darts501Container');
                
                // Show standard mode, hide all grid modes
                standardMode.style.display = 'block';
                if (crownsMode) crownsMode.classList.remove('active');
                if (golfMode) golfMode.classList.remove('active');
                if (scrabbleMode) scrabbleMode.classList.remove('active');
                if (yahtzeeMode) yahtzeeMode.classList.remove('active');
                if (phase10Mode) phase10Mode.classList.remove('active');
                if (genericGridMode) genericGridMode.classList.remove('active');
                if (darts501Container) darts501Container.style.display = 'none';
                
                // Update instructions display
                updateStandardModeDisplay();
                
                 // This will show the empty state
                return;
            }
            
            // Players exist - update subtitle based on game type
            const subtitle = document.querySelector('.subtitle');
            switch(currentGameType) {
                case 'golf':
                    subtitle.textContent = 'Lower Score Wins';
                    break;
                case '5crowns':
                    subtitle.textContent = 'Lower Score Wins';
                    break;
                case 'phase10':
                    subtitle.textContent = 'Lower Score Wins';
                    break;
                case 'farkle':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                case 'darts':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                case 'scrabble':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                case 'yahtzee':
                    subtitle.textContent = 'Higher Score Wins';
                    break;
                default:
                    subtitle.textContent = 'Track  Compete  Win';
            }
            // Automatically switch to 5 Crowns Grid mode if 5 Crowns is selected
            if (currentGameType === '5crowns') {
                console.log('Switching to 5 Crowns grid mode');
                scoringMode = 'crowns';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show 5 Crowns mode
                const crownsMode = document.getElementById('crownsMode');
                crownsMode.classList.add('active');
                
                console.log('standardMode display:', standardMode.style.display);
                console.log('crownsMode classList:', crownsMode.classList);
                
                // Initialize grid with existing players (preserves any existing data)
                initializeCrownsScores();
                renderCrownsTable();
                
                // Don't render players on main screen - 5 Crowns uses its own grid interface
            } else if (currentGameType === 'golf') {
                console.log('Switching to Golf grid mode');
                scoringMode = 'golf';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Golf mode
                const golfMode = document.getElementById('golfMode');
                golfMode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializeGolfScores();
                renderGolfTable();
                
                // Update the golf course dropdown list
                updateSavedCoursesList();
                
                // Don't render players on main screen - Golf uses its own grid interface
            } else if (currentGameType === 'scrabble') {
                console.log('Switching to Scrabble grid mode');
                scoringMode = 'scrabble';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Scrabble mode
                const scrabbleMode = document.getElementById('scrabbleMode');
                scrabbleMode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializeScrabbleScores();
                renderScrabbleTable();
                
                // Reset timer state when entering Scrabble mode
                resetScrabbleTimerState();
                
                // Don't render players on main screen - Scrabble uses its own grid interface
            } else if (currentGameType === 'yahtzee') {
                console.log('Switching to Yahtzee grid mode');
                scoringMode = 'yahtzee';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Yahtzee mode
                const yahtzeeMode = document.getElementById('yahtzeeMode');
                yahtzeeMode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializeYahtzeeScores();
                renderYahtzeeTable();
                
                // Don't render players on main screen - Yahtzee uses its own grid interface
            } else if (currentGameType === 'phase10') {
                console.log('Switching to Phase 10 grid mode');
                scoringMode = 'phase10';
                
                // Hide all other modes first
                hideAllGameModes();
                
                // Show Phase 10 mode
                const phase10Mode = document.getElementById('phase10Mode');
                phase10Mode.classList.add('active');
                
                // Initialize grid with existing players (preserves any existing data)
                initializePhase10Scores();
                renderPhase10Table();
                
                // Don't render players on main screen - Phase 10 uses its own grid interface
            } else if (currentGameType === 'darts') {
                console.log('Switching to Darts 501 mode');
                
                // If players already exist, start the Darts game directly
                if (players.length > 0) {
                    console.log('Darts: Players exist, starting game directly');
                    
                    // Hide all other modes first
                    hideAllGameModes();
                    
                    // Initialize Darts if not already initialized
                    if (!dartsScores || Object.keys(dartsScores).length === 0) {
                        console.log('Initializing Darts game with existing players');
                        startGameDarts();
                    } else {
                        // Just show the Darts interface
                        const darts501Container = document.getElementById('darts501Container');
                        if (darts501Container) {
                            darts501Container.style.display = 'block';
                            const gameArea = document.getElementById('gameArea');
                            if (gameArea) gameArea.style.display = 'block';
                            renderGame();
                        }
                    }
                } else {
                    // No players yet - show player setup
                    console.log('Darts: No players, showing player setup screen');
                    
                    // Hide all other modes first
                    hideAllGameModes();
                    
                    // Show general player setup
                    const standardMode = document.getElementById('standardMode');
                    const addPlayerSection = document.getElementById('addPlayerSection');
                    if (standardMode) standardMode.style.display = 'block';
                    if (addPlayerSection) addPlayerSection.style.display = 'flex';
                }
            } else {
                // Use generic grid for General and Farkle
                if (currentGameType === 'general' || currentGameType === 'farkle') {
                    console.log('Switching to Generic Grid mode for', currentGameType);
                    scoringMode = 'generic';
                    
                    // Hide all other modes first
                    hideAllGameModes();
                    
                    // Show Generic Grid mode
                    const genericGridMode = document.getElementById('genericGridMode');
                    if (genericGridMode) genericGridMode.classList.add('active');
                    
                    // Initialize grid with existing players (preserves any existing data)
                    initializeGenericGridScores();
                    renderGenericGridTable();
                    
                    // Don't render players on main screen - Generic Grid uses its own grid interface
                } else {
                    // Switch back to standard mode for other games
                    scoringMode = 'standard';
                    document.getElementById('standardMode').style.display = 'block';
                    const darts501Container = document.getElementById('darts501Container');
                    if (darts501Container) darts501Container.style.display = 'none'; // Hide Darts
                    const addPlayerSection = document.getElementById('addPlayerSection');
                    if (addPlayerSection) addPlayerSection.style.display = 'flex'; // Show general player setup
                    document.getElementById('crownsMode').classList.remove('active');
                    if (document.getElementById('golfMode')) {
                        document.getElementById('golfMode').classList.remove('active');
                    }
                    if (document.getElementById('scrabbleMode')) {
                        document.getElementById('scrabbleMode').classList.remove('active');
                    }
                    if (document.getElementById('yahtzeeMode')) {
                        document.getElementById('yahtzeeMode').classList.remove('active');
                    }
                    if (document.getElementById('genericGridMode')) {
                        document.getElementById('genericGridMode').classList.remove('active');
                    }
                    
                    // Re-render player list to show current scores
                    
                }
            }
        }
        function addPlayer() {
            // Cancel any voice operations when manually adding players
            cancelAllVoiceOperations();
            
            // Check all 4 input fields
            const inputs = [
                document.getElementById('playerNameInput1'),
                document.getElementById('playerNameInput2'),
                document.getElementById('playerNameInput3'),
                document.getElementById('playerNameInput4')
            ];
            
            let addedCount = 0;
            
            inputs.forEach((input, index) => {
                if (input) {
                    const name = input.value.trim();
                    if (name !== '') {
                        const correctedName = correctPronunciation(name);
                        const player = {
                            id: Date.now() + index,
                            name: correctedName,
                            score: 0
                        };
                        
                        players.push(player);
                        addedCount++;
                        input.value = ''; // Clear the field
                    }
                }
            });
            
            if (addedCount > 0) {
                savePlayers();
                
                
                // Focus first empty field
                const firstEmpty = inputs.find(input => input && input.value === '');
                if (firstEmpty) {
                    firstEmpty.focus();
                }
            }
        }
        function addMorePlayerFields() {
            const container = document.getElementById('playerInputsContainer');
            
            // Create a new row with 2 input fields
            const newRow = document.createElement('div');
            newRow.className = 'player-inputs-row';
            
            const input1 = document.createElement('input');
            input1.type = 'text';
            input1.id = 'playerNameInput' + nextPlayerNumber;
            input1.placeholder = 'Player ' + nextPlayerNumber;
            input1.maxLength = 20;
            
            const input2 = document.createElement('input');
            input2.type = 'text';
            input2.id = 'playerNameInput' + (nextPlayerNumber + 1);
            input2.placeholder = 'Player ' + (nextPlayerNumber + 1);
            input2.maxLength = 20;
            
            // Add Enter key support for new inputs
            input1.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addMorePlayerFields();
                }
            });
            input2.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addMorePlayerFields();
                }
            });
            
            newRow.appendChild(input1);
            newRow.appendChild(input2);
            container.appendChild(newRow);
            
            // Update next player number
            nextPlayerNumber += 2;
            
            // Focus on the first new input
            input1.focus();
        }
        function doneAdding() {
            // Cancel any voice operations when done adding players
            cancelAllVoiceOperations();
            
            console.log('doneAdding called, current players:', players.length);
            
            // First, add any names that are in the text fields but haven't been added yet
            // Find all input fields dynamically (including newly added ones)
            const container = document.getElementById('playerInputsContainer');
            const allInputs = container.querySelectorAll('input[type="text"]');
            
            let addedCount = 0;
            let skippedCount = 0;
            allInputs.forEach((input, index) => {
                if (input) {
                    const name = input.value.trim();
                    if (name !== '') {
                        const correctedName = correctPronunciation(name);
                        
                        // Check if player already exists
                        const existingPlayer = players.find(p => p.name.toLowerCase() === correctedName.toLowerCase());
                        
                        if (!existingPlayer) {
                            const player = {
                                id: Date.now() + index + Math.random(),
                                name: correctedName,
                                score: 0
                            };
                            
                            players.push(player);
                            addedCount++;
                            console.log('doneAdding: Added new player:', correctedName);
                        } else {
                            skippedCount++;
                            console.log('doneAdding: Player already exists, skipping:', correctedName);
                        }
                        
                        input.value = ''; // Clear the field
                    }
                }
            });
            
            console.log(`doneAdding: Added ${addedCount}, Skipped ${skippedCount}, Total players: ${players.length}`);
            console.log('Current game type:', currentGameType);
            console.log('Current scoring mode:', scoringMode);
            
            // Clear saved player inputs since we're done adding
            sessionStorage.removeItem('scorekeeper_player_inputs');
            
            // If no players at all, exit early
            if (players.length === 0) {
                speak('No players added yet.');
                showVoiceFeedback('No players added', '');
                setTimeout(hideVoiceFeedback, 2000);
                return;
            }
            
            // Save players
            savePlayers();
            
            // Initialize grid based on game type
            console.log('=== DONE ADDING - INITIALIZING GAME ===');
            console.log('Current game type from variable:', currentGameType);
            console.log('Game type in localStorage:', localStorage.getItem('scorekeeper_gametype'));
            console.log('Dropdown value:', document.getElementById('gameType')?.value);
            console.log('Initializing game for type:', currentGameType);
            if (currentGameType === '5crowns') {
                scoringMode = 'crowns';
                initializeCrownsScores();
                renderCrownsTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'golf') {
                scoringMode = 'golf';
                initializeGolfScores();
                renderGolfTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'scrabble') {
                scoringMode = 'scrabble';
                initializeScrabbleScores();
                renderScrabbleTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'yahtzee') {
                scoringMode = 'yahtzee';
                initializeYahtzeeScores();
                renderYahtzeeTable();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'phase10') {
                scoringMode = 'phase10';
                initializePhase10Scores();
                renderPhase10Table();
                changeGameType(); // Ensure UI is properly set up
            } else if (currentGameType === 'darts') {
                // Initialize Darts game
                console.log('Initializing Darts game with players:', players.length);
                startGameDarts();
            } else if (currentGameType === 'general' || currentGameType === 'farkle') {
                // For generic games, call changeGameType to initialize
                console.log('Calling changeGameType for generic game');
                changeGameType();
            }
            
            // Hide the add player section
            console.log('Hiding addPlayerSection');
            const addPlayerSection = document.getElementById('addPlayerSection');
            if (addPlayerSection) {
                addPlayerSection.style.display = 'none';
                console.log('addPlayerSection hidden');
            }
            
            // Set flag so section stays hidden when switching tabs
            isDoneAdding = true;
            
            // Add grid-mode class to body to trigger tab bar replacement
            document.body.classList.add('grid-mode');
            
            // Move game-type-row into tab-navigation-container
            const gameTypeRow = document.querySelector('.game-type-row');
            const tabNavContainer = document.querySelector('.tab-navigation-container');
            if (gameTypeRow && tabNavContainer) {
                // Insert game-type-row as first child of tab-navigation-container
                tabNavContainer.insertBefore(gameTypeRow, tabNavContainer.firstChild);
            }
            
            // Clear adding mode state
            isAddingMode = false;
            addedPlayersInSession = [];
            
            // Mark game as in progress and update button
            console.log('Setting game in progress - transitioning from voice-guided setup');
            isVoiceGuidedSetup = false; // Exit voice-guided setup mode
            gameInProgress = true;
            updateGameStateButton();
            
            speak(`${players.length} player${players.length > 1 ? 's' : ''} ready! Let's start the game.`);
            showVoiceFeedback(`${players.length} player${players.length > 1 ? 's' : ''} ready!`, '');
            setTimeout(hideVoiceFeedback, 2000);
            
            // Update instructions display (will hide them since players now exist)
            updateStandardModeDisplay();
        }
        
        function updateStandardModeDisplay() {
            const instructions = document.getElementById('standardModeInstructions');
            const standardMode = document.getElementById('standardMode');
            if (instructions && standardMode) {
                // Show instructions only when no players exist and standard mode is visible
                const isStandardModeVisible = standardMode.style.display !== 'none';
                if (players.length === 0 && isStandardModeVisible) {
                    instructions.style.display = 'block';
                } else {
                    instructions.style.display = 'none';
                }
            }
        }
        
        function deletePlayer(id) {
            // Find the player before deleting (for console logging)
            const player = players.find(p => p.id === id);
            if (player) {
                console.log('Deleting player:', player.name, 'ID:', id);
                
                // Remove from players array
                players = players.filter(p => p.id !== id);
                
                // Remove from 5 Crowns scores if in that mode
                if (crownsScores[id]) {
                    delete crownsScores[id];
                    delete currentCrownsRound[id];
                    saveCrownsScores();
                    localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                    console.log('Removed from 5 Crowns scores');
                }
                
                // Remove from Golf scores if in that mode
                if (golfScores[id]) {
                    delete golfScores[id];
                    delete currentGolfHole[id];
                    console.log('Removed from Golf scores');
                }
                
                // Remove from Scrabble scores if in that mode
                if (scrabbleScores[id]) {
                    delete scrabbleScores[id];
                    delete currentScrabbleTurn[id];
                    console.log('Removed from Scrabble scores');
                }
                
                // Save and render
                savePlayers();
                
                
                // Re-render grids if in grid mode
                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                    renderCrownsTable();
                    console.log('Refreshed 5 Crowns grid');
                } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                    renderGolfTable();
                    console.log('Refreshed Golf grid');
                } else if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    renderScrabbleTable();
                    console.log('Refreshed Scrabble grid');
                }
            }
        }
        // updateScore function removed with old player interface
        // ===== UNDO FUNCTIONALITY =====
        
        function saveStateForUndo(actionDescription) {
            const state = {
                description: actionDescription,
                players: JSON.parse(JSON.stringify(players)),
                crownsScores: JSON.parse(JSON.stringify(crownsScores)),
                currentCrownsRound: JSON.parse(JSON.stringify(currentCrownsRound)),
                golfScores: JSON.parse(JSON.stringify(golfScores)),
                currentGolfHole: JSON.parse(JSON.stringify(currentGolfHole)),
                timestamp: Date.now()
            };
            
            undoStack.push(state);
            
            // Keep stack size manageable
            if (undoStack.length > MAX_UNDO_HISTORY) {
                undoStack.shift();
            }
            
            console.log('Saved undo state:', actionDescription, 'Stack size:', undoStack.length);
        }
        
        function undo() {
            if (undoStack.length === 0) {
                speak('Nothing to undo');
                showVoiceFeedback('Nothing to undo', '');
                setTimeout(hideVoiceFeedback, 1500);
                return;
            }
            
            // Pop the last state
            const previousState = undoStack.pop();
            
            // Restore state
            players = JSON.parse(JSON.stringify(previousState.players));
            crownsScores = JSON.parse(JSON.stringify(previousState.crownsScores));
            currentCrownsRound = JSON.parse(JSON.stringify(previousState.currentCrownsRound));
            golfScores = JSON.parse(JSON.stringify(previousState.golfScores));
            currentGolfHole = JSON.parse(JSON.stringify(previousState.currentGolfHole));
            
            // Save and render
            savePlayers();
            saveCrownsScores();
            localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
            
            
            // Re-render grids if needed
            if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                renderCrownsTable();
            } else if (scoringMode === 'golf' && currentGameType === 'golf') {
                renderGolfTable();
            }
            
            speak(`Undid ${previousState.description}`);
            showVoiceFeedback(`Undid: ${previousState.description}`, '');
            setTimeout(hideVoiceFeedback, 2000);
            
            console.log('Undid action:', previousState.description, 'Remaining in stack:', undoStack.length);
        }
        async function resetScores() {
            // Cancel any voice operations when manually resetting scores
            cancelAllVoiceOperations();
            
            if (players.length === 0) return;
            
            const shouldReset = await customConfirm('Reset all scores to 0?', ' Reset Scores');
            if (shouldReset) {
                // Reset standard scores
                players.forEach(p => p.score = 0);
                
                // Reset 5 Crowns scores if in that mode
                if (scoringMode === 'crowns' && currentGameType === '5crowns') {
                    players.forEach(player => {
                        CROWNS_ROUNDS.forEach(round => {
                            if (crownsScores[player.id]) {
                                crownsScores[player.id][round] = 0;
                            }
                        });
                        currentCrownsRound[player.id] = 0;
                    });
                    saveCrownsScores();
                    localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                    renderCrownsTable();
                }
                
                // Reset Golf scores if in that mode
                if (scoringMode === 'golf' && currentGameType === 'golf') {
                    players.forEach(player => {
                        GOLF_HOLES.forEach(hole => {
                            if (golfScores[player.id]) {
                                golfScores[player.id][hole] = 0;
                            }
                        });
                        currentGolfHole[player.id] = 0;
                    });
                    renderGolfTable();
                }
                
                // Reset Scrabble scores if in that mode
                if (scoringMode === 'scrabble' && currentGameType === 'scrabble') {
                    players.forEach(player => {
                        SCRABBLE_TURNS.forEach(turn => {
                            if (scrabbleScores[player.id]) {
                                scrabbleScores[player.id][turn] = 0;
                            }
                        });
                        if (scrabbleScores[player.id]) {
                            scrabbleScores[player.id]['unplayed'] = 0;
                            scrabbleScores[player.id]['opponents'] = 0;
                        }
                        currentScrabbleTurn[player.id] = 0;
                    });
                    renderScrabbleTable();
                }
                
                // Reset Yahtzee scores if in that mode
                if (scoringMode === 'yahtzee' && currentGameType === 'yahtzee') {
                    players.forEach(player => {
                        if (yahtzeeScores[player.id]) {
                            // Reset all category scores to 0
                            yahtzeeScores[player.id] = {
                                ones: 0, twos: 0, threes: 0, fours: 0, fives: 0, sixes: 0,
                                upperTotal: 0, upperBonus: 0,
                                threeKind: 0, fourKind: 0, fullHouse: 0,
                                smStraight: 0, lgStraight: 0, yahtzee: 0, chance: 0,
                                yahtzeeBonus: 0
                            };
                        }
                        // Clear all used categories so they show as "-" again
                        yahtzeeUsedCategories[player.id] = {};
                    });
                    saveYahtzeeData();
                    renderYahtzeeTable();
                }
                
                // Reset Phase 10 scores if in that mode
                if (scoringMode === 'phase10' && currentGameType === 'phase10') {
                    players.forEach(player => {
                        if (phase10Scores[player.id]) {
                            PHASE10_PHASES.forEach(phase => {
                                phase10Scores[player.id][phase.num] = 0;
                            });
                        }
                        phase10Completed[player.id] = {};
                    });
                    savePhase10Data();
                    renderPhase10Table();
                }
                
                // Reset Generic Grid scores if in that mode
                if (scoringMode === 'generic' && (currentGameType === 'general' || currentGameType === 'darts' || currentGameType === 'farkle')) {
                    players.forEach(player => {
                        GENERIC_TURNS.forEach(turn => {
                            if (genericGridScores[player.id]) {
                                genericGridScores[player.id][turn] = 0;
                            }
                        });
                        currentGenericTurn[player.id] = 0;
                    });
                    saveGenericGridData();
                    renderGenericGridTable();
                }
                
                savePlayers();
                
            }
        }
        window.resetAll = async function() {
            console.log(' Reset All button clicked');
            // Cancel any voice operations when resetting all
            cancelAllVoiceOperations();
            
            console.log(' Calling customConfirm for Reset All...');
            const shouldReset = await customConfirm('Reset everything and start over?', ' Reset All');
            console.log(' customConfirm returned:', shouldReset);
            
            if (shouldReset) {
                console.log(' User confirmed reset, proceeding...');
                // Clear all players and scores
                players = [];
                crownsScores = {};
                currentCrownsRound = {};
                golfScores = {};
                currentGolfHole = {};
                scrabbleScores = {};
                currentScrabbleTurn = {};
                yahtzeeScores = {};
                yahtzeeUsedCategories = {};
                phase10Scores = {};
                phase10Completed = {};
                genericGridScores = {};
                currentGenericTurn = {};
                dartsScores = {};
                dartsCurrentPlayer = null;
                dartsKeypadRendered = false; // Reset keypad flag
                SCRABBLE_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Reset to 12 turns
                scrabbleMaxTurn = 12; // Reset max turn
                GENERIC_TURNS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; // Reset to 12 turns
                genericMaxTurn = 12; // Reset max turn
                gameInProgress = false;
                isVoiceGuidedSetup = false; // Reset voice-guided setup state
                gameStarted = false; // Reset Darts game started flag
                isAskingGameType = false;
                hasAskedGameType = false;
                isDoneAdding = false; // Reset done adding flag
                
                // Remove grid-mode class from body
                document.body.classList.remove('grid-mode');
                
                // Move game-type-row back to its original position (after tab-navigation-container)
                const gameTypeRow = document.querySelector('.game-type-row');
                const tabNavContainer = document.querySelector('.tab-navigation-container');
                if (gameTypeRow && tabNavContainer && gameTypeRow.parentElement === tabNavContainer) {
                    tabNavContainer.parentElement.insertBefore(gameTypeRow, tabNavContainer.nextSibling);
                }
                nextPlayerNumber = 5; // Reset to 5 for next added fields
                currentGameType = 'general'; // Reset game type to general
                
                // Save cleared state
                savePlayers();
                saveCrownsScores();
                saveYahtzeeData();
                savePhase10Data();
                saveGenericGridData();
                localStorage.setItem('scorekeeper_current_crowns_round', JSON.stringify(currentCrownsRound));
                localStorage.removeItem('scorekeeper_asked_gametype'); // Allow game type to be asked again
                localStorage.setItem('scorekeeper_gametype', 'general'); // Reset to general
                
                // Reset game type selector
                const gameTypeSelect = document.getElementById('gameType');
                if (gameTypeSelect) {
                    gameTypeSelect.value = 'general';
                }
                const selectedGameType = document.getElementById('selectedGameType');
                if (selectedGameType) {
                    selectedGameType.textContent = 'Select a Game';
                }
                
                // Clear all input fields and reset to initial 4 fields
                const container = document.getElementById('playerInputsContainer');
                container.innerHTML = `
                    <div class="player-inputs-row">
                        <input type="text" id="playerNameInput1" placeholder="Player 1" maxlength="20">
                        <input type="text" id="playerNameInput2" placeholder="Player 2" maxlength="20">
                    </div>
                    <div class="player-inputs-row">
                        <input type="text" id="playerNameInput3" placeholder="Player 3" maxlength="20">
                        <input type="text" id="playerNameInput4" placeholder="Player 4" maxlength="20">
                    </div>
                `;
                
                // Re-add Enter key listeners to initial fields
                ['playerNameInput1', 'playerNameInput2', 'playerNameInput3', 'playerNameInput4'].forEach(function(id) {
                    const input = document.getElementById(id);
                    if (input) {
                        input.addEventListener('keypress', function(e) {
                            if (e.key === 'Enter') {
                                addMorePlayerFields();
                            }
                        });
                    }
                });
                
                // Show the add player section
                document.getElementById('addPlayerSection').style.display = 'flex';
                
                // Switch back to scorekeeper tab
                currentTab = 'scorekeeper';
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById('scorekeeperTab').classList.add('active');
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-btn')[0].classList.add('active'); // First tab button
                
                // Switch to standard mode since we have no players
                scoringMode = 'generic';
                document.getElementById('standardMode').style.display = 'block';
                document.getElementById('crownsMode').classList.remove('active');
                if (document.getElementById('golfMode')) {
                    document.getElementById('golfMode').classList.remove('active');
                }
                if (document.getElementById('scrabbleMode')) {
                    document.getElementById('scrabbleMode').classList.remove('active');
                }
                if (document.getElementById('yahtzeeMode')) {
                    document.getElementById('yahtzeeMode').classList.remove('active');
                }
                if (document.getElementById('phase10Mode')) {
                    document.getElementById('phase10Mode').classList.remove('active');
                }
                if (document.getElementById('genericGridMode')) {
                    document.getElementById('genericGridMode').classList.remove('active');
                }
                
                // Hide Darts interface
                const gameArea = document.getElementById('gameArea');
                if (gameArea) gameArea.style.display = 'none';
                const darts501Container = document.getElementById('darts501Container');
                if (darts501Container) darts501Container.style.display = 'none';
                
                // Clear Darts keypad and action buttons
                const keypadContainer = document.getElementById('keypadContainer');
                if (keypadContainer) keypadContainer.innerHTML = '';
                const actionButtonsContainer = document.getElementById('actionButtonsContainer');
                if (actionButtonsContainer) actionButtonsContainer.innerHTML = '';
                
                // Clear grid tables
                const crownsTable = document.getElementById('crownsTable');
                if (crownsTable) {
                    crownsTable.innerHTML = '';
                }
                const golfTable = document.getElementById('golfTable');
                if (golfTable) {
                    golfTable.innerHTML = '';
                }
                const scrabbleTable = document.getElementById('scrabbleTable');
                if (scrabbleTable) {
                    scrabbleTable.innerHTML = '';
                }
                const yahtzeeTable = document.getElementById('yahtzeeTable');
                if (yahtzeeTable) {
                    yahtzeeTable.innerHTML = '';
                }
                const phase10Table = document.getElementById('phase10Table');
                if (phase10Table) {
                    phase10Table.innerHTML = '';
                }
                const genericGridTable = document.getElementById('genericGridTable');
                if (genericGridTable) {
                    genericGridTable.innerHTML = '';
                }
                
                // Update game state button to green "Start"
                updateGameStateButton();
                
                // Render empty state (instructions panel)
                
                
                // Call changeGameType to ensure UI is properly set for 'general' mode
                changeGameType();
                
                console.log(' Reset All completed successfully');
                // Show feedback
                showVoiceFeedback('Reset complete! Add players to start.', '');
                setTimeout(hideVoiceFeedback, 2000);
            } else {
                console.log(' User cancelled Reset All');
            }
        }
        // renderPlayers function removed - old +/- scoring interface no longer used
        // editPlayerName function removed with old player interface
        // editScore function removed with old player interface
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ===== CUSTOM GAME TRACKING FUNCTIONS =====
        
        function openCustomGameTrackingModal() {
            // Close main page game type dropdown
            const gameTypeDropdown = document.getElementById('gameTypeDropdown');
            const gameTypeDropdownList = document.getElementById('gameTypeDropdownList');
            if (gameTypeDropdown) gameTypeDropdown.classList.remove('open');
            if (gameTypeDropdownList) gameTypeDropdownList.classList.remove('open');

            // Close hamburger menu
            const sideMenu = document.getElementById('sideMenu');
            const menuOverlay = document.getElementById('menuOverlay');
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            if (sideMenu) { sideMenu.classList.remove('active'); sideMenu.style.overflowY = 'auto'; }
            if (menuOverlay) menuOverlay.classList.remove('active');
            if (hamburgerBtn) hamburgerBtn.classList.remove('active');

            // Close wins tracker dropdown
            const winsDropdown = document.getElementById('winsTrackerDropdown');
            const winsDropdownList = document.getElementById('winsTrackerDropdownList');
            if (winsDropdown) winsDropdown.classList.remove('open');
            if (winsDropdownList) winsDropdownList.classList.remove('open');
            
            // Reset form
            resetCustomGameForm();
            
            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('customGameDate').value = today;
            
            // Show modal
            document.getElementById('customGameTrackingModal').classList.add('show');
        }
        
        function closeCustomGameTrackingModal() {
            document.getElementById('customGameTrackingModal').classList.remove('show');
            resetCustomGameForm();
        }
        
        function resetCustomGameForm() {
            // Clear all inputs
            document.getElementById('customGameType').value = '';
            document.getElementById('customGameDate').value = '';
            
            // Reset players container to initial 2 players
            const container = document.getElementById('customGamePlayersContainer');
            container.innerHTML = `
                <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <input type="text" class="custom-player-input" placeholder="Player 1" maxlength="20" 
                           style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                    <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                           style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <input type="text" class="custom-player-input" placeholder="Player 2" maxlength="20" 
                           style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                    <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                           style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                </div>
            `;
            
            // Clear winner dropdown
            const winnerSelect = document.getElementById('customGameWinner');
            winnerSelect.innerHTML = '<option value="">Select Winner</option>';
            
            // Add event listeners for updating winner dropdown
            updateCustomGameWinnerOptions();
        }
        
        function addCustomGamePlayer() {
            const container = document.getElementById('customGamePlayersContainer');
            const playerCount = container.children.length;
            
            // Maximum 8 players
            if (playerCount >= 8) {
                customAlert('Maximum 8 players allowed.', ' Player Limit');
                return;
            }
            
            const newPlayerDiv = document.createElement('div');
            newPlayerDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: center;';
            newPlayerDiv.innerHTML = `
                <input type="text" class="custom-player-input" placeholder="Player ${playerCount + 1}" maxlength="20" 
                       style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                       style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                <button class="delete-btn" onclick="removeCustomGamePlayer(this)" style="width: 36px; height: 36px; font-size: 1.2rem;"></button>
            `;
            
            container.appendChild(newPlayerDiv);
            
            // Add event listeners to new inputs
            const nameInput = newPlayerDiv.querySelector('.custom-player-input');
            nameInput.addEventListener('input', updateCustomGameWinnerOptions);
            
            updateCustomGameWinnerOptions();
        }
        
        function removeCustomGamePlayer(button) {
            button.parentElement.remove();
            updateCustomGameWinnerOptions();
        }
        
        function updateCustomGameWinnerOptions() {
            const winnerSelect = document.getElementById('customGameWinner');
            const currentWinner = winnerSelect.value;
            
            // Clear existing options
            winnerSelect.innerHTML = '<option value="">Select Winner</option>';
            
            // Get all player name inputs
            const nameInputs = document.querySelectorAll('.custom-player-input');
            nameInputs.forEach((input, index) => {
                const playerName = input.value.trim();
                if (playerName) {
                    const option = document.createElement('option');
                    option.value = playerName;
                    option.textContent = playerName;
                    if (playerName === currentWinner) {
                        option.selected = true;
                    }
                    winnerSelect.appendChild(option);
                }
            });
        }
        
        async function saveCustomGame() {
            // Validate inputs
            const gameTypeRaw = document.getElementById('customGameType').value.trim();
            const gameDate = document.getElementById('customGameDate').value;
            const winnerRaw = document.getElementById('customGameWinner').value;
            
            // Normalize game type and winner
            const gameType = normalizeGameType(gameTypeRaw);
            const winner = normalizePlayerName(winnerRaw);
            
            if (!gameType) {
                customAlert('Please enter a game type.', ' Missing Information');
                return;
            }
            
            if (!gameDate) {
                customAlert('Please select a date.', ' Missing Information');
                return;
            }
            
            // Get players and scores
            const nameInputs = document.querySelectorAll('.custom-player-input');
            const scoreInputs = document.querySelectorAll('.custom-player-score');
            const players = [];
            
            for (let i = 0; i < nameInputs.length; i++) {
                const nameRaw = nameInputs[i].value.trim();
                const score = scoreInputs[i].value.trim();
                
                if (nameRaw) {
                    const normalizedName = normalizePlayerName(nameRaw);
                    players.push({
                        name: normalizedName,
                        score: score ? parseInt(score) : 0
                    });
                }
            }
            
            if (players.length < 2) {
                customAlert('Please enter at least 2 players.', ' Missing Information');
                return;
            }
            
            if (!winner) {
                customAlert('Please select a winner.', ' Missing Information');
                return;
            }
            
            // Check if winner is in player list
            if (!players.some(p => p.name === winner)) {
                customAlert('Winner must be one of the players.', ' Invalid Winner');
                return;
            }
            
            // Create custom game record
            const customGame = {
                gameType: gameType,
                date: gameDate,
                players: players,
                winner: winner,
                timestamp: Date.now()
            };
            
            // Save to localStorage
            saveCustomGameRecord(customGame);
            
            // Update wins tracking for all players
            players.forEach(player => {
                const isWinner = player.name === winner;
                updatePlayerWins(player.name, gameType.toLowerCase().replace(/\s+/g, ''), isWinner);
            });
            
            // Show success message and close modal
            await customAlert(`${gameType} game saved successfully!\n\nWinner: ${winner}`, ' Game Saved');
            closeCustomGameTrackingModal();
        }
        
        function saveCustomGameRecord(customGame) {
            // Get existing custom games
            const existingGames = JSON.parse(localStorage.getItem('scorekeeper_custom_games') || '[]');
            
            // Add new game
            existingGames.push(customGame);
            
            // Save back to localStorage
            localStorage.setItem('scorekeeper_custom_games', JSON.stringify(existingGames));
        }
        
        function loadCustomGameRecords() {
            return JSON.parse(localStorage.getItem('scorekeeper_custom_games') || '[]');
        }
        
        function openCustomGamesViewer() {
            // Close hamburger menu first
            const sideMenu = document.getElementById('sideMenu');
            const menuOverlay = document.getElementById('menuOverlay');
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            
            if (sideMenu) sideMenu.classList.remove('open');
            if (menuOverlay) menuOverlay.classList.remove('show');
            if (hamburgerBtn) hamburgerBtn.classList.remove('active');
            
            // Close wins tracker dropdown properly
            const winsDropdown = document.getElementById('winsTrackerDropdown');
            const winsDropdownList = document.getElementById('winsTrackerDropdownList');
            if (winsDropdown) winsDropdown.classList.remove('open');
            if (winsDropdownList) winsDropdownList.classList.remove('open');
            
            // Display custom games
            displayCustomGames();
            
            // Show modal
            document.getElementById('customGamesViewerModal').classList.add('show');
        }
        
        function closeCustomGamesViewer() {
            document.getElementById('customGamesViewerModal').classList.remove('show');
        }
        
        function displayCustomGames() {
            const customGames = loadCustomGameRecords();
            const container = document.getElementById('customGamesDisplay');
            
            if (customGames.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-dim);">
                        <div style="font-size: 2rem; margin-bottom: 15px;"></div>
                        <div style="font-weight: 700; margin-bottom: 10px; color: var(--text-primary);">No Custom Games Yet</div>
                        <div style="font-size: 0.95rem; line-height: 1.4;">
                            Track games that don't have dedicated scoring grids.<br>
                            Perfect for Cribbage, Chess, StarCraft, and more!
                        </div>
                    </div>
                `;
                return;
            }
            
            // Get unique game types with game count (using normalized game types)
            const gameTypeMap = new Map();
            customGames.forEach(game => {
                const normalizedGameType = normalizeGameType(game.gameType);
                if (!gameTypeMap.has(normalizedGameType)) {
                    gameTypeMap.set(normalizedGameType, {
                        name: normalizedGameType,
                        count: 0,
                        latestDate: game.timestamp
                    });
                }
                gameTypeMap.get(normalizedGameType).count++;
                // Update latest date if this game is more recent
                if (game.timestamp > gameTypeMap.get(normalizedGameType).latestDate) {
                    gameTypeMap.get(normalizedGameType).latestDate = game.timestamp;
                }
            });
            
            // Convert to array and sort by latest date (most recently played first)
            const gameTypes = Array.from(gameTypeMap.values()).sort((a, b) => b.latestDate - a.latestDate);
            
            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            
            gameTypes.forEach(gameType => {
                const pluralGames = gameType.count === 1 ? 'game' : 'games';
                
                html += `
                    <div onclick="openCustomGameStatistics('${escapeHtml(gameType.name)}')" 
                         style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 18px; border-left: 4px solid var(--neon-blue); cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: space-between; align-items: center;"
                         onmouseover="this.style.background='rgba(255,255,255,0.1)'"
                         onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                        <div>
                            <div style="font-weight: 700; color: #000000; font-size: 1.2rem; margin-bottom: 5px;">${escapeHtml(gameType.name)}</div>
                            <div style="font-size: 0.85rem; color: #666666;">${gameType.count} ${pluralGames} tracked</div>
                        </div>
                        <div style="color: #666666; font-size: 1.2rem;"></div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        async function deleteCustomGame(index) {
            const customGames = loadCustomGameRecords();
            const game = customGames[index];
            
            if (!game) return;
            
            const confirmed = await customConfirm(
                `Delete ${game.gameType} game from ${new Date(game.timestamp).toLocaleDateString()}?\n\nThis will also remove it from win tracking statistics.`,
                ' Delete Custom Game'
            );
            
            if (confirmed) {
                // Remove from custom games array
                customGames.splice(index, 1);
                localStorage.setItem('scorekeeper_custom_games', JSON.stringify(customGames));
                
                // Remove from win tracking stats
                game.players.forEach(player => {
                    const gameTypeKey = game.gameType.toLowerCase().replace(/\s+/g, '');
                    const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
                    
                    if (winsData[gameTypeKey] && winsData[gameTypeKey][player.name]) {
                        const stats = winsData[gameTypeKey][player.name];
                        
                        // Decrease played count
                        if (stats.played > 0) {
                            stats.played--;
                        }
                        
                        // Decrease wins count if this player was the winner
                        if (player.name === game.winner && stats.wins > 0) {
                            stats.wins--;
                        }
                        
                        // Remove player entry if no games left
                        if (stats.played === 0) {
                            delete winsData[gameTypeKey][player.name];
                        }
                        
                        // Remove game type if no players left
                        if (Object.keys(winsData[gameTypeKey]).length === 0) {
                            delete winsData[gameTypeKey];
                        }
                    }
                    
                    localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
                });
                
                // Refresh display
                displayCustomGames();
                
                await customAlert('Custom game deleted successfully.', ' Game Deleted');
            }
        }
        
        function openCustomGameStatistics(gameType) {
            // Close Custom Games viewer
            closeCustomGamesViewer();
            
            // Set modal title
            document.getElementById('customGameStatisticsTitle').textContent = `${gameType} Statistics`;
            
            // Display statistics
            displayCustomGameStatistics(gameType);
            
            // Show modal
            document.getElementById('customGameStatisticsModal').classList.add('show');
        }
        
        function closeCustomGameStatistics() {
            document.getElementById('customGameStatisticsModal').classList.remove('show');
        }
        
        function displayCustomGameStatistics(gameType) {
            const container = document.getElementById('customGameStatisticsDisplay');
            const customGames = loadCustomGameRecords();
            
            // Filter games for this specific game type
            const gameTypeGames = customGames.filter(game => game.gameType === gameType);
            
            if (gameTypeGames.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-dim);">
                        <div style="font-size: 2rem; margin-bottom: 15px;"></div>
                        <div style="font-weight: 700; margin-bottom: 10px; color: var(--text-primary);">No ${gameType} Games Found</div>
                        <div style="font-size: 0.95rem;">No statistics available for this game type.</div>
                    </div>
                `;
                return;
            }
            
            // Calculate player statistics
            const playerStats = new Map();
            
            gameTypeGames.forEach(game => {
                game.players.forEach(player => {
                    if (!playerStats.has(player.name)) {
                        playerStats.set(player.name, { played: 0, wins: 0 });
                    }
                    
                    const stats = playerStats.get(player.name);
                    stats.played++;
                    
                    if (player.name === game.winner) {
                        stats.wins++;
                    }
                });
            });
            
            // Convert to array and sort by win percentage (highest first)
            const sortedPlayers = Array.from(playerStats.entries()).map(([name, stats]) => ({
                name,
                played: stats.played,
                wins: stats.wins,
                percentage: stats.played > 0 ? ((stats.wins / stats.played) * 100).toFixed(1) : '0.0'
            })).sort((a, b) => {
                const aPercent = parseFloat(a.percentage);
                const bPercent = parseFloat(b.percentage);
                return bPercent - aPercent;
            });
            
            // Build HTML
            let html = `
                <div style="margin-bottom: 20px;">
                    <table class="crowns-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th style="text-align: left; width: 100px;">Player</th>
                                <th style="width: 60px; padding: 4px 8px;">Played</th>
                                <th style="width: 50px; padding: 4px 8px;">Wins</th>
                                <th style="width: 45px; padding: 4px 2px;">%</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            sortedPlayers.forEach(player => {
                html += `
                    <tr>
                        <td style="text-align: left;">
                            <input type="text" value="${escapeHtml(player.name)}" 
                                   class="wins-tracker-input" 
                                   onchange="updateCustomGamePlayerName('${escapeHtml(gameType)}', '${escapeHtml(player.name)}', this.value)"
                                   style="width: 100%; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                        </td>
                        <td style="padding: 4px 8px;">
                            <input type="number" value="${player.played}" 
                                   class="wins-tracker-input" 
                                   inputmode="numeric"
                                   onchange="updateCustomGameStat('${escapeHtml(gameType)}', '${escapeHtml(player.name)}', 'played', this.value)"
                                   style="width: 44px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                        </td>
                        <td style="padding: 4px 8px;">
                            <input type="number" value="${player.wins}" 
                                   class="wins-tracker-input" 
                                   inputmode="numeric"
                                   onchange="updateCustomGameStat('${escapeHtml(gameType)}', '${escapeHtml(player.name)}', 'wins', this.value)"
                                   style="width: 34px; text-align: center; background: transparent; border: 1px solid transparent; color: var(--text-primary); padding: 4px 4px; font-family: Outfit, sans-serif; font-weight: 600;">
                        </td>
                        <td style="font-weight: 700; color: var(--neon-blue); padding: 4px 2px; text-align: center;">${player.percentage}%</td>
                        <td style="text-align: center;">
                            <button class="delete-btn" onclick="deleteCustomGamePlayerStats('${escapeHtml(gameType)}', '${escapeHtml(player.name)}')" style="width: 36px; height: 36px; font-size: 1.2rem;"></button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        async function deleteCustomGamePlayerStats(gameType, playerName) {
            const confirmed = await customConfirm(
                `Delete all ${gameType} games for ${playerName}?\n\nThis will permanently remove their statistics and game records.`,
                ' Delete Player Stats'
            );
            
            if (confirmed) {
                // Get all custom games
                const customGames = loadCustomGameRecords();
                
                // Filter out games where this player participated in this game type
                const filteredGames = customGames.filter(game => 
                    !(game.gameType === gameType && game.players.some(p => p.name === playerName))
                );
                
                // Save filtered games back
                localStorage.setItem('scorekeeper_custom_games', JSON.stringify(filteredGames));
                
                // Update wins tracking
                const gameTypeKey = gameType.toLowerCase().replace(/\s+/g, '');
                const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
                
                if (winsData[gameTypeKey] && winsData[gameTypeKey][playerName]) {
                    delete winsData[gameTypeKey][playerName];
                    
                    // Remove game type if no players left
                    if (Object.keys(winsData[gameTypeKey]).length === 0) {
                        delete winsData[gameTypeKey];
                    }
                    
                    localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
                }
                
                // Refresh display
                displayCustomGameStatistics(gameType);
                
                await customAlert(`${playerName}'s ${gameType} statistics deleted successfully.`, ' Player Stats Deleted');
            }
        }
        
        function normalizeGameType(gameType) {
            // Normalize game type: trim, capitalize first letter of each word, remove extra punctuation
            return gameType.trim()
                .toLowerCase()
                .replace(/[^\w\s]/g, '') // Remove punctuation except letters, numbers, spaces
                .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function normalizePlayerName(playerName) {
            // Normalize player name: trim and capitalize first letter of each word
            return playerName.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function updateCustomGamePlayerName(gameType, oldPlayerName, newPlayerName) {
            const normalizedNewName = normalizePlayerName(newPlayerName);
            
            if (!normalizedNewName || normalizedNewName === oldPlayerName) {
                return; // No change needed
            }
            
            // Get all custom games
            const customGames = loadCustomGameRecords();
            let gamesUpdated = 0;
            
            // Update player names in games of this type
            customGames.forEach(game => {
                if (game.gameType === gameType) {
                    // Update in players array
                    game.players.forEach(player => {
                        if (player.name === oldPlayerName) {
                            player.name = normalizedNewName;
                            gamesUpdated++;
                        }
                    });
                    
                    // Update winner if it matches
                    if (game.winner === oldPlayerName) {
                        game.winner = normalizedNewName;
                    }
                }
            });
            
            // Save updated games
            localStorage.setItem('scorekeeper_custom_games', JSON.stringify(customGames));
            
            // Update wins tracking data
            const gameTypeKey = gameType.toLowerCase().replace(/\s+/g, '');
            const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
            
            if (winsData[gameTypeKey] && winsData[gameTypeKey][oldPlayerName]) {
                // Move data from old name to new name
                winsData[gameTypeKey][normalizedNewName] = winsData[gameTypeKey][oldPlayerName];
                delete winsData[gameTypeKey][oldPlayerName];
                localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
            }
            
            // Refresh display
            displayCustomGameStatistics(gameType);
        }
        
        function updateCustomGameStat(gameType, playerName, statType, newValue) {
            const value = parseInt(newValue) || 0;
            
            if (value < 0) return; // Don't allow negative values
            
            const gameTypeKey = gameType.toLowerCase().replace(/\s+/g, '');
            const winsData = JSON.parse(localStorage.getItem('scorekeeper_wins') || '{}');
            
            // Ensure structure exists
            if (!winsData[gameTypeKey]) winsData[gameTypeKey] = {};
            if (!winsData[gameTypeKey][playerName]) winsData[gameTypeKey][playerName] = { played: 0, wins: 0 };
            
            // Update the stat
            winsData[gameTypeKey][playerName][statType] = value;
            
            // If wins > played, adjust played to match wins
            if (statType === 'wins' && value > winsData[gameTypeKey][playerName].played) {
                winsData[gameTypeKey][playerName].played = value;
            }
            
            // If played < wins, adjust wins to match played
            if (statType === 'played' && value < winsData[gameTypeKey][playerName].wins) {
                winsData[gameTypeKey][playerName].wins = value;
            }
            
            // Save updated data
            localStorage.setItem('scorekeeper_wins', JSON.stringify(winsData));
            
            // Refresh display to show updated percentages
            displayCustomGameStatistics(gameType);
        }
        
        function initializeCustomGameTracking() {
            // Add event delegation for custom player inputs
            document.addEventListener('input', function(e) {
                if (e.target.classList && e.target.classList.contains('custom-player-input')) {
                    updateCustomGameWinnerOptions();
                }
            });
        }
        
        // Allow Enter key to add more player fields from any input field
        ['playerNameInput1', 'playerNameInput2', 'playerNameInput3', 'playerNameInput4'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        addMorePlayerFields();
                    }
                });
            }
        });
        // ===== TIMER FUNCTIONS (global scope for onclick access) =====
        function toggleTimerDropdown() {
            const dd = document.getElementById('timerDropdown');
            const list = document.getElementById('timerDropdownList');
            if (!dd || !list) return;
            const isOpen = dd.classList.contains('open');
            if (isOpen) {
                dd.classList.remove('open');
                list.classList.remove('open');
            } else {
                dd.classList.add('open');
                list.classList.add('open');
            }
        }
        function openInNewTab() {
            // Close hamburger menu first
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            const hamburger = document.getElementById('hamburgerBtn');
            if (menu) menu.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
            if (hamburger) hamburger.classList.remove('active');
            // Grab the full HTML and open as a blob in a new tab
            const html = document.documentElement.outerHTML;
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
        }
        function openTimer(type) {
            // Close the timer dropdown cleanly
            const dd = document.getElementById('timerDropdown');
            const list = document.getElementById('timerDropdownList');
            if (dd) dd.classList.remove('open');
            if (list) list.classList.remove('open');
            document.getElementById('selectedTimer').textContent = 'Select a Timer';
            // Close hamburger menu using correct IDs and classes
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            const hamburger = document.getElementById('hamburgerBtn');
            if (menu) menu.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
            if (hamburger) hamburger.classList.remove('active');
            // Open the right modal
            if (type === 'sand') { document.getElementById('sandTimerModal').style.display = 'flex'; sandTimerReset(); }
            else if (type === 'digital') { document.getElementById('digitalTimerModal').style.display = 'flex'; digitalTimerReset(); }
            else if (type === 'chess') { document.getElementById('chessTimerModal').style.display = 'flex'; chessTimerReset(); }
        }
        function closeTimer(type) {
            // Reset dropdown state so it works again after reopening menu
            const dd = document.getElementById('timerDropdown');
            const list = document.getElementById('timerDropdownList');
            if (dd) dd.classList.remove('open');
            if (list) list.classList.remove('open');
            if (type === 'sand') { sandTimerStop(); document.getElementById('sandTimerModal').style.display = 'none'; }
            else if (type === 'digital') { digitalTimerStop(); document.getElementById('digitalTimerModal').style.display = 'none'; }
            else if (type === 'chess') { chessTimerStop(); document.getElementById('chessTimerModal').style.display = 'none'; }
        }
        function fmtTime(secs) {
            const m = Math.floor(secs / 60), s = secs % 60;
            return m + ':' + String(s).padStart(2, '0');
        }
        // Sand Timer
        let sandTotal = 60, sandRemaining = 60, sandInterval = null, sandRunning = false;
        function setSandDuration(secs) {
            document.querySelectorAll('.sand-pill').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('sand-btn-' + secs);
            if (btn) btn.classList.add('active');
            sandTotal = secs; sandTimerReset();
        }
        function sandTimerAction() { sandRunning ? sandTimerPause() : sandTimerStart(); }
        function sandTimerStart() {
            if (sandRemaining <= 0) sandTimerReset();
            sandRunning = true;
            document.getElementById('sandStartBtn').textContent = 'Pause';
            document.getElementById('sandStartBtn').classList.add('paused');
            sandInterval = setInterval(() => { sandRemaining--; updateSandDisplay(); if (sandRemaining <= 0) sandTimerDone(); }, 1000);
        }
        function sandTimerPause() {
            sandRunning = false; clearInterval(sandInterval);
            document.getElementById('sandStartBtn').textContent = 'Resume';
            document.getElementById('sandStartBtn').classList.remove('paused');
        }
        function sandTimerStop() { sandRunning = false; clearInterval(sandInterval); }
        function sandTimerReset() {
            sandTimerStop(); sandRemaining = sandTotal;
            document.getElementById('sandStartBtn').textContent = 'Start';
            document.getElementById('sandStartBtn').classList.remove('paused', 'stopped');
            document.getElementById('sandTimerDisplay').textContent = fmtTime(sandTotal);
            document.getElementById('sandTimerDisplay').classList.remove('timer-urgent');
            updateSandDisplay();
        }
        function sandTimerDone() {
            sandTimerStop(); sandRemaining = 0;
            document.getElementById('sandStartBtn').textContent = 'Start';
            document.getElementById('sandStartBtn').classList.remove('paused');
            document.getElementById('sandStartBtn').classList.add('stopped');
            document.getElementById('sandTimerDisplay').textContent = '0:00';
            document.getElementById('sandTimerDisplay').classList.add('timer-urgent');
            updateSandSVG(0);
            playBeep(); setTimeout(playBeep, 350); setTimeout(playBeep, 700);
        }
        function updateSandDisplay() {
            document.getElementById('sandTimerDisplay').textContent = fmtTime(sandRemaining);
            const progress = sandTotal > 0 ? sandRemaining / sandTotal : 0;
            sandRemaining <= 10 && sandRemaining > 0
                ? document.getElementById('sandTimerDisplay').classList.add('timer-urgent')
                : document.getElementById('sandTimerDisplay').classList.remove('timer-urgent');
            updateSandSVG(progress);
        }
        function updateSandSVG(progress) {
            const topGroup = document.getElementById('topSandPixels');
            const botGroup = document.getElementById('bottomSandPixels');
            const stream   = document.getElementById('sandStream');
            const svg      = document.getElementById('sandHourglass');
            if (!topGroup || !botGroup || !svg) return;

            const isSteel = document.body.getAttribute('data-theme') === 'stainless';

            if (isSteel) {
                renderSteelHourglass(svg, topGroup, botGroup, stream, progress);
            } else {
                renderNeonHourglass(svg, topGroup, botGroup, stream, progress);
            }
        }

        function renderNeonHourglass(svg, topGroup, botGroup, stream, progress) {
            // Ensure neon SVG structure is present
            if (!svg.querySelector('#neonGlow')) {
                svg.setAttribute('viewBox', '0 0 200 320');
                svg.setAttribute('width', '200');
                svg.setAttribute('height', '280');
            }
            const px = 8, gap = 1, rows = 13, cx = 100;
            const topY0 = 42, topY1 = 148, botY0 = 172, botY1 = 278;
            function halfWidth(row, totalRows, topHalf) {
                const t = row / (totalRows - 1);
                const wide = 66, narrow = 8;
                return topHalf ? wide * (1-t) + narrow*t : narrow*(1-t) + wide*t;
            }
            function buildPixels(group, filled, totalRows, y0, y1, topHalf) {
                group.innerHTML = '';
                const rowH = (y1 - y0) / totalRows;
                for (let r = 0; r < totalRows; r++) {
                    const hw = halfWidth(r, totalRows, topHalf);
                    const numCols = Math.max(1, Math.floor(hw * 2 / (px + gap)));
                    const rowFilled = topHalf ? r < Math.ceil(filled * totalRows) : r >= Math.floor((1-filled) * totalRows);
                    if (!rowFilled) continue;
                    const totalW = numCols * px + (numCols - 1) * gap;
                    const startX = cx - totalW / 2;
                    const y = y0 + r * rowH + (rowH - px) / 2;
                    for (let c = 0; c < numCols; c++) {
                        const x = startX + c * (px + gap);
                        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
                        rect.setAttribute('x', x.toFixed(1)); rect.setAttribute('y', y.toFixed(1));
                        rect.setAttribute('width', px); rect.setAttribute('height', px); rect.setAttribute('rx','1.5');
                        const alpha = 0.55 + Math.random() * 0.35;
                        rect.setAttribute('fill', `rgba(0,229,255,${alpha.toFixed(2)})`);
                        group.appendChild(rect);
                    }
                }
            }
            buildPixels(topGroup, progress,       rows, topY0, topY1, true);
            buildPixels(botGroup, 1 - progress,   rows, botY0, botY1, false);
            if (stream) {
                stream.setAttribute('x','98'); stream.setAttribute('y','146');
                stream.setAttribute('width','4'); stream.setAttribute('height','28');
                stream.setAttribute('fill','#00e5ff');
                stream.style.opacity = (progress > 0.01 && sandRunning) ? '1' : '0';
            }
        }

        function renderSteelHourglass(svg, topGroup, botGroup, stream, progress) {
            // Rebuild SVG for organic steel look the first time
            svg.setAttribute('viewBox', '0 0 200 320');
            svg.setAttribute('width', '200');
            svg.setAttribute('height', '280');

            // Clear non-group children and rebuild frame if needed
            if (!svg.querySelector('.steel-frame')) {
                // Remove old neon elements
                [...svg.children].forEach(el => {
                    if (el.tagName === 'defs' || el.id === 'topSandPixels' || el.id === 'bottomSandPixels') return;
                    if (!el.classList.contains('steel-frame')) el.remove();
                });
                const ns = 'http://www.w3.org/2000/svg';

                // Organic hourglass path using cubic bezier curves
                // Top bulge: wide at cap, curves inward to narrow waist
                // Bottom bulge: mirrors top
                const framePath = document.createElementNS(ns, 'path');
                framePath.setAttribute('class', 'steel-frame');
                // Organic shape: cubic beziers for smooth curves
                framePath.setAttribute('d', [
                    'M 28,30',       // top-left cap
                    'L 172,30',      // top-right cap
                    'C 172,30 185,60 155,105',  // right side curves in
                    'C 135,135 115,148 100,155', // right narrows to waist
                    'C 85,148 65,135 45,105',   // left narrows to waist
                    'C 15,60 28,30 28,30 Z',    // left side back to start  top bulb done
                    // bottom bulb
                    'M 28,30',
                ].join(' '));
                // Use two separate paths for clarity
                const topBulb = document.createElementNS(ns, 'path');
                topBulb.setAttribute('class', 'steel-frame');
                topBulb.setAttribute('d', 'M 26,28 L 174,28 C 195,70 175,120 115,152 L 100,158 L 85,152 C 25,120 5,70 26,28 Z');
                topBulb.setAttribute('fill', 'url(#steelGlass)');
                topBulb.setAttribute('stroke', '#94a3b8');
                topBulb.setAttribute('stroke-width', '2');
                topBulb.setAttribute('stroke-linejoin', 'round');

                const botBulb = document.createElementNS(ns, 'path');
                botBulb.setAttribute('class', 'steel-frame');
                botBulb.setAttribute('d', 'M 26,292 L 174,292 C 195,250 175,200 115,168 L 100,162 L 85,168 C 25,200 5,250 26,292 Z');
                botBulb.setAttribute('fill', 'url(#steelGlass)');
                botBulb.setAttribute('stroke', '#94a3b8');
                botBulb.setAttribute('stroke-width', '2');
                botBulb.setAttribute('stroke-linejoin', 'round');

                // Highlight sheen on top bulb
                const sheen = document.createElementNS(ns, 'path');
                sheen.setAttribute('class', 'steel-frame');
                sheen.setAttribute('d', 'M 50,38 C 65,32 120,32 148,40 C 160,55 165,75 155,95 C 140,70 100,55 55,68 C 40,55 38,45 50,38 Z');
                sheen.setAttribute('fill', 'rgba(255,255,255,0.28)');
                sheen.setAttribute('stroke', 'none');

                // Caps (top + bottom)
                const topCap = document.createElementNS(ns, 'rect');
                topCap.setAttribute('class', 'steel-frame');
                topCap.setAttribute('x','20'); topCap.setAttribute('y','16');
                topCap.setAttribute('width','160'); topCap.setAttribute('height','24'); topCap.setAttribute('rx','8');
                topCap.setAttribute('fill', 'url(#steelCap)');
                topCap.setAttribute('stroke','#94a3b8'); topCap.setAttribute('stroke-width','1.5');

                const botCap = document.createElementNS(ns, 'rect');
                botCap.setAttribute('class', 'steel-frame');
                botCap.setAttribute('x','20'); botCap.setAttribute('y','280');
                botCap.setAttribute('width','160'); botCap.setAttribute('height','24'); botCap.setAttribute('rx','8');
                botCap.setAttribute('fill', 'url(#steelCap)');
                botCap.setAttribute('stroke','#94a3b8'); botCap.setAttribute('stroke-width','1.5');

                // Gradients in defs
                const defs = svg.querySelector('defs') || document.createElementNS(ns, 'defs');
                defs.innerHTML += `
                    <linearGradient id="steelGlass" x1="0" y1="0" x2="1" y2="1">
                        <stop offset="0%"   stop-color="#e8edf3" stop-opacity="0.7"/>
                        <stop offset="50%"  stop-color="#d0d8e4" stop-opacity="0.5"/>
                        <stop offset="100%" stop-color="#b8c4d0" stop-opacity="0.6"/>
                    </linearGradient>
                    <linearGradient id="steelCap" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%"   stop-color="#f0f4f8"/>
                        <stop offset="50%"  stop-color="#c8d0da"/>
                        <stop offset="100%" stop-color="#a0aab4"/>
                    </linearGradient>
                    <radialGradient id="steelBead" cx="35%" cy="32%" r="60%">
                        <stop offset="0%"   stop-color="#fff8dc"/>
                        <stop offset="40%"  stop-color="#d4a017"/>
                        <stop offset="75%"  stop-color="#a07810"/>
                        <stop offset="100%" stop-color="#6b5000"/>
                    </radialGradient>
                    <clipPath id="topSandClipS">
                        <path d="M 30,40 L 170,40 C 185,75 165,118 110,150 L 90,150 C 35,118 15,75 30,40 Z"/>
                    </clipPath>
                    <clipPath id="bottomSandClipS">
                        <path d="M 90,170 L 110,170 C 165,202 185,245 170,280 L 30,280 C 15,245 35,202 90,170 Z"/>
                    </clipPath>
                `;
                if (!svg.querySelector('defs')) svg.insertBefore(defs, svg.firstChild);

                // Update clip paths on groups
                topGroup.setAttribute('clip-path', 'url(#topSandClipS)');
                botGroup.setAttribute('clip-path', 'url(#bottomSandClipS)');

                // Insert frame elements below the sand groups
                svg.insertBefore(botBulb,  topGroup);
                svg.insertBefore(topBulb,  topGroup);
                svg.insertBefore(sheen,    topGroup.nextSibling.nextSibling || null);
                svg.insertBefore(topCap,   topGroup);
                svg.insertBefore(botCap,   topGroup);
            }

            // Draw silver bead sand
            const topY0=40, topY1=150, botY0=170, botY1=280, cx=100;

            function buildSteelSand(group, filled, y0, y1, topHalf) {
                group.innerHTML = '';
                if (filled <= 0.01) return;
                const ns2 = 'http://www.w3.org/2000/svg';
                const r = 5.5; // bead radius
                const spacing = r * 2 + 1.5; // center-to-center
                const rows = Math.floor((y1 - y0) / spacing);
                const cx = 100;

                for (let row = 0; row < rows; row++) {
                    const t = row / (rows - 1 || 1);
                    // Organic half-width following the bulb curve
                    const hw = topHalf
                        ? 70 * Math.pow(1 - t, 0.6) + 6
                        : 70 * Math.pow(t, 0.6) + 6;

                    const rowFilled = topHalf
                        ? row < Math.ceil(filled * rows)
                        : row >= Math.floor((1 - filled) * rows);
                    if (!rowFilled) continue;

                    const y = topHalf
                        ? y0 + row * spacing + r
                        : y1 - (rows - row) * spacing + r;

                    // Stagger alternate rows for natural bead packing
                    const stagger = (row % 2 === 0) ? 0 : r;
                    const colSpacing = r * 2 + 2;
                    const numBeads = Math.max(1, Math.floor((hw * 2 - r) / colSpacing));
                    const totalW = (numBeads - 1) * colSpacing;
                    const startX = cx - totalW / 2 + stagger * 0.5;

                    for (let col = 0; col < numBeads; col++) {
                        const bx = startX + col * colSpacing;
                        // Clip beads that fall outside the organic bulb
                        if (Math.abs(bx - cx) > hw - r * 0.5) continue;

                        const beadId = `sb-${row}-${col}`;

                        // Bead circle
                        const circle = document.createElementNS(ns2, 'circle');
                        circle.setAttribute('cx', bx.toFixed(1));
                        circle.setAttribute('cy', y.toFixed(1));
                        circle.setAttribute('r', r);
                        circle.setAttribute('fill', `url(#steelBead)`);
                        circle.setAttribute('stroke', 'rgba(80,90,100,0.25)');
                        circle.setAttribute('stroke-width', '0.5');
                        group.appendChild(circle);

                        // Specular highlight dot
                        const hl = document.createElementNS(ns2, 'circle');
                        hl.setAttribute('cx', (bx - r * 0.3).toFixed(1));
                        hl.setAttribute('cy', (y - r * 0.35).toFixed(1));
                        hl.setAttribute('r', (r * 0.32).toFixed(1));
                        hl.setAttribute('fill', 'rgba(255,255,255,0.75)');
                        group.appendChild(hl);
                    }
                }
            }

            buildSteelSand(topGroup, progress,     topY0, topY1, true);
            buildSteelSand(botGroup, 1 - progress, botY0, botY1, false);

            // Steel stream: falling silver bead trickle
            if (stream) {
                stream.setAttribute('x','97'); stream.setAttribute('y','150');
                stream.setAttribute('width','6'); stream.setAttribute('height','22');
                stream.setAttribute('rx','3');
                stream.setAttribute('fill','url(#steelBead)');
                stream.setAttribute('stroke','rgba(80,90,100,0.3)');
                stream.setAttribute('stroke-width','0.5');
                stream.removeAttribute('filter');
                stream.style.opacity = (progress > 0.01 && sandRunning) ? '1' : '0';
            }
        }
        // Digital Timer
        let digitalMins = 1, digitalSecs = 0, digitalTotal = 60, digitalRemaining = 60, digitalInterval = null, digitalRunning = false;
        function adjustDigital(unit, delta) {
            if (unit === 'min') { digitalMins = Math.max(0, Math.min(99, digitalMins + delta)); }
            else { digitalSecs = Math.max(0, Math.min(45, digitalSecs + (delta > 0 ? 15 : -15))); }
            document.getElementById('digitalMinDisplay').textContent = String(digitalMins).padStart(2, '0');
            document.getElementById('digitalSecDisplay').textContent = String(digitalSecs).padStart(2, '0');
        }
        function digitalTimerAction() { digitalRunning ? digitalTimerPause() : digitalTimerStart(); }
        function digitalTimerStart() {
            digitalTotal = digitalMins * 60 + digitalSecs;
            if (digitalTotal === 0) return;
            digitalRemaining = digitalTotal;
            document.getElementById('digitalSetControls').style.display = 'none';
            document.getElementById('digitalTimerDisplay').style.display = 'block';
            digitalRunning = true;
            document.getElementById('digitalStartBtn').textContent = 'Pause';
            document.getElementById('digitalStartBtn').classList.add('paused');
            document.getElementById('digitalTimerStatus').textContent = 'Running';
            document.getElementById('digitalTimerDisplay').textContent = fmtTime(digitalRemaining);
            digitalInterval = setInterval(() => {
                digitalRemaining--;
                document.getElementById('digitalTimerDisplay').textContent = fmtTime(digitalRemaining);
                if (digitalRemaining <= 10 && digitalRemaining > 0) document.getElementById('digitalTimerDisplay').classList.add('timer-urgent');
                if (digitalRemaining <= 0) digitalTimerDone();
            }, 1000);
        }
        function digitalTimerPause() {
            digitalRunning = false; clearInterval(digitalInterval);
            document.getElementById('digitalStartBtn').textContent = 'Resume';
            document.getElementById('digitalStartBtn').classList.remove('paused');
            document.getElementById('digitalTimerStatus').textContent = 'Paused';
        }
        function digitalTimerStop() { digitalRunning = false; clearInterval(digitalInterval); }
        function digitalTimerReset() {
            digitalTimerStop(); digitalMins = 1; digitalSecs = 0; digitalRemaining = 60;
            document.getElementById('digitalMinDisplay').textContent = '01';
            document.getElementById('digitalSecDisplay').textContent = '00';
            document.getElementById('digitalSetControls').style.display = 'flex';
            document.getElementById('digitalTimerDisplay').style.display = 'none';
            document.getElementById('digitalTimerDisplay').classList.remove('timer-urgent');
            document.getElementById('digitalStartBtn').textContent = 'Start';
            document.getElementById('digitalStartBtn').classList.remove('paused', 'stopped');
            document.getElementById('digitalTimerStatus').textContent = 'Set time above';
        }
        function digitalTimerDone() {
            digitalTimerStop();
            document.getElementById('digitalTimerDisplay').textContent = '0:00';
            document.getElementById('digitalTimerDisplay').classList.add('timer-urgent');
            document.getElementById('digitalStartBtn').textContent = 'Start';
            document.getElementById('digitalStartBtn').classList.remove('paused');
            document.getElementById('digitalStartBtn').classList.add('stopped');
            document.getElementById('digitalTimerStatus').textContent = "Time's up!";
            playBeep(); setTimeout(playBeep, 350); setTimeout(playBeep, 700);
        }
        // Chess Clock
        let chessDuration = 180, chessTime1 = 180, chessTime2 = 180, chessActive = 0, chessInterval = null;
        function setChessDuration(secs) {
            document.querySelectorAll('.chess-durations .sand-duration-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('chess-btn-' + secs);
            if (btn) btn.classList.add('active');
            chessDuration = secs; chessTimerReset();
        }
        function chessPressClock(player) {
            if (chessActive === player) {
                chessActive = player === 1 ? 2 : 1; updateChessDisplay();
            } else if (chessActive === 0) {
                chessActive = player === 1 ? 2 : 1; startChessInterval(); updateChessDisplay();
            }
        }
        function startChessInterval() {
            clearInterval(chessInterval);
            chessInterval = setInterval(() => {
                if (chessActive === 1) chessTime1 = Math.max(0, chessTime1 - 1);
                if (chessActive === 2) chessTime2 = Math.max(0, chessTime2 - 1);
                updateChessDisplay();
                if ((chessActive === 1 && chessTime1 === 0) || (chessActive === 2 && chessTime2 === 0)) chessTimerDone(chessActive);
            }, 1000);
        }
        function updateChessDisplay() {
            document.getElementById('chessTime1').textContent = fmtTime(chessTime1);
            document.getElementById('chessTime2').textContent = fmtTime(chessTime2);
            document.getElementById('chessBlock1').classList.toggle('active-player', chessActive === 1);
            document.getElementById('chessBlock2').classList.toggle('active-player', chessActive === 2);
            document.getElementById('chessTime1').style.color = chessTime1 <= 10 && chessActive === 1 ? '#ff6b6b' : '';
            document.getElementById('chessTime2').style.color = chessTime2 <= 10 && chessActive === 2 ? '#ff6b6b' : '';
            document.getElementById('chessTimerStatus').textContent = chessActive === 0 ? 'Tap a player clock to start' : 'Tap your clock after your move';
        }
        function chessTimerDone(loser) {
            chessTimerStop();
            const winner = loser === 1 ? 2 : 1;
            document.getElementById('chessTimerStatus').textContent = `Player ${loser} ran out of time! Player ${winner} wins!`;
            document.getElementById('chessBlock' + loser).classList.add('out-of-time');
            document.getElementById('chessBlock' + loser).classList.remove('active-player');
            playBeep(); setTimeout(playBeep, 350); setTimeout(playBeep, 700);
        }
        function chessTimerStop() { clearInterval(chessInterval); chessActive = 0; }
        function chessTimerReset() {
            chessTimerStop(); chessTime1 = chessDuration; chessTime2 = chessDuration;
            document.getElementById('chessTime1').textContent = fmtTime(chessDuration);
            document.getElementById('chessTime2').textContent = fmtTime(chessDuration);
            document.getElementById('chessTime1').style.color = '';
            document.getElementById('chessTime2').style.color = '';
            document.getElementById('chessBlock1').classList.remove('active-player', 'out-of-time');
            document.getElementById('chessBlock2').classList.remove('active-player', 'out-of-time');
            document.getElementById('chessTimerStatus').textContent = 'Tap a player clock to start';
        }

        // Initialize on startup - wrap in DOMContentLoaded to ensure DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log(' Scorekeeper with Darts loaded successfully');
            console.log(' VERSION: 2026-02-12-FIX-v94 - Move Custom Game Tracking to Main Dropdown');
            initSpeechRecognition();
            loadPlayers();
            loadPlayerInputs(); // Load saved player input values
            loadTheme();
            loadSpeakerState(); // Load speaker mute state
            loadInputMode();
            loadGolfMode();
            loadGolfData();
            loadYahtzeeData();
            loadPhase10Data();
            loadGenericGridData();
            loadScrabbleData();
            
            // Initialize game state button
            updateGameStateButton(); // Ensure button shows correct text on page load
            
            // Initialize custom game tracking
            initializeCustomGameTracking();
            loadSavedGolfCourses();
            populateHamburgerScorecardDropdown(); // Load saved scorecards into hamburger menu dropdown
            
            // Add event listeners to save player inputs when they change
            ['playerNameInput1', 'playerNameInput2', 'playerNameInput3', 'playerNameInput4'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', savePlayerInputs);
                    input.addEventListener('blur', savePlayerInputs);
                }
            });
            
            // Add event listener for Scrabble word input to update button color
            const scrabbleWordInput = document.getElementById('scrabbleWordInput');
            if (scrabbleWordInput) {
                scrabbleWordInput.addEventListener('input', updateScrabbleCheckButton);
                scrabbleWordInput.addEventListener('keyup', updateScrabbleCheckButton);
                scrabbleWordInput.addEventListener('paste', function() {
                    // Handle paste events with slight delay
                    setTimeout(updateScrabbleCheckButton, 10);
                });
                // Initialize button state
                updateScrabbleCheckButton();
                console.log('Scrabble word input event listeners added and initialized');
            } else {
                console.log('scrabbleWordInput not found during DOMContentLoaded');
            }
            
            // Add beforeunload check to see if data persists
            window.addEventListener('beforeunload', function(e) {
                const saved = sessionStorage.getItem('scorekeeper_player_inputs');
                console.log('=== BEFORE UNLOAD ===');
                console.log('Player inputs in sessionStorage:', saved);
                console.log('All sessionStorage keys:', Object.keys(sessionStorage));
            });
            
            // Add pulse animation to Start button on initial load
            const gameStateBtn = document.getElementById('gameStateBtn');
            if (gameStateBtn && !gameInProgress) {
                gameStateBtn.classList.add('pulse');
            }
            
            // Match Start button width to instructions panel
            matchStartButtonWidth();
            
            // Add resize listener to keep button width matched
            window.addEventListener('resize', matchStartButtonWidth);
            
            // Set grid-mode class if players exist and done adding
            if (isDoneAdding && players.length > 0) {
                document.body.classList.add('grid-mode');
                
                // Move game-type-row into tab-navigation-container
                const gameTypeRow = document.querySelector('.game-type-row');
                const tabNavContainer = document.querySelector('.tab-navigation-container');
                if (gameTypeRow && tabNavContainer) {
                    tabNavContainer.insertBefore(gameTypeRow, tabNavContainer.firstChild);
                }
            }
            
            // Don't auto-start voice on page load - user must click "Start Voice Recognition"
            
            // Setup golf mode toggle event listener
            const golfModeToggle = document.getElementById('golfModeToggle');
            if (golfModeToggle) {
                golfModeToggle.addEventListener('change', function(e) {
                    toggleGolfMode();
                });
            }
            
            // Initialize generic grid data but don't display it on page load
            // (It will show when a game type is selected)
            initializeGenericGridScores();
            
            // Initialize the display for the default 'general' game type
            // This will show the instructions panel
            console.log('Initializing default game type display: general');
            changeGameType();
            
            // Ensure instructions are shown on initial load
            updateStandardModeDisplay();
            // Setup golf course dropdown event listener
            // NOTE: Using inline onclick instead of addEventListener due to event listener issues
            /*
            console.log('About to setup golf course dropdown event listener');
            const golfCourseDropdown = document.getElementById('golfCourseDropdown');
            console.log('golfCourseDropdown element:', golfCourseDropdown);
            if (golfCourseDropdown) {
                console.log('Golf course dropdown found, attaching event listener');
                golfCourseDropdown.addEventListener('click', function(e) {
                    console.log('Golf course dropdown clicked!');
                    e.preventDefault();
                    e.stopPropagation();
                    toggleGolfCourseDropdown();
                });
            } else {
                console.log('Golf course dropdown NOT found during DOMContentLoaded');
            }
            */
            
            // Setup game type dropdown event listener
            // NOTE: Using inline onclick instead of addEventListener
            /*
            const gameTypeDropdown = document.getElementById('gameTypeDropdown');
            if (gameTypeDropdown) {
                gameTypeDropdown.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleGameTypeDropdown();
                });
            }
            
            // Setup game type dropdown list items
            const gameTypeItems = document.querySelectorAll('.dropdown-list-item-game');
            gameTypeItems.forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const gameValue = this.getAttribute('data-value');
                    selectGameType(gameValue);
                });
            });
            */
            
            // Hamburger menu and overlay use inline onclick handlers
            // No additional event listeners needed
            // Setup modal background click handlers for closing
            const finalScoresModal = document.getElementById('finalScoresModal');
            if (finalScoresModal) {
                finalScoresModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeFinalScoresModal();
                    }
                });
            }
            const editCourseModal = document.getElementById('editCourseModal');
            if (editCourseModal) {
                editCourseModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeEditCourseModal();
                    }
                });
            }
        });
        // Close modals with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close custom alert if open
                const alertModal = document.getElementById('customAlertModal');
                if (alertModal && alertModal.classList.contains('show')) {
                    closeCustomAlert();
                    return;
                }
                // Close custom confirm if open
                const confirmModal = document.getElementById('customConfirmModal');
                if (confirmModal && confirmModal.classList.contains('show')) {
                    resolveCustomConfirm(false);
                    return;
                }
                // Close custom prompt if open
                const promptModal = document.getElementById('customPromptModal');
                if (promptModal && promptModal.classList.contains('show')) {
                    resolveCustomPrompt(null);
                    return;
                }
                // Close edit course modal if open
                const editCourseModal = document.getElementById('editCourseModal');
                if (editCourseModal && editCourseModal.classList.contains('show')) {
                    closeEditCourseModal();
                    return;
                }
                // Close final scores modal if open
                const finalModal = document.getElementById('finalScoresModal');
                if (finalModal && finalModal.classList.contains('show')) {
                    closeFinalScoresModal();
                    return;
                }
            }
        });
    </script>
    <!-- Custom Modal for Final Scores -->
    <div id="finalScoresModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title">Final Scores</div>
            <div id="finalScoresWinner" class="final-scores-winner"></div>
            <ol id="finalScoresList" class="final-scores-list"></ol>
            <button class="final-scores-ok-btn" onclick="closeFinalScoresModal()">OK</button>
        </div>
    </div>
    <!-- Custom Alert Modal -->
    <div id="customAlertModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="customAlertTitle">Alert</div>
            <div id="customAlertMessage" class="custom-dialog-message"></div>
            <button class="final-scores-ok-btn" onclick="closeCustomAlert()">OK</button>
        </div>
    </div>
    <!-- Custom Confirm Modal -->
    <div id="customConfirmModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="customConfirmTitle">Confirm</div>
            <div id="customConfirmMessage" class="custom-dialog-message"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveCustomConfirm(false)">Cancel</button>
                <button class="final-scores-ok-btn" onclick="resolveCustomConfirm(true)">OK</button>
            </div>
        </div>
    </div>
    
    <!-- Golf Scorecard Save Modal (with Notes) -->
    <div id="golfScorecardSaveModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="golfScorecardSaveTitle">Game Complete!</div>
            <div id="golfScorecardSaveMessage" class="custom-dialog-message"></div>
            <div id="golfScorecardNotesSection" style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">Notes:</label>
                <textarea id="golfScorecardNotesInput" class="custom-prompt-input" style="min-height: 100px; resize: vertical; font-family: Outfit, sans-serif;" placeholder="Add notes about this round..."></textarea>
            </div>
            
            <!-- Save Options -->
            <div class="save-options-container">
                <div class="save-options-row">
                    <span class="save-options-label">Saved Data:</span>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveWinLoss" class="game-header-checkbox" checked>
                        <label for="saveWinLoss">Track Wins</label>
                    </div>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveScorecard" class="game-header-checkbox">
                        <label for="saveScorecard">Full Scorecard</label>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveGolfScorecardSave('cancel')">Close</button>
                <button class="final-scores-ok-btn" onclick="resolveGolfScorecardSave('save')">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Universal Game Completion Modal (for all games) -->
    <div id="gameCompletionModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="gameCompletionTitle">Game Complete!</div>
            <div id="gameCompletionMessage" class="custom-dialog-message"></div>
            <div id="gameCompletionNotesSection" style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">Notes:</label>
                <textarea id="gameCompletionNotesInput" class="custom-prompt-input" style="min-height: 100px; resize: vertical; font-family: Outfit, sans-serif;" placeholder="Add notes about this game..."></textarea>
            </div>
            
            <!-- Save Options -->
            <div class="save-options-container">
                <div class="save-options-row">
                    <span class="save-options-label">Saved Data:</span>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveWinLossGeneral" class="game-header-checkbox" checked>
                        <label for="saveWinLossGeneral">Track Wins</label>
                    </div>
                    
                    <div class="save-option-item">
                        <input type="checkbox" id="saveScorecardGeneral" class="game-header-checkbox">
                        <label for="saveScorecardGeneral">Full Scorecard</label>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveGameCompletion('cancel')">Close</button>
                <button class="final-scores-ok-btn" onclick="resolveGameCompletion('save')">Save</button>
            </div>
        </div>
    </div>
    <!-- Custom Prompt Modal -->
    <div id="customPromptModal" class="final-scores-modal">
        <div class="final-scores-content">
            <div class="final-scores-title" id="customPromptTitle">Input</div>
            <div id="customPromptMessage" class="custom-dialog-message"></div>
            <input type="text" id="customPromptInput" class="custom-prompt-input">
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="final-scores-ok-btn" onclick="resolveCustomPrompt(null)">Cancel</button>
                <button class="final-scores-ok-btn" onclick="resolveCustomPrompt(document.getElementById('customPromptInput').value)">OK</button>
            </div>
        </div>
    </div>
    <!-- Edit Golf Course Modal -->
    <div id="editCourseModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Add/Edit Course</div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 700; color: var(--text-primary);">Course Name:</label>
                <input type="text" id="editCourseName" class="custom-prompt-input" style="margin-top: 0;">
            </div>
            
            <div style="margin-bottom: 20px; max-height: calc(85vh - 200px); overflow-y: auto;">
                <div id="editCourseGrid" class="edit-course-grid"></div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeEditCourseModal()">Cancel</button>
                <button class="final-scores-ok-btn" onclick="saveEditedCourse()">Save changes</button>
            </div>
        </div>
    </div>
    
    <!-- Saved Scorecards Modal -->
    <div id="savedScorecardsModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Saved Golf Scorecard</div>
            <div id="scorecardDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Scorecard details will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeSavedScorecardsModal()">Close</button>
                <button class="final-scores-ok-btn" onclick="deleteCurrentScorecard()" id="deleteScorecardBtn">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Wins Tracker Modal -->
    <div id="winsTrackerModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title" id="winsTrackerTitle">Wins Tracker</div>
            <div id="winsTrackerDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Wins tracker stats will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="deleteAllScorecardsBtn" class="final-scores-ok-btn" onclick="window.deleteAllGameScorecards('golf')" style="display: none;">Delete All</button>
                <button class="final-scores-ok-btn" onclick="closeWinsTrackerModal()">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Game Statistics Modal -->
    <div id="customGameStatisticsModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title" id="customGameStatisticsTitle">Game Statistics</div>
            <div id="customGameStatisticsDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Custom game statistics will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeCustomGameStatistics()" style="flex: 1;">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Games Viewer Modal -->
    <div id="customGamesViewerModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Custom Games</div>
            <div id="customGamesDisplay" style="margin-bottom: 20px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                <!-- Custom games list will be displayed here -->
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeCustomGamesViewer()" style="flex: 1;">Close</button>
                <button class="final-scores-ok-btn" onclick="openCustomGameTrackingModal(); closeCustomGamesViewer();" style="flex: 1;">Add New Game</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Game Tracking Modal -->
    <div id="customGameTrackingModal" class="final-scores-modal">
        <div class="final-scores-content" style="max-width: min(95vw, 414px); width: calc(100vw - 20px); max-height: 85vh;">
            <div class="final-scores-title">Custom Game Tracking</div>
            <div style="margin-bottom: 10px; max-height: calc(85vh - 120px); overflow-y: auto; padding: 5px;">
                
                <!-- Game Type Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.95rem;">Game Type:</label>
                    <input type="text" id="customGameType" class="custom-game-field" placeholder="e.g. Chess, Backgammon, Cribbage" maxlength="30">
                </div>
                
                <!-- Date Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.95rem;">Date:</label>
                    <input type="date" id="customGameDate" class="custom-game-field">
                </div>
                
                <!-- Players Section -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.95rem;">Players:</label>
                    <div id="customGamePlayersContainer">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                            <input type="text" class="custom-player-input" placeholder="Player 1" maxlength="20" 
                                   style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                            <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                                   style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                            <input type="text" class="custom-player-input" placeholder="Player 2" maxlength="20" 
                                   style="flex: 1; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                            <input type="number" class="custom-player-score" placeholder="Score" inputmode="numeric"
                                   style="width: 80px; padding: 8px; background: var(--card-bg); border: 2px solid var(--neon-blue); border-radius: 8px; color: var(--text-primary); font-family: Outfit, sans-serif; font-weight: 400; font-size: 0.85rem; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); transition: all 0.3s ease; text-align: center;">
                        </div>
                    </div>
                    <button class="final-scores-ok-btn" onclick="addCustomGamePlayer()" style="padding: 8px 16px; margin-bottom: 15px; font-weight: 700;">Add More Players</button>
                </div>
                
                <!-- Winner Selection -->
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary); font-size: 0.95rem;">Winner:</label>
                    <select id="customGameWinner" class="custom-game-field">
                        <option value="">Select Winner</option>
                    </select>
                </div>
                
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="final-scores-ok-btn" onclick="closeCustomGameTrackingModal()" style="flex: 1;">Cancel</button>
                <button class="final-scores-ok-btn" onclick="saveCustomGame()" style="flex: 1;">Save Game</button>
            </div>
        </div>
    </div>
</body>
</html>
